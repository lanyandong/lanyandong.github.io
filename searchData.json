[{"title":"Java基础强化——Reflection","url":"/2019/09/02/2019-09-02-java-reflection/","content":"\n1、反射：在程序运行时通过一个类的对象获取这个类的信息的方法。\n\n2、Class类：在java里万事万物皆对象，可以理解为是Class类的对象，Class有一些方法可以由类的对象获取类的信息。获取一个class的Class实例有三种办法，如下：\n\n```java\npackage reflection;\n\npublic class ReflectionDemo {\n\t\n\tpublic static void main(String args[]) {\n\t\t// 实例对象如何表示\n\t\tClassDemo classDemo = new ClassDemo();\n\t\n\t\t// ClassDemo是类，其实也是一个实例对象是基于Class的。\n\t\t//方法1：（任何一个类都有一个隐含的成员变量class）\n\t\tClass c1 = ClassDemo.class; \n\t\t\n\t\t//方法2：（通过getClass()方法获取一个对象的类信息）\n\t\tClass c2 = classDemo.getClass(); \n\t\t\n\t\t// 两种表达式相同的\n\t\tSystem.out.println(c1 == c2);\n\t\t\n\t\t//方法3：通过Class的forName()方法\n\t\tClass c3 = null;\n\t\ttry {\n\t\t\tc3 = Class.forName(\"reflection.ClassDemo\");\n\t\t} catch (Exception e) {\n\t\t\t// TODO: handle exception\n\t\t}\n\t\t\n\t\t// 也是相等的\n\t\tSystem.out.println(c2 == c3);\n\t\t\n\t\t// 可以通过c1，c2, c3创建该类的对象\n\t\ttry {\n\t\t\tClassDemo classDemo2 = (ClassDemo)c1.newInstance(); // 根据实际情况进行强制类型转换\n\t\t\tclassDemo2.print();\n\t\t} catch (InstantiationException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (IllegalAccessException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\t\n\t}\n}\n\n// classdemo 类\nclass ClassDemo{\n\t\n\tvoid print() {\n\t\tSystem.out.println(\"class demo\");\n\t}\t\n}\n```\n\n3、静态加载和动态加载：静态加载时值程序在编译期的时候就完成了加载编译，比如new对象就是编译时加载的，已经创建好了对象实例。而动态加载时指在运行时需要使用的时候才进行加载，绕过编译且不报错。\n\n4、通过反射API获取类信息：使用Class的提供的方法可以获取一个对象的类的信息，包括成员变量，成员方法，构造方法，甚至包括接口信息，继承关系等。Java的反射API提供的`Field`类封装了成员变量的所有信息，`Method`对象封装了方法的所有信息，`Constructor`对象封装了构造方法的所有信息。\n\n5、动态代理：JDK提供的动态创建接口对象的方式，即没有实现类但是在运行期动态创建了一个接口对象的方式。\n\n```java\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\n// 定义一个InvocationHandler实例，它负责实现接口的方法调用；\n// 通过Proxy.newProxyInstance()创建interface实例，它需要3个参数：(使用的`ClassLoader`；需要实现的接口数组；用来处理接口方法调用的`InvocationHandler`实例。)\n//将返回的`Object`强制转型为接口。 \n\npublic class Main {\n\t\n\tpublic static void main(String args[]) {\n\t\t\n\t\tInvocationHandler handler = new InvocationHandler() {\n\t\t\t@Override\n\t\t\tpublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                System.out.println(method);\n                if (method.getName().equals(\"morning\")) {\n                    System.out.println(\"Good morning, \" + args[0]);\n                }\n                return null;\n            }\t\n\t\t};\n\t\t\n\t\tHello hello = (Hello) Proxy.newProxyInstance(\n\t            Hello.class.getClassLoader(), // 传入ClassLoader\n\t            new Class[] { Hello.class },  // 传入要实现的接口\n\t            handler); // 传入处理调用方法的InvocationHandler\n\t        hello.morning(\"Bob\");\n\t}\n}\n\ninterface Hello {\n    void morning(String name);\n}\n```\n\n6、代理模式和反射机制：动态代理是设计模式当中代理模式的一种（为其他对象提供一种代理以控制这个对象的访问），JDK的动态代理主要是使用的是反射机制。常应用于AOP（面向切面编程）、RPC（远程过程调用），反编译，EventBus 2.x，动态生成类框架等。\n\n优点：运行期类型的判断，动态类加载，动态代理使用反射；\n\n缺点：性能是一个问题，反射相当于一系列解释操作，通知jvm要做的事情，性能比直接的java代码要慢很多。","tags":["Java"],"categories":["学习笔记"]},{"title":"基于SSM框架的秒杀系统开发过程","url":"/2019/09/02/2019-09-02-ssm-seckill/","content":"\n1、数据库的设计\n\n2、开发环境的搭建\n\n- maven项目管理\n- pom.xml相关依赖配置\n\n3、DAO层的设计与开发\n\n- mybatis与spring的整合\n- Junit测试\n\n4、Service层的设计与开发\n\n- 接口设计与实现\n- 声明式事务\n\n5、Web层的设计与开发\n\n- SpringMVC 的整合\n\n- JSP的编写\n- bootstrap和js框架\n\n6、高性能优化\n\n- 事务管理优化\n- Redis缓存","categories":["JavaEE"]},{"title":"2019中国国际智能产业博览会","url":"/2019/08/29/2019-08-29-cse2019/","content":"\n今年的智博会还是有一些亮点的，去年作为志愿者没有时间参观会展，今年作为一名观众，花了了大概三四个小时把展馆走了一圈，发现还是有一些亮点的。我就对比看一下，就能感受到科技和产业的发展的一个简单趋势了。\n\n### 5G是今年最大的亮点\n\n虽然去年也有类似5G的展但都没有实实在在的产品落地，今年不一样，有很多产品已经落地了。虽然上半年已经有报道关于5G产品，但在咱这地方确实没有机会体验到，这次刚好有机会可以体验一下。\n\n5G手机，5G芯片，5G视频传输，反正5G带动的整个生态是非常强大的，5G的赋能让AI大数据，物联网和工业互联网的应用更加可行和可靠。三大运营商都推出了5g的解决方案。中兴亮相了5G的机站还有刚发布的中兴天机Axon10 Pro，体验感十足。\n\n![5g](https://s2.ax1x.com/2019/08/29/mqyaG9.jpg)\n\n由5G带动的一系列产业也慢慢有起色，像比物联网，5G传输应用在展会中也有出现。除此之外还有5G芯片，物联网芯片，手机芯片也都亮相了。\n\n![5gcore](https://s2.ax1x.com/2019/08/29/mqyBKx.jpg)\n\n### AI技术广泛应用\n\n除了5G以外，还有一些看点的就是AI，今年AI的产品应用比去年多了很多，AI的产品和应用基本成为现在大公司的基本布局。展会上有AI作画，AI语音识别，以及广受欢迎的图像识别，现在的图像识别已经能够做到又快又准，而且还能结合大数据进行分析，基本上已经比较成熟了。不过很多公司的产品都大同小异没啥看点。在我看来AI的最重要的还是算法PK吧。\n\n![ai](https://s2.ax1x.com/2019/08/29/mqyd2R.jpg)\n\n### 工业互联网和自动化\n\n工业互联网产业化基本已经定型，自动化水平越来越高，使用工业机器人来完成一系列工作已经成为提高生产力的重要方法。在展会上各种各样的工业机器人实操演示，还有各种应用解决方案在，只有我们想不到的，没有啥是做不到的。技术真的能改变生活！\n\n![gongye](https://s2.ax1x.com/2019/08/29/mqyt54.jpg)\n\n![gongye2](https://s2.ax1x.com/2019/08/29/mqyUPJ.jpg)\n\n### 技术带来的生活体验\n\n通过参展我发现了一些新的东西，就是目前一些大型互联网科技公司，做产品越来越注重用户的个人体验了，无论是从整个生态来讲还是单一的产品来说，大公司对于用户的体验和审美都有导向做作用，产品的设计更加的人性化，产品的理念更加新颖有创造力。\n\n![google](https://s2.ax1x.com/2019/08/29/mqyrqK.jpg)\n\n![8k](https://s2.ax1x.com/2019/08/29/mqyJVU.jpg)\n\n### 高校科研和国际合作\n\n展区还有高校的科研展区，国际展区，以及全国个省展区，还有重庆本地各县区展区，我都仔细的逛了一圈，有亮眼的黑科技，也有很平常的应用，虽然参差不齐，但却很全面。我们可以预见重庆发展会越来越迅速的。\n\n![gaoxiao](https://s2.ax1x.com/2019/08/29/mqyYaF.jpg)\n\n![gouji](https://s2.ax1x.com/2019/08/29/mqyDr6.jpg)"},{"title":"智力算法和一些有趣的算法题（LeetCode）","url":"/2019/08/21/2019-08-21-leetcode-ac/","content":"\n记录一些有意思的智力算法和一些有趣的算法题。\n\n##  [除数博弈](https://leetcode-cn.com/problems/divisor-game/)\n\n**题目描述：**\n\n爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。\n\n最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：\n\n选出任一 x，满足 0 < x < N 且 N % x == 0 。\n用 N - x 替换黑板上的数字 N 。\n如果玩家无法执行这些操作，就会输掉游戏。\n\n只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。\n\n**题解思路：**\n\n可以依次举例数字N的值，以及爱丽丝获胜的的情况，比如：\n\n| N的值 | 1     | 2    | 3     | 4         | 5         | 6    | 7     |\n| ----- | ----- | ---- | ----- | --------- | --------- | ---- | ----- |\n| A先手 | x     | (2)1 | (3)1  | (4)1-(2)1 | (5)1-(3)1 | (6)1 | (7)1  |\n| B后手 | x     | x    | (2)1  | (3)1      | (4)1      | (5)1 | (6)1  |\n| A获胜 | false | true | false | true      | false     | true | false |\n\n由已知的数学规律：奇数的因子（约数）只能是奇数，偶数的因子（约数）可以是奇数或偶数。然后举几个例子就能够发现一些其他规律：当N为奇数的时候，先手(A)只能够选择奇数，此时`奇数-奇数=偶数`，则一下个玩家面对的数据就为偶数，当玩家面对偶数时，可能会选择偶数因子也可能选择奇数因子，由规律发现只有先手数据为偶数时，A才能够获胜，相反情况则B获胜，所以在玩家最佳状态选择除数因子都会遵循：`N-除数因子 = 奇数`，这样对手就不会获胜了。\n\n**代码实现：**\n\n```java\nclass Solution {\n    public boolean divisorGame(int N) {\n        return N % 2 == 0;\n    }\n}\n```\n\n\n\n##  [2的幂](https://leetcode-cn.com/problems/power-of-two/)\n\n**题目描述：**\n\n给定一个整数，编写一个函数来判断它是否是 2 的幂次方。\n\n**解题思路：**\n\n传统解法：不停地去除以 2，看最后的迭代商是否为 1。\n\n```java\nclass Solution {\n    public boolean isPowerOfTwo(int n) {\n        if(n ==1)\n            return true;\n        while(n % 2==0){\n            n=n/2;\n        }\n        if(n == 1)\n            return true;\n        else \n            return false;\n    }\n}\n```\n\n利用二进制的解法：如果一个数是 2 的次方数的话，那么它的二进数必然是最高位为 1，其它都为 0 ，那么如果此时我们减 1 的话，则最高位会降一位，其余为 0 的位现在都为变为 1，那么我们把两数相与，就会得到 0。\n\n```java\nclass Solution {\n     public boolean isPowerOfTwo(int n) {\n        return n > 0 && ((n & (n - 1)) == 0);\n    }\n}\n```\n\n\n\n## [3的幂](https://leetcode-cn.com/problems/power-of-three/)\n\n**题目描述：**\n\n给定一个整数，写一个函数来判断它是否是 3 的幂次方。\n\n**解题思路：**\n\n与上面2的幂的解法类似，第一个方法是不停地去除以 3，看最后的迭代商是否为 1。\n\n```java\nclass Solution {\n    public boolean isPowerOfThree(int n) {\n\t\tif (n <= 0){\n\t\t\treturn false;\n\t\t}\n\t\tif (n == 1){\n\t\t\treturn true;\n\t\t}\n\t\twhile (true){\n\t\t\tif (n == 1){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (n % 3 > 0){\n\t\t\t\treturn false;\n\t\t\t}\n\t        else{\n\t\t\t\tn = n / 3;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n另外一种思路是将整数转换为3进制数的字符串，然后判断最高是否为1，其余位为0，但是3进制转换需要写一个转换方法，有点麻烦。\n\n所以可以再换一个思路，因为`3的次幂的质因子只有3`，因为根据数论相关定理，不考虑排列顺序的情况下，每个正整数都能够以唯一的方式表示成它的质因数的乘积。比如：1没有质因子。2、4、8、16等只有1个质因子：2（2是质数，4 = 2^2，8 = 2^3，如此类推），3的次幂的质因子只有3（3、9、27、81...）。\n\n又因为给定的是整数，故而题目中所给整数范围内最大的 3 的幂次的因子只能是 3 的幂次，而1162261467 是 3 的 19 次幂，是整数范围内最大的3的幂次。\n\n```java\nclass Solution {\n    public boolean isPowerOfThree(int n) {\n         return n > 0 && 1162261467 % n == 0;\n    }\n}\n```\n\n\n\n##  [4的幂](https://leetcode-cn.com/problems/power-of-four/)\n\n**题目描述：**\n\n给定一个整数 (32 位有符号整数)，请编写一个函数来判断它是否是 4 的幂次方。\n\n**解题思路：**\n\n直观思路，循环num=num/4检测num%4是否为0，直到num为1为止。注意，需考虑num为0的情况，否则会陷入死循环，码代码多考虑一些边界特殊情况.\n\n```java\nclass Solution {\n    public boolean isPowerOfFour(int n) {\n\t\tif(num == 0)\n            return false;\n \n        while(num != 1){\n            if(num%4 != 0)\n                return false;\n            num = num/4;\n        }\n        return true;\n    }\n}\n```\n\n不使用循环的解法：我们知道num & (num - 1)可以用来判断一个数是否为2的幂，其中4的幂是2的幂的一个子集，所以对2的幂做一些限制条件，4的幂都是在16进制下的第1和4位，即0101，所以我们只需和数(0x55555555) 进按位与，得到的数还是其本身，则可以肯定其为4的次方数。\n\n```java\nclass Solution {\n    public boolean isPowerOfFour(int num) {\n        return num > 0 && (num&(num-1)) == 0 && ((num&0x55555555)==num); \n    }\n}\n\n```\n\n","tags":["算法"],"categories":["算法"]},{"title":"利用Struts+Hibernate构建学生管理系统遇到的一些问题","url":"/2019/08/18/2019-08-18-ssh-test/","content":"\n私以为在学习过程中多一些BUG是有好处的，通过BUG可以学习很多新的东西，以及解决问题方法。当然遇到BUG首先应该仔细看报错信息，然后准确定位问题，不要盲目的百度检索。下面就来记录一下利用Struts+Hibernate构建学生管理系统遇到的一些问题，如果以后出现类似问题，方便查阅。\n\n### 1. jar包配置问题\n\n本次项目的开发环境为：Struts2.3 + hibernate3.0 + MySQL5.0，由于使用的是Eclipse，并没有使用Maven进行项目构建，所以所有的环境和需要的jar都需要手动配置。项目需要导入需要的核心jar包，包括：hibernate-core包，struts2-core包，mysql驱动包 junit单元测试包。\n\n所需要的jar包，大多可通过百度查的官方下载地址（<https://mvnrepository.com/>），下载需要的jar，然后导入到项目的WEB-INF目录下的lib目录中。\n\n\n\n### 2. 配置struts环境\n\n配置struts只需要简单的两部：\n\n1. 修改web.xml, 配置过滤器。这里需要弄清楚struts使用的版本。\n2. 创建struts.xml 并将文件保存在Java Resources 下的src目录下，struts.xml 是用来拦截请求转发至对应Action的，所以要完成Action注册。\n\n下面是一个简单的struts.xml配置例子：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE struts PUBLIC\n        \"-//Apache Software Foundation//DTD Struts Configuration 2.0//EN\"\n        \"http://struts.apache.org/dtds/struts-2.0.dtd\">\n<struts>\n    <!-- Struts xml的配置文件 -->\n    <!-- 所有匹配*.action的请求都由struts2处理 -->\n    <constant name=\"struts.action.extension\" value=\"action,,\" />\n    <!-- 是否启用开发模式 -->\n    <constant name=\"struts.devMode\" value=\"true\" />\n\n    <package name=\"default\" extends=\"struts-default\" namespace=\"/\">\n        <!-- 如果不指定method，那么默认方法是execute-->\n        <!--name:Action类的名字，具有唯一性，页面上通过name来访问Action类 -->\n\n        <action name=\"test\" class=\"test\" method=\"test\">\n            <!-- 配置结果集 :name属性的值一定要与execute方法的返回值一致-->\n            <result name=\"test\">test.jsp</result>\n        </action>\n    </package>\n    \n</struts>\n```\n\n\n\n### 3. hibernate相关配置\n\n创建hibernate.cfg.xml文件,并将文件保存在Java Resources 下的src目录下。配置文件包括两个核心部分：一个是property属性，主要配置的是数据库的链接。另外一个是mapping属性，指定关联的 .hbm.xml文件。\n\n另外指定currentSession()方法所得到的Session由谁来跟踪管理，thread指Session由当前线程来跟踪管理，这是一种事务配置的方式，实质上是只当前session通过当前执行的线程来跟踪和界定。\n\nhibernate还有一个很牛的feature就是可以用HQL，这是完全可以把查询映射到你OO模型的查询语言，我们可以不用过多关注SQL的编写，而更关注于数据和数据、对象和对象之间的关系。\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE hibernate-configuration PUBLIC\n\t\t\"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n\t\t\"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\">\n<hibernate-configuration>\n    <session-factory>\n\t\t<property name=\"connection.username\">root</property>\n\t\t<property name=\"connection.password\">root</property>\n\t\t<property name=\"connection.driver_class\">com.mysql.jdbc.Driver</property>\n\t\t<property name=\"connection.url\">jdbc:mysql://localhost:3306/studentms?useUnicode=true&amp;characterEncoding=utf-8</property>\n\t\t<property name=\"dialect\">org.hibernate.dialect.MySQLDialect</property>\n\t\t<!-- 执行操作时是否在控制台打印SQL -->\n\t\t<property name=\"show_sql\">true</property>\n\t\t<property name=\"format_sql\">true</property>\n        \t<!-- 指定自动生成数据表的策略 -->\n\t\t<property name=\"hbm2ddl.auto\">update</property>\n        \t<!-- 指定currentSession()方法所得到的Session由谁来跟踪管理，thread指Session由当前线程来跟踪管理 -->\n\t\t<property name=\"hibernate.current_session_context_class\">thread</property>\n\t\t<!-- 指定关联的 .hbm.xml文件 -->\n\t\t<mapping resource=\"entity/Students.hbm.xml\"/>\n\t\t<mapping resource=\"entity/Users.hbm.xml\"/>\n\t</session-factory>\n</hibernate-configuration>\n```\n\n关于实体和表的映射，需要生成相关.hbm.xml映射文件，用于向Hibernate提供关于将对象持久化到关系数据库中的信息，持久化对象的映射定义可全部存储在同一个映射文件中，也可将每个对象的映射定义存储在独立的文件中。后一种方法较好，因为将大量持久化类的映射定义存储在一个文件中比较麻烦，而且将难以调试和隔离特定类的映射定义错误。\n\n\n\n### 4. 设计接口和实现类\n\n面向接口编程是OOP的设计原则之一，目的是就是降低程序的耦合性，接口定义统一的编程规范，实现类可以根据具体的业务逻辑实现特定的功能，既利于程序的扩展，也利于程序的维护。\n\n在对数据库进行管理时，可以利用Hibernate的 SessionFactroy接口，创建会话工厂对象，它充当数据存储源的代理，并负责创建Session对象。一般情况下，一个项目通常只需要一个SessionFactory就够，然后在其他类中调用其中的方法就OK了。下面就是一个简单的创建会话对象的类方法。\n\n```java\nimport org.hibernate.SessionFactory;\nimport org.hibernate.boot.registry.StandardServiceRegistryBuilder;\nimport org.hibernate.cfg.Configuration;\nimport org.hibernate.service.ServiceRegistry;\n\n\n// 会话工厂类,目的获得SessionFactory对象\npublic class MyHibernateSessionFactory {\n\t\n\tprivate static SessionFactory sessionFactory; //会话工厂属性\n\t// 构造函数保证单例模式\n\tprivate MyHibernateSessionFactory(){\n\t\t\n\t}\n\t//共有的静态方法，获得会话工厂对象\n\tpublic static SessionFactory getSessionFactory(){\n\t\tif(sessionFactory==null){\n\t\t\t//创建配置对象\n\t\t\tConfiguration config = new Configuration().configure();\n\t\t\t//创建服务注册对象  \n\t\t\tServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder().applySettings(config.getProperties()).build();\n\t\t\t//创建sessionFactory\n\t\t\tsessionFactory = config.buildSessionFactory(serviceRegistry);\n\t\t\treturn sessionFactory;\n\t\t}else{\n\t\t\treturn sessionFactory;\n\t\t}\n\t}\n}\n```\n\n\n\n利用Hibernate的Query，Transaction和Session可以完成数据库事务的管理操作，Query负责执行各种数据库查询。它可以使用HQL语言或SQL语句两种表达方式。它的返回值一般是List，需要自己转换。Transaction接口负责事务相关的操作，一般在Hibernate的增删改中出现，但是使用Hibernate的人一般使用spring)去管理事务。\n\n这里值得注意的是Hibernate的Session接口， Session可以看作介于数据连接与事务管理一种中间接口，有时也称Session是一个持久层管理器，因为它包含这一些持久层相关的操作，如存储持久对象至数据库，以及从数据库从获得它们。\n\n在Hibernate中，实例化的Session是一个轻量级的类，创建和销毁它都不会占用很多资源，这不同于JSP 应用中的HttpSession，一般情况我们会会HttpSesion 对象称为用户session。\n\n### 5.  设计Action控制器\n\n在项目中Action承担着一个控制业务调度和管理跳转的功能，Action就像是服务员，顾客点什么菜，菜上给几号桌，都是ta的职责；所以当实现功能后，需要在struts.xml 中进行注册，与JSP的请求相对应，并完成相应的界面调用。\n\nStruts接受的表单数据的方式有几种方式，分别是实体类对象，属性驱动，模型驱动的方式和表达式驱动等，具体采用哪种需要根据具体的业务逻辑来选择，没有最好的，只有最合适的。\n\n可以直接使用Validator(验证器)框架对表单数据进行验证，而不需要用户编写代码去验证，拦截器是在Action提交之前，动态的拦截Action，然后查询配置文件，如果当前的Action配置了拦截器，那么就相应的实例化出拦截器对象，并串联成表，最后一个一个调用拦截器。\n\n拦截器只对Action进行处理，对其余的不进行处理。拦截器可以读取值栈中的东西，就像登录验证时，拦截器可以读取Session的内容。拦截器一次创建可以多次被调用，只要是使用拦截器的Action，Action执行几次，拦截器就同样执行几次。\n\n\n\n### 6. 项目框架\n\n项目中没有使用spring进行解耦，而是将hibernate和struts进行整合，项目也基本上符合MVC的一个设计理念：\n\nEntity对应数据库表的实体类，Dao层是使用hibernate连接数据库、操作数据库（增删改查）定义了一些列操作数据库的接口，Service层：引用对应的Dao数据库操作。在一定程度上Dao层和Service可以写在一起。以上几层综合起来类似于MVC的模型层。\n\nAction层：处理业务调度和管理跳转，引用对应的Service层，结合Struts的配置文件，跳转到指定的页面。起到一个控制层的作用。\n\n最后是JSP表现的视图层，可以通过编写JSP进行请求和数据显示，这里可以使用struts的一些标签，通过用户session读出数据。JSP真的太难写了ORZ...前后端分离是相当有必要的，使用页面模板也是很有必要的。\n\n整个项目的调用流程基本上是：**JSP—Action—Service—DAO—Hibernate**。整个项目框架的优点是：利用Struts负责Web层，进行请求拦截。利用Hibernate负责持久化层，完成对数据库的crud操作。\n\n\n\n### 7. 问题总结\n\n通过上面的总结，把项目构建的重要步骤和项目的框架流程都进行分析，从零开始，一步步的构建一个完整项目，真的能够学到很多东西。熟能生巧，多看多思多动手，技术能力自然就有增长咯。\n\n\n\n\n\n\n\n\n\n","tags":["JavaEE"],"categories":["JavaEE"]},{"title":"秋招之前","url":"/2019/08/12/2019-08-12-before-recruitment/","content":"\n接近八月中旬，秋招也陆陆续续的开始了。回想自己的春招经历，也是惨目忍睹，由于缺乏准备和自身能力的欠缺，错失了很多很好的机会。春招的试错，为秋招的准备提供了一个很好的指导，通过自己近段时间的学习和查缺补漏，技术栈和基础知识都得到了提升和巩固。但面对秋招，我觉得还是有很大的欠缺，下面就总结一下自己近段时间所学以及要努力提升的东西。\n\n从暑假实习结束回到学校，首先将上个学过的课程内容进行了简单的整理总结，因为上个学期的很多课程都还是比较重要，比如数据库，Java等都是自己将来工作中会常常使用的，嵌入式和计算机体系结构这些课程是对计算有更深入的了解，在之前的几篇博文中也总结了自己通过课程学习的所思所感所获。我们学的很多东西都很基础，对于自己职业发展也并没有很明显的帮助，所以将很多关键性的东西我都将其总结并同步到Github上了，如果以后涉及到了的话方便查看。\n\n总结春招的失误的教训，很多原因是由于基础不劳造成的，所以花费了一些时间来巩固基础的内容，包括操作系统，计算机网络，还有数据结构和算法。回顾了之前记录的笔记和参考了网上的一些内容，把计算机网路和操作系统的核心内容提取了出来，并构建了自己的Learning Notes（<https://smallseven.top/mkdocs-notes/>）。花费时间比较多的是数据结构和算法，之前学习的时候只是了解了大致的思想，并没有通过编程去实现它，这次通过Java编程实现了常用的排序算法和一些基础的数据结构，对这些知识又有了新的认识。\n\n关于Java的基础，将《Java基础教程》过了一遍，了解了一些不常用的方法和工具包。《Java编程思想》这本书写得比较详细深入，只看了几章自己觉得欠缺的内容。另外《Java数据结构和算法》基本上看完一遍，并把一些例子实现了。为了拓展内容还专门看了一些清华邓俊辉的数据结构，不愧是大师讲的内容，思路惊奇并且理论依据充足，记忆最深的是在讲Hash时，关于Hash函数的设计和减少冲突的算法就讲了很多种，并且都进行性能分析和对比，让人受益匪浅，如果有时间可以深入的了解一下。为了查缺补漏快速的过了一遍清华郑莉的Java基础课程，内容比较简单但还是有一些额外的收获，比如了解了更多关于Object类，继承多态，抽象类等方面的东西。通过对基础的复习，很多内容得到了巩固，最缺乏的就是练习了。\n\n关于Java Web开发的学习，学习过程并没有很清楚的路线，这也正是我比较担心的东西，Java后台开发涉及的东西很多，如果每一样都要学会才去上手实践，这大概可能不太现实，所以自己零零碎碎的学了一些东西，首先把SpringMVC框架的底层内容了解了一下，其次是将程序猿DD的SpringBoot的基础教程看了一遍。看完之后感觉学到了东西，又感觉什么也没学到，自己也很方。关于框架的学习还真得找大佬取取经。另外，还看了《深入理解Java虚拟机》，对于其中的Java内存模型，垃圾回收有了更深入的认识。至于Java的设计模式还没有看，但对OOP的设计原则有了一些了解。\n\n关于自己的技术栈，大致应该是以Java语言为核心的后端开发为主，去学习了解更多框架，熟悉业务流程，前后端分离以及近些年前端的崛起，后端也越来越苦逼，总有学不完的框架，而这些框架大多为了提高开发效率而屏蔽了底层实现细节，这对于开发人员是好是坏？自己的技术路线该如何选择，上天还是入地，这真是一个值得思考的问题。对于现在我自己的技术能力对于强大的后端开发而言，真的是连入门都算不上，这一点我自己十分清楚。对于一个应届生而言，大概其核心竞争力就是学习能力和专业基础知识，还有各方面的综合软实力，对于技术能力可能并不是企业关注的重点，但技术仍可能也是衡量一个人学习能力的一个重要指标，至少我认为。\n\n说了那么多，还是简单的列一下计划吧：\n\n* 抓紧时间弄几个有技术含量的项目，首先是巩固自己的知识，其次计算机本来就是实践出真知的一门学科，Coding是最基础的。尽量挖掘技术深度，这是一个区别于大数人的好办法，熟练精通某项技能是有必要的，而不是单纯的了解一些东西。\n* 结果才是反映能力的核心，做事尽量以结果为导向，有明确的目标才更容易坚持，过程啥的自己体会就够了。经常给自己一些正反馈，小小的成就感是很有必要的，尝试一些小的东西并做到完美，给自己一些正反馈会更加有动力。\n* 适当的压力是有必要的，经常做一些To Do List不仅可以提高效率还可以驱动自己，我现在已经开始了TWIL计划，记录每周所学，另外还计划每周至少一篇技术文章，花费一些时间，坚持做一件小事。\n* 警惕注意力劫持，这是最近了解到的一个词语，说的是很多信息流劫持了我们的注意力，会导致工作效率下降。所以应该注意这一点，自己的计划是主动屏蔽一些不相关的信息流，控制自己的好奇清晰，减少刻意强迫的行为。\n\n这是写在秋招之前的一篇小的总结，也安排了一些适当的计划。希望自己可以身体力行，做事时能够沉得下心，多一些专注力，一步一个脚印的来。保持积极良好的心态，秋招加油！\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["随笔集"]},{"title":"Java Web开发入门总结篇","url":"/2019/07/24/2019-07-24-learn-spring/","content":"\n### Java Web 相关概念\n\n在Java开发中很多概念性的名词，对于一个开发人员来说，是有必要了解它们的基本概念和含义的，要不然在看一些技术文章时会很懵，或者会混淆一些基础概念性的东西。就此，我对自己所理解的一些概念性的东西进行简单的梳理。\n\n**Java EE**：(Java Platform Enterprise Edition)是Java面向企业应用的一个平台，类似于一种标准规范，就目前的各种表达如J2EE，JavaEE，JEE其实说的都是同一个东西。JavaEE 比JavaSE (Java Platform, Standard Edition)增加面向企业的开发支持，包括Servlet，WebSocket，EL，EJB 等。\n\n**Servlet**：是Web开发离不开的组件，Servlet 是一套用于处理 HTTP 请求的 API 标准，也可以理解为运行在Server端的小程序，用于响应客户端的HTTP请求。和Servlet对应的有一个Applet，这是运行于客户端的一种小程序组件，主要应用于web浏览器端。\n\n另外，不得不提的是**JSP**（Java Server Pages），它是一种高度抽象的Servlet，JSP在运行期间会被编译成Servlet，其实本质上Servlet和JSP没啥区别，但JSP写起来要方便的多。\n\n**EJB**： （Enterprise JavaBean）也是JavaEE的一个组件，面向更加复杂的企业业务，对于Web开发来说，EJB不是必须的。对于上面提到的Servlet，如果要运行的话需要Servlet Container，而常用的Container包括Tomcat，JBoss，Jetty等。对于EJB而言，同一样也需要EJB Container，JBoss提供了EJB的支持，但Tomcat并不支持EJB。\n\n**SSH**：（Struts+Spring +Hibernate）是一个Java Web开发的合成框架。Struts进行流程控制，Spring进行业务流转，Hibernate进行数据库操作的封装。事实上JavaEE开发可以仅使用Servlet和JSP技术，在JSP上构建View，实现业务逻辑。但随着技术的进步和发展，纯JSP技术可能并不能满足业务需求和开发效率的要求，所以衍生了一些列如SSH的结合框架。\n\nStruts更多的是面向JSP和View，而Spring则是一个非常庞大的框架，其中包括了SpringMVC，SpringBoot 以及 SpringCloud 等用于 Web 开发的工具。而Hibernate则是一种ORM框架，是一种对象关系映射关系，简化了数据的处理和访问。\n\n**SSM**：（Spring+SpringMVC+MyBatis）同样是一个Java Web开发的合成框架，是标准的MVC模式，将整个系统划分为表现层，controller层，service层，dao层四层。Spring实现业务对象管理，Spring MVC负责请求的转发和视图管理，MyBatis作为数据对象的持久化引擎。\n\n至此，关于Java Web开发的一些概念词汇大致梳理了一遍，但都没有详细讲解它们的基本原理和架构，这需要在具体的实践中去体验。另外需要注意的是区分JavaEE，Java Web，Spring它们的关系，**JavaEE可以理解为是一种Java的标准，而Java Web则是指Java的应用开发方向，而Spring则是Java Web开发的框架。**\n\n\n\n### Spring 框架模块\n\n**Spring有七大功能模块，分别是Spring Core，AOP，ORM，DAO，WEB，Context，MVC。**\n\n![spring](https://s2.ax1x.com/2019/07/25/eZjFC4.gif)\n\n每个模块的作用如下：\n\n- **核心容器（Spring Core）**：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用*控制反转* （IoC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。\n\n- **Spring AOP**：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。\n\n- **Spring DAO**：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。\n\n- **Spring ORM**：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。\n\n- **Spring Context**：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。\n\n- **Spring Web 模块**：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。\n\n- **Spring MVC 框架**：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。\n\n  \n\n**Ioc Container**：反转控制模式它是Spring的一个基础，也是最重要的。它不创建对象，但是描述创建对象的方式，在代码中也不直接与对象和服务连接，但在配置文件中描述了哪一个组件需要哪一项服务。在Spring框架中，IoC容器的实现模式主要有两种是：\n\n1. 通过JavaBean属性（例如 setter 方法）分配依赖性。\n2. 依赖性以构造函数的形式提供，不以JavaBean 属性的形式公开。\n\n```java\n/**IoC容器创建 HelloWorldService 对象，是通过 setter 方法传递 HelloWorld 对象到HelloWorldService。**/\n\npublic class HelloWorldService {\n  \n    private HelloWorld helloWorld;\n  \n    public HelloWorldService() {\n  \n    }\n    // 依赖注入\n    public void setHelloWorld(HelloWorld helloWorld) {\n        this.helloWorld = helloWorld;\n    }\n  \n    public HelloWorld getHelloWorld() {\n        return this.helloWorld;\n    }\n}\n\n```\n\n\n\n### Spring MVC\n\nSpring web MVC框架提供了MVC(模型 - 视图 - 控制器)架构和用于开发灵活和松散耦合的Web应用程序的组件。 MVC模式导致应用程序的不同方面(输入逻辑，业务逻辑和UI逻辑)分离，同时提供这些元素之间的松散耦合。\n\n- 模型(Model)封装了应用程序数据，通常它们将由`POJO`类组成。\n- 视图(View)负责渲染模型数据，一般来说它生成客户端浏览器可以解释HTML输出。\n- 控制器(Controller)负责处理用户请求并构建适当的模型，并将其传递给视图进行渲染。\n\n模型 - 视图 - 控制器(MVC)框架是围绕DispatcherServlet设计的，它处理所有的HTTP请求和响应。\n\n![DispatcherServlet](https://s2.ax1x.com/2019/07/25/eZjk8J.png)\n\n**DispatcherServlet**的请求处理工作流：\n\n1. 在接收到HTTP请求后，DispatcherServlet会查询HandlerMapping以调用相应的Controller。\n\n2. Controlle接受请求并根据使用的`GET`或`POST`方法调用相应的服务方法。 服务方法将基于定义的业务逻辑设置模型数据，并将视图名称返回给DispatcherServlet。\n3. DispatcherServlet将从ViewResolver获取请求的定义视图。\n4. 当视图完成，DispatcherServlet将模型数据传递到最终的视图，并在浏览器上呈现。\n\n\n\n### Spring Boot\n\nSpringBoot 是构建在 SpringMVC 基础上的新一代 Web 开发框架。相比 SpringMVC，SpringBoot 的配置更简单，上手更容易。在纯的Spring MVC配置中，要启动一个web程序demo，需要进行很多配置，包括一些复杂的Annotation，Controller是需要理解和明白的。但是在Spring Boot中，减少了大量的配置，提供了一种简单应用程序入门的方式。\n\nSpring Boot会根据使用`@EnableAutoConfiguration`批注添加到项目中的依赖项自动配置应用程序。spring boot应用程序的入口点是包含`@SpringBootApplication`注释和`main`方法的类。\nSpring Boot使用`@ComponentScan`注释自动扫描项目中包含的所有组件。为了更好的适应包扫描机制，避免一些特殊的配置工作，可以参考下面的工程结构。\n\n```\ncom\n  +- example\n    +- myproject\n      +- Application.java\n      |\n      +- domain\n      |  +- Customer.java\n      |  +- CustomerRepository.java\n      |\n      +- service\n      |  +- CustomerService.java\n      |\n      +- web\n      |  +- CustomerController.java\n      |\n```\n\n- `root package`：`com.example.myproject`，所有的类和其他package都在root package之下。\n\n- 应用主类：`Application.java`，该类直接位于`root package`下。通常我们会在应用主类中做一些框架配置扫描等配置，我们放在root package下可以帮助程序减少手工配置来加载到我们希望被Spring加载的内容\n\n- `com.example.myproject.domain`包：用于定义实体映射关系与数据访问相关的接口和实现\n\n- `com.example.myproject.service`包：用于编写业务逻辑相关的接口与实现\n\n- `com.example.myproject.web`：用于编写Web层相关的实现，比如：Spring MVC的Controller等\n\n  \n\n**使用IDEA Spring Boot工程的两种方法**\n\n1. 使用Maven构建项目：通过访问<https://start.spring.io/> 生成一个基础项目下载解压，用IDE 以Maven项目导入。\n\n2. 使用Intellij IDEA中的Spring Initializr工具，直接创建生成。\n\n   \n\n### 简单总结\n\n以上就是我关于Java Web，以及Spring框架的了解，至于Spring Cloud还没来得及去仔细学习，最开始自己是使用Eclipse构建项目，觉得Eclipse是世界上最好的IDE，但自从入坑Java web项目后，需要配置Tomcat，编写Servlet和JSP，进行各种Annotation以及SSH和SSM环境的搭建，真的是太麻烦了，常常在深夜红着眼睛和各种配置BUG做斗争，也时常因为环境配置问题而导致心态奔溃选择了放弃。但自从使用了IDEA，使用了Spring Boot，搭建应用分分钟搞定，再也不会因为环境配置的问题而烦恼，终于可以快乐地写代码了，于是我就已经知道我再也回不到Eclipse时代了。\n\n","categories":["学习笔记"]},{"title":"Hash-Map-HashMap","url":"/2019/07/19/2019-07-19-hash-map/","content":"\n在平时coding时虽然经常会用到`HashMap`，但没有仔细思考它的实现原理，也常常将`HashTable`，`HashMap`，`TreeMap`等概念特性混淆，最主要原因是不太理解它们的底层逻辑，后面仔细思考了一下，发现自己竟然分不太清Hash和Map，后面查了一些资料，总算是弄明白了一些，记录一下。\n\n### Hash是啥？\n\n`Hash又`称散列，它表示的是通过一个输入值，通过装换算法输出一个对应的值，这个装换算法是一种映射关系，又叫做`Hash函数`，hash函数能够使对一个数据的访问过程更加有效，通过hash函数，数据元素可以快速的被定位。hash算法也并不是唯一的，在不同的应用中有不同的hash算法，比如常见的的`FNK`算法，`CRC`系列算法，`MD5`，`SHA-1`等。\n\n### HashTable是啥？\n\n`HashTable`是hash函数的一个主要应用，使用散列表能够快速的查找数据记录，是一种可以根据键值对直接访问的数据结构，它通过把关键码映射到表中的一个位置来访问记录，从而加快了查找的速度，`HashTable`是数组和链表的结合，使用Hash函数将被查找的键转化为数组的索引，然后根据索引就可以定位到数据记录，当然在进行转化时会发生hash冲突，如果单桶存储的数据条目过多，将会导致性能下降，这时候就需要考虑是否要使用rehash方法进行扩容了。\n\n### Map是啥？\n\n`Map`是一种关联容器，它提供了一对一的数据处理能力，这与上面所述的hash好像是一个东西，但其实并非这样，在网上也很难找到这两者的具体定义和区别，我个人理解的是Hash更强调的是一种算法，而`Map`则是一种数据结构（容器），维基百科中是这样定义Map的：\n\n>  **map**：In computer science, an associative array, map, symbol table, or dictionary is an abstract data type composed of a collection of (key, value) pairs, such that each possible key appears at most once in the collection.\n\n在C++的STL中`Map`是一个标准容器，在Java中`Map`是定义的一个接口，我们常用的`HashMap`，`LinkedHashMap`都实现了该接口。\n\n### HashMap是啥？\n\n`HashMap`存储数据采用的是散列表结构（数组+链表的结构），在JDK8中`HashMap`的底层数据结构已经变为数组+链表+红黑树的结构，这主要原因是为了减少之前提到的hash冲突带来的影响。\n\n**`HashMap`的基本原理**是散列表+拉链法，就是在往`HashMap`中put元素时，会先根据key的hash值得到这个元素在数组中的位置（即下标），然后把这个元素放到对应的位置中。如果这个元素所在的位子上已经存放有其他元素了，那么在同一个位子上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。\n\n实际情况下，我们希望HashMap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素是我们想要元素，而不用再去遍历链表。最容易的做法就是把hashcode对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是“模”运算的消耗是比较大的，在Java中选择了另外一种更快速，消耗更小的方式：**首先算得key得hashcode值，然后跟数组的长度-1做一次“与”运算（&）**\n\n```java\nstatic int indexFor(int h, int length) {\n\treturn h & (length-1);\n}  \n```\n\n在`HashMap`中get()方法的执行过程是：首先计算key的`hashcode`，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。所以`hashcode`与`equals`方法是找到对应元素的两个关键方法，通过改写key对象的`equals`和`hashcode`方法，我们就可以将任意的业务对象作为map的key。在判断两个对象是否真的相等时，必须保证它们的`hashcode`相同，且保证调用 `equals() `方法返回true。\n\n### TreeMap是啥？\n\n`TreeMap`在存储数据时是安装特定顺序存储的，并非像`HashMap`那样无明显顺序，最主要的原因是其底层原理不同，`TreeMap`的本质是红黑树，红黑树理解起来是比较复杂的，在此就不做展开了。\n\n\n\n### 补充1：HashMap扩容\n\n在JDK7中，`HashMap`数据结构是数组+链表的方式，`HashMap`内存储数据的Entry数组默认是16，如果没有对Entry扩容机制的话，当存储的数据一多，Entry内部的链表会很长，这就失去了`HashMap`的存储意义了，所以`HasnMap`内部有扩容机制来进行处理。\n\n在`HashMap`内部有：变量size，记录`HashMap`的底层数组中已用槽的数量；变量threshold，它是`HashMap`的阈值，用于判断是否需要调整`HashMap`的容量（threshold = 容量*加载因子）；变量DEFAULT_LOAD_FACTOR = 0.75f，默认加载因子为0.75。\n\n`HashMap`扩容的条件是：当size大于threshold时，对`HashMap`进行扩容。\n\n```java\n//举个例子假如现在有三个元素（3,5,7）要放入map里面，table的的容量是2，如下\n[0]=null  \n[1]=3->5->7  \n\n//现在将table的大小扩容成4，分布如下：\n[0]=null  \n[1]=5->7  \n[2]=null  \n[3]=3  \n```\n\n在JDK8里面，`HashMap`的底层数据结构已经变为数组+链表+红黑树的结构了，因为在hash冲突严重的情况下，链表的查询效率是O(n），所以JDK8做了优化对于单个链表的个数大于8的链表，会直接转为红黑树结构算是以空间换时间，这样以来查询的效率就变为O(logN)。\n\n简单总结就是，JDK7里面是先判断table的存储元素的数量是否超过当前的`threshold=table.length*loadFactor（默认0.75）`，如果超过就先扩容，在JDK8里面是先插入数据，插入之后在判断下一次`++size`的大小是否会超过当前的阈值，如果超过就扩容。 \n\n\n\n### 补充2：区别Collection和Map\n\nCollection 和Map 是Java容器类库的两种主要类型，最主要的区别在于Collection保存的是单个元素，而Map保存的是一个键值对。\n\n下面例子展示了一些基本类型的容器，第一个 fill() 可以用于所用类型的Collection，这些类型都实现了用来添加新元素的 add() 方法。而第二个 fill()  使用与Map，它们都实现了添加键值对的 put()  方法。\n\n```java\nimport java.util.*;\n// 容器的打印\npublic class PrintingContainers {\n\n    static Collection fill(Collection<String> collection){\n        collection.add(\"rat\");\n        collection.add(\"cat\");\n        collection.add(\"dog\");\n        collection.add(\"dog\");\n\n        return collection;\n    }\n\n    static Map fill(Map<String, String> map){\n        map.put(\"rat\", \"Fuzzy\");\n        map.put(\"cat\", \"Rags\");\n        map.put(\"dog\", \"Bosco\");\n        map.put(\"dog\", \"Spot\");\n\n        return map;\n    }\n\n\n    public static void main(String args[]){\n        // List 类型\n        System.out.println(fill(new ArrayList<String>()));\n        System.out.println(fill(new LinkedList<String>()));\n\n        // Set 类型\n        System.out.println(fill(new HashSet<String>()));\n        System.out.println(fill(new TreeSet<String>()));\n        System.out.println(fill(new LinkedHashSet<String>()));\n\n        // Map 类型\n        System.out.println(fill(new HashMap<String, String>()));\n        System.out.println(fill(new TreeMap<String, String>()));\n        System.out.println(fill(new LinkedHashMap<String, String>()));\n\n    }\n}\n```\n\n`ArrayList` 和 `LinkedList` 都是List类型，都是按照插入了顺序保存元素，`ArrayList `可以理解为动态数组，`LinkedList`可以理解为链表，两者最主要的区别在于执行某些类型的操作时的性能。\n\n`HashSet`，`TreeSet` 和`LinkedHashSet`都是Set类型，在Set类型中每个元素只不留一次，不会出现相同的项，它们的一个主要区别是存储元素的方式不同，`HashSet`是以散列的形式保存元素，所以是无序的，而`TreeSet`是以树的形式存储数据，是按照一定的顺序要求保存的。而LinkedHashSet则是按照添加的顺序保存对象的。\n\n`HashMap`，`TreeMap`和`LinkedHashMap`都是Map类型，保存都是键值对（key—value），`HashMap`没有按照任何明显的顺序来保存其元素，但查找效率是比较快的，它有自己的算法来控制顺序，`TreeMap`则是按照某种特定顺序来保存键的，`LinkedHashMap`则是按照插入顺序保存键，并且保存了`HashMap`的查询速度。\n\n\n\n**Tips：**\n\n **1、越底层的东西越复杂,当然也越有用！2、专业的书比网上的资料更全面更详细。3、好奇心和求知欲是第一驱动力。**\n\n","tags":["Java"],"categories":["学习笔记"]},{"title":"VMware-Linux","url":"/2019/07/11/2019-07-11-vmware-linux/","content":"\n### 0x00 前言\n\n对于Linux系统，现在基本上属于能够熟练使用常用命令，做一些配置的水平，还是不太熟悉其开发，对于底层原理也不是很了解，自己使用Linux系统主要是VMware安装的Ubuntu，和阿里云的CentOS，这篇文章主要记录一下使用Ubuntu的一些操作，熟悉的就不赘述，记录一些我自己不熟的。\n\n\n\n### 0x01 安装使用\n\n想要使用Linux 系统，可以安装虚拟机，然后安装Linux系统（Ubuntu还不错）。\n\n1、首先安装 VMware，找到安装包，不需要啥配置，傻瓜式操作。\n\n![img](https://s2.ax1x.com/2019/07/11/Z2kVyR.md.png)\n\n安装好，就可以安装系统了，这时候需要一个系统镜像，也很容易找到，可以安装Ubuntu，CentOS，看自己需求吧。\n\n2、这时候就需要一些配置了，包括安装路径，给系统进行个性化配置以及分配存储空间，按照安装向导弄就成了，这个安装可能需要一点时间。\n\n![img](https://s2.ax1x.com/2019/07/11/Z2kQYD.md.png)\n\n安装好就使用之前设置的用户和密码登录就成了。这前我安装过VMware，也安装过Ubuntu系统，不知道什么原因用着有点卡，而且联网也总是出问题，体验不是很好，这次重新安装了一下，感觉好用了很多，所以如果发现软件不好用，卸载重装可能也是一种解决办法吧。\n\n要是想联网的话把网络适配改成桥接模式（主机和虚拟使用同一IP）。\n\n \n\n### 0x02 常用命令\n\n总结一些Linux常用命令，主要是这前不太熟悉的：\n\n可以通过查找打开终端，也可以使用快捷键 `ctrl+alt+T `打开。\n\n查看主机名：`hostname`\n\n查看IP信息：`ifconfig`\n\n查看网络端口：`netstat -ntlp`\n\n查看CPU信息：`cat /proc/cpuinfo`\n\n查看进程信息：`ps aux  `\n\n使用`ps aux |grep xxx `可以过滤\n\n结束某个进程：`kill -9` 进程ID\n\n查看目录文件详细信息：`ls -al`\n\n(cdl)rwx r-x r-x 文件相关权限显示的标识\n\n创建一个文件：`touch filename`\n\n可以使用vi 进行编辑，也可以使用gedit 命令编辑，当然有些目录或文件是有权限限制的，可以使用sudo 来进行一些操作。\n\n查看文件详细信息可以使用 `file filename`\n\n删除文件 `rm `\n\n删除目录` rm rf`\n\n查找文件：`find ./ -name filename `（find 查找目录 文件名）\n\n也可以进行匹配查找：`find ./ -name *.c`\n\n安装软件可以是使用：`sudo apt-get install `软件名\n\n比如安装git，可以使用`sudo apt-get install git`\n\n\n\n### 0x03 源码安装\n\n源码编译安装nginx 并进行相关配置\n\n首先去官网下载源码安装，安装包很小，很快就能下载好。\n\n然后进行解压\n\n`tar -zxvf nginx-1.17.1.tar.gz`\n\n这是直接解压到当前目录下，也可以指定解压目录。\n\n进入解压好的目录里cd nginx-1.17.1/ 可以查看到一个configure 文件，在这个目录下执行configure文件：`./ configure --prefix=/usr/local/nginx `并指定安装的路径，这里表示安装在local/nginx路径下。运行时可能会报错说缺少一些模块，可以根据实际情况添加或或者不添加，在运行命令后追加配置，重新执行就行。\n\n![img](https://s2.ax1x.com/2019/07/11/Z2kEl9.png) \n\n然后编译nginx，使用make命令，这里make会查找执行Makefile文件。（Makefile 定义整个工程的编译规则，可实现自动化编译，make命令是解释Makefile中的指令）。\n\n编译完成后可以使用`make install `进行安装，安装完成后就可以在之前设置的目录里看到用nginx的文件。\n\n![img](https://s2.ax1x.com/2019/07/11/Z2kmex.md.png)\n\n到此位置nginx就编译安装成功了，但为了使用nginx方便一些，我们可以配置环境或者是设置软连接，就可以直接通过 nginx命令来启用后禁用服务器了。\n\n配置环境变量`sudo gedit /etc/profile`\n\n将你的解解压好的目录添加进去\n\n`export PATH=\"$PATH:/usr/local/nginx/sbin\"`\n\n设置软连接，其实就将一个文件下的文件连接到另一个文件夹，达到简化切换目录的麻烦。\n\n`ln -s /usr/local/nginx/sbin/nginx /usr/bin/nginx`\n\n配置好以后就可以使用nginx了。\n\n使用`sudo nginx `启动nginx，使用`sudo nginx -s stop `命令关闭nginx。\n\n可以测试一下：nginx 默认端口是80，在浏览器中输入localhost:80\n\n![img](https://s2.ax1x.com/2019/07/11/Z2kASJ.png)\n\n\n\n ### 0x04 交叉编译\n\n交叉编译器（Linux Ubuntu编译程序--在开发板上运行）\n\n下载安装包\n\n解压/解压路径（设置路径 -C 要大写）\n\n`sudo tar jxvf  XXXXXX  -C /usr/local/`\n\n配置环境变量`sudo gedit /etc/profile`\n\n将你的解解压好的目录添加进去\n\n`export PATH=\"$PATH:/usr/local/arm-2009q3/bin\"`\n\n![img](https://s2.ax1x.com/2019/07/11/Z2kZO1.md.png)\n\n 测试一下看成不成，或者直接使用env命令 查看环境变量有没有配好\n\n`env |grep PATH`\n\n如果没有的话，使用source让它立刻生效\n\n`source /etc/profile`\n\n现在应该就可以\n\n![img](https://s2.ax1x.com/2019/07/11/ZRJEHf.md.png)\n\n在用户目录下创建一个.c 文件，可以先用gcc 编译一哈。比如 `gcc hello.c -o hello`\n\n现在使用arm 编译一哈，就成了\n\n`arm-none-linux-gnueabi-gcc hello.c -o arm_hello`\n\n![img](https://s2.ax1x.com/2019/07/11/Z2kMFO.png)\n\n然后就生成了两个版本的执行程序了。\n\n![img](https://s2.ax1x.com/2019/07/11/Z2knw6.md.png)\n\n![img](https://s2.ax1x.com/2019/07/11/Z2kuTK.md.png)\n\n \n\n","tags":["linux"],"categories":["学习笔记"]},{"title":"Embedded-Hardware","url":"/2019/07/11/2019-07-11-embedded-hardware/","content":"\n### 0x00 前言\n\n终于有时间了，整理一下嵌入式硬件的东西，在过去的一个学期里选修了嵌入式课程，然后相对完整的了解了嵌入式开发过程，咱物联网专业比较好的一点就是可以结合软硬件，都可以了解，上学期还做了一些WSN ZigBee，RFID 的实验，当时觉得用不到，没想到，这次实训竟然也做嵌入式开发，也使用了ZigBee模块完成一些功能，感觉所有东西并不是绝对没用，多了解一点总是好的。\n\n### 0x01 嵌入式入门\n\n关于硬件的东西，之前几乎是从来没有接触，完全不懂什么SOC，也不知道什么MCU，更别说是做开发了，之前唯一对硬件感兴趣的就是树莓派，听说是一块很不错的板子，但由于各种情况，也没有入坑。知道这个学期选了嵌入式，然后因为要完成实验所以入坑了一块EK-TM4C123GXL 开发板，麻雀虽小五脏俱全，这块板子基本能够满足所有嵌入式的基本开发，用来学习还是很不错的。\n\n关于硬件的学习，其实最主要还是要了解硬件资源，熟悉硬件提供的功能，包括GPIO，时钟，中断等，这些都是最基本的，另外就是一些ADC，DAC，时钟频率，高低电平，这些也是要十分熟悉才行。硬件开发有很多东西是记不住的，所以学会查文档很重要的，学习路线可以大致为：看文档了解硬件资源--找案例照葫芦画瓢--网上查阅资料--查开发文档；有些东西不用刻意去记，用的时候去查就行。但构建思路，开发步骤是需要明确的，比如说要使用GPIO时要初始化寄存器，使用模块功能时要考虑时钟的影响，使用中断时要了解如何调用中断处理函数，如果有要连接传感器的话，还要参考传感器的资料，了解其电气特性等。总之，查资料，阅读资料，理解资料在硬件开发中尤为重要。\n\n### 0x02 实训硬件开发\n\n实训时使用的是CC2530，搭载了ZigBee模块，在开发中都是使用IAR软件，刚好和我们wsn实验ZigBee联系上了，不过我们在wsn实验中我只使用了ZigBee协议栈组网通信，而这次我是利用ZigBee通信来控制硬件功能，而硬件功能实现就是需要嵌入式开发的知识了，刚好把所学内容进行了结合，在嵌入式开发中，不同的硬件资源可能开发就有所不同，但大多数底层逻辑是相同的，所以重点是理解思路。但嵌入式开发仍然有很多烦人的问题，这些Bug出现的原因各种各样，有的是硬件本身故障，有的程序错误，甚至可能的电路连接错误，所以在开发中遇到Bug，排查问题方式方法很关键，我个人认为先从硬件开始检查，最后再检查软件程序，逐层排查是一个相对较好的思路。\n\n当将嵌入式硬件和网络连接起来后，功能开始就更强大了，当然问题出现几率也开始变大了，在物联网传感器硬件开发中，一般使用ZigBee进行硬件组网，网络协议是单独的且复杂的，很多时候我们在开发过程中是不允许修改协议栈的，都已经封装好的，我们需要的是理解代码，了解功能实现思路，然后再做简单的自定义开发，所以读代码也物联网硬件开发需要的能力。\n\n在硬件开发中调试是一个不得不进行的过程，而硬件开发的调试不像软件那么方便，它需要在开发板或是硬件资源中运行，这是一个比较繁琐的过程，构建，编译，烧录，运行，测试输出这是一个最基本的流程，也是一个相对花费时间的过程，所以想要提升开发效率，最好的办法是理解问题本质并细心的修改问题，而不是盲目的测试，企图用巧合来达到成功。\n\n### 0x03 总结\n\n本来是准备写一篇详细嵌入式硬件开发的文章，把自己使用的TM4C123GXL 开发和CC2530开发时使用的核心技术，关键代码总结一下，后面发现硬件开发这玩意儿，只要理解了解很简单，实现起来也是多变的，没有一个很固定的标准，所以也不太好总结，也没太必要，下一次遇到是查资料就行。这次在完成项目时参考了很多网上的资料，学到很多东西，比如博客园的小蜜蜂老师和csdn的Bruceoxl老师，他们的博文很全面也很详细，给了我很大的帮助，同时也挺佩服他们能够输出那么多优质内容，应该向他们学习。\n\n写到这也要告一段落了，关于硬件嵌入式ZigBee开发，我究竟理解多少，掌握了多少，过段时间后我是否还能记起，这些都是无法量化和衡量的，只希望自己总结的方法能够适用于以后的问题。\n\n","tags":["嵌入式"],"categories":["学习笔记"]},{"title":"记录零碎技术栈","url":"/2019/06/29/2019-06-29-tech-stack/","content":"\n\n\n### 0x00 前言\n\n好久没有写东西做总结了，应该时时更新，日日总结，保持对新事物的好奇心，回顾所学旧的知识，融汇贯通。因为实训接触了一些新的玩意儿，如: Vuejs，Flutter, Kotlin 等，也刚好有时间，就干脆多了解一些，顺便做了一点笔记，丰富一下自己的认知。没有实际干货，也不算是技术栈，不管以后会不会深入学习，先记录一下吧。\n\n\n\n### 0x01 Vue.js\n\nVue.js 是以数据驱动和组件化思想构建的一个JavaScript MVVM库，提供了简洁和易于理解的的API，能够快速上手。\n\n什么是MVVM（Model-View-ViewModel），简单来说就是一种设计模式，借鉴了MVC的思想，在前端页面中，将Model用纯JavaScript对象表示，View负责显示，两者做到了最大限度的分离，对于现在多功能的前端和复杂业务逻辑的后端，以及技术分工的划分，这其实是技术发展的一个必然趋势。把Model和View关联起来的就是ViewModel。ViewModel负责把Model的数据同步到View显示出来，还负责把View的修改同步回Model。对于MVVM，我们并不用关注DOM，而是直接操作JavaScript对象，去除操作DOM的繁琐步骤。\n\n使用Vue其实就是一个定义MVVM各个组成部分的过程，可以归结为：定义View，定义Model，创建Vue实例（连接View 和Model）。目前只是做一个简单了解，要是想要更深入的了解或是使用，还得好好学习一番。下面是一个简单例子：\n\n```html\n!DOCTYPE html>\n<html>\n    <head>\n        <meta charset=\"UTF-8\">\n        <title></title>\n    </head>\n\n    <body>\n        <!--这是View-->\n        <div id=\"app\">\n            {{ message }}\n        </div>\n    </body>\n    \n    <script src=\"js/vue.js\"></script>\n    <script>\n        // 这是Model\n        var exampleData = {\n            message: 'Hello World!'\n        }\n\n        // 创建一个 Vue 实例或 \"ViewModel\"\n        // 它连接 View 与 Model\n        new Vue({\n            el: '#app',\n            data: exampleData\n        })\n    </script>\n    \n</html>\n```\n\n\n\n### 0x01 Flutter框架\n\nFlutter 是 Google推出并开源的移动应用开发框架，开发者可以通过 Dart语言开发 App，一套代码同时运行在 iOS 和 Android平台。\n\n之前一直没有了解和关注移动开发这一块，最近也是因为实训内容涉及到Android开发，所以特意去了解了一下。对于移动开发需要区分原生开发和跨平台技术，原生应用程序是指某一移动平台（比如iOS 和安卓）所特有的应用，使用相应平台支持的开发工具和语音，并直接调用系统提供的SDK API。比如Android原生应用就是指使用Java或Kotlin语言直接调用Android SDK开发的应用程序；而iOS原生应用就是指通过Objective-C或Swift语言直接调用iOS SDK开发的应用程序。\n\n原生开发的优势在于速度快、性能高、可以实现复杂动画及绘制，整体用户体验好，但存在动态化和开发成本较大的问题，因此诞生了一些跨平台的动态化框架，而Flutter就是其中之一，可以看一下官网给的框架图：\n\n![flutter](https://s2.ax1x.com/2019/06/29/ZlJWbn.md.png)\n\n属于一种自绘UI+原生的技术模式，性能比较好，开发效率也比较高，而且也是一种很新的框架，由Google在2017年的 I/O 大会上首次推出，至今短短两年的时间，其生态系统快速增长，相信未来发展也很值得期待。\n\n由于目前Flutter仍处于快速发展的阶段，其应用场景的资讯和参考资料并不是很多，想要深入了解可以通过官网和源码等渠道进行学习，包括Dart 语言，这些对于我个人来说都是很陌生的东西，现在发现可以学习的东西太多了，需要学习的东西也很多，保持一颗好奇心，不断去尝试，技术人就是要不断学习的。\n\n\n\n### 0x02 Kotlin 语言\n\n是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为 Android 世界的Swift，由 JetBrains 设计开发并开源。Kotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。\n\n在Google I/O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言，主要原因可能还是因为Google 和 Oracle 的官司纠纷，导致Google不得不推出Kotlin，当然作为Android开发的核心语言Java，在未来的发展中依然具有巨大影响力。\n\n另外值得一提的是Oracle公司，近些年对于开源界并不友好，收购了Sun公司（Java，MySQL），开源社区因为担心MySQL被闭源，另外维护了MariaDB作为其分支，之前在数据库课程实验时使用的就是MariaDB，因此顺便了解了Sun公司及其整个发展历程，从兴起到巅峰再到衰亡，也是十分感叹，信息技术行业真的是一个不断更新变换的行业，无论是技术还是产业，整个生态都是快节奏的，真的需要把握时机，顺应变换，更新迭代，否则将会被淘汰。\n\n对于开源，在计算机行业也只有在计算机行业才能实现和发展的，这是一种行业特性，对于传统行业是无法做到的，开源是一种精神，开源不等于免费，知识产权也是需要保护，在现实利益的趋势下，到底该如何定义开源，真的不是一两句能够说清楚的，对于开发者来讲当然应高喊开源万岁。\n\n\n\n### 0x03 Gradle 工具\n\nGradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建开源工具。面向Java应用为主。当前其支持的语言限于Java、Groovy、Kotlin和Scala，计划未来将支持更多的语言。\n\n这个东西主要是在使用Android Studio开发应用时，发现在使用Gradle构建项目，不太清楚到底是个啥就查了一下，简单来说gradle就是一个基于JVM的构建工具，支持局部构建，支持多方式依赖管理，与ant、maven、ivy有良好的相容相关性，gradle适用于任何结构的工程。\n\n\n\n### 0x04 小结一下\n\n唉~搞计算机的要学的东西还真多啊，关于硬件嵌入式Linux的学习还没有总结呢，那个好像也很多，等下一篇更新吧。\n\n"},{"title":"初识Docker与简单使用","url":"/2019/06/17/2019-06-17-docker-study/","content":"\n### 0x00 容器与虚拟机\n\n我们用的传统虚拟机如 `VMware` ， `VisualBox` 之类的需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。\n\n而容器技术是和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。容器技术是实现操作系统虚拟化的一种途径，可以让您在资源受到隔离的进程中运行应用程序及其依赖关系。\n\n![img](https://s2.ax1x.com/2019/07/13/Z4tsgS.md.png)\n\n`Docker` 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 `Docker` ，就不用担心环境问题。\n\n\n\n### 0x01 Docker的优势\n\n**Docker相比于传统虚拟化方式具有更多的优势：**\n\n- `docker` 启动快速属于秒级别。虚拟机通常需要几分钟去启动。`docker` 需要的资源更少， `docker` 在操作系统级别进行虚拟化， `docker` 容器和内核交互，几乎没有性能损耗，性能优于通过 `Hypervisor` 层与内核层的虚拟化。\n\n  ![img](https://s2.ax1x.com/2019/07/13/Z4twNt.md.png)\n\n- `docker` 更轻量， `docker` 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境， `Docker` 运行的镜像数远多于虚拟机数量，对系统的利用率非常高。\n\n- 高可用和可恢复性： `docker` 对业务的高可用支持是通过快速重新部署实现的。虚拟化具备负载均衡，高可用，容错，迁移和数据保护等经过生产实践检验的成熟保障机制， `VMware` 可承诺虚拟机 `99.999%` 高可用，保证业务连续性。\n\n- 快速创建、删除：虚拟化创建是分钟级别的， `Docker` 容器创建是秒级别的， `Docker` 的快速迭代性，决定了无论是开发、测试、部署都可以节约大量时间。\n\n- 交付、部署：虚拟机可以通过镜像实现环境交付的一致性，但镜像分发无法体系化。 `Docker` 在 `Dockerfile` 中记录了容器构建过程，可在集群中实现快速分发和快速部署。\n\n\n\n### 0x02 Docker基础架构\n\nDocker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。Docker 包括是三个最基本的概念：Image(镜像)，Container(容器)，Repository(仓库)。\n\n| Docker 镜像(Images)    | Docker 镜像是用于创建 Docker 容器的模板。     |\n| ---------------------- | --------------------------------------------- |\n| Docker 容器(Container) | 容器是独立运行的一个或一组应用。              |\n| Docker 仓库(Registry)  | Docker 仓库用来保存镜像，可以理解为代码仓库。 |\n\n![img](https://s2.ax1x.com/2019/07/13/Z4tr38.png)\n\nDocker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。镜像实际是由多层文件系统联合组成。镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。\n\n镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等，容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。\n\n镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其他服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。一个 Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。\n\n在上面分别介绍了docker的三个基本概念：Image(镜像)，Container(容器)，Repository(仓库)和C/S的架构。现在在详细记录一下这些组件协作运行容器的过程：\n\n1. `Docker` 客户端执行 `docker run` 命令\n2. `Dockerdaemon` 发现本地没有我们需要的镜像\n3. `daemon` 从 `DockerHub` 下载镜像\n4. 下载完成后，镜像被保存到本地\n5. `Dockerdaemon` 启动容器\n\n`Dockerdaemon` 是服务器组件，以 `Linux` 后台服务的方式运行，是 `Docker` 最核心的后台进程，我们也把它称为守护进程。它负责响应来自 `Docker Client` 的请求，然后将这些请求翻译成系统调用完成容器管理操作。\n\n\n\n\n### 0x03 Docker 安装与使用\n\nLXC （Linux Container）内核虚拟化技术，可以提供轻量级虚拟化，以便隔离进程和资源。\n\nUbuntu12.04 安装Docker需要升级内核（Docker 在3.8内核下运行最佳，Ubuntu1204内核版本为3.2）\n\n```shell\n# install the backported kernel\nsudo apt-get update\nsudo apt-get install linux-image-generic-lts-raring linux-headers-generic-lts-raring\n# reboot\nsudo reboot\n```\n\n安装Docker\n\n```bsh\n# 添加Docker库的密钥\nsudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9\n\n# 把Docker的库添加到apt的源列表中，更新并安装lxc-docker包。\nsudo sh -c \"echo deb http://get.docker.io/ubuntu docker main\\\n> /etc/apt/sources.list.d/docker.list\"\nsudo apt-get update\nsudo apt-get install lxc-docker\n```\n\n按照这个步骤安装后，发现报了很多错误，调试了半天也没能解决，后来发现自己的Ubuntu12.04 是32位的，Docker需要运行在64位的机子上，所以失败了。后面查了一下说docker也可以安装在32位的系统，不过pull下来的镜像也必须是32位的，这个有点麻烦，所以放弃了。\n\n在安装docker或者其他软件时记得要使用命令`uname -a` 、`uname -r` 、`lsb_release -a` 查看系统相关信息，来避免一些不必要的麻烦。另外注意通过`uname -a`命令查看内核和版本显示系统版本为i386和i686的为 32位系统；显示为X86_64的，才是64位系统。\n\n后面选择了我的**阿里云CentOS 安装Docker**，一路pass，没有遇到任何bug，大致步骤如下：\n\n1、清理原有的docker目录和文件，确保安装环境的干净：\n\n```\nsudo yum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-selinux \\\n                  docker-engine-selinux \\\n                  docker-engine\n```\n\n2、使用yum安装docker\n\n安装一些必要的工具，设备映射器存储驱动程序需要设备映射器-持久数据和lvm2。\n\n```\nsudo yum install -y yum-utils \\\ndevice-mapper-persistent-data \\\nlvm2\n```\n\n设定软件源地址，国外慢的可怜，我这里使用国内源：\n\n```\nsudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n```\n\n更新源信息\n\n```\nsudo yum makecache fast\n```\n\n下载docker，直接下载最新版：\n\n```\nsudo yum install docker-ce\n```\n\n也可以选择下载指定版本：\n\n```\nyum list docker-ce --showduplicates | sort -r\nsudo yum install docker-ce-<VERSION STRING>\n```\n\n至此docker就下载安装成功了，可以直接使用命令docker -v 查看docker版本。\n\n通过网上查资料说还有更简单的安装方法，直接使用脚本安装，只需要简单的两条命令就可以，我没有测试，应该是可以的。\n\n```\ncurl -fsSL get.docker.com -o get-docker.sh\n\nsudo sh get-docker.sh --mirror Aliyun\n```\n\n3、安装成功后可以进行一些配置和测试。可以设置系统启动时同时启动docker\n\n```\nsudo systemctl enable docker\n```\n\n启动docker并测试\n\n```\nsudo systemctl start docker\nsudo docker run hello-world\n```\n\n![img](https://s2.ax1x.com/2019/07/13/Z4tD9f.md.png)\n\n\n\n### 0x04 Docker 常用命令\n\n```powershell\n1.docker images ls                             # 列出本地docker镜像\n2.docker rmi -f {image id}                     # 删除docker镜像\n\n3.docker stop [docker_names]|[docker_id]       # 停止容器运行\n4.docker rename [docker_names] [newname]       # 重命名容器\n5.docker rm [docker_names]                     # 删除容器\n6.docker ps -a                                 # 已创建docker image列表\n```\n\n**以创建Nginx容器为例**\n\n```\n# 查找 Docker Hub 上的 nginx 镜像\ndocker search nginx\n\n# 拉取镜像\ndocker pull nginx\n\n# 查看本地镜像\ndocker images nginx\n\n# 启动一个Nginx容器实例\n# --name(容器名)、-p(端口映射)、-d(后台执行)\ndocker run --name nginx-test -p 8080:80 -d nginx\n\n# 查看容器是否有在运行\ndocker ps \n```\n\n![img](https://s2.ax1x.com/2019/07/13/Z4DLhd.md.png)\n\n创建Nginx容器成功后，可以使用 ip + 端口号进行访问，Ubuntu系统可以直接使用127.0.0.1:端口号，如果是云服务器的话就是 ip+端口号，注意端口号要进行防火墙设置以保证可用。\n\n### 0x05 Dockerfile\n\n除了上述的拉取镜像生成容器实例的基本方法，还可以使用`Dockerfile`来定义镜像创建容器，这里的`Dockerfile`非常类似Makefile 和 Linux下shell。`Dockerfile` 是由一行行命令语句组成，并且支持已 `#` 开头的注释行。一般来说，可以将 `Dockerfile` 分为四个部分：\n\n1. 基础镜像(父镜像)信息指令 FROM\n\n2. 维护者信息指令 MAINTAINER\n\n3. 镜像操作指令 RUN 、 EVN 、 ADD 和 WORKDIR 等\n\n4. 容器启动指令 CMD 、 ENTRYPOINT 和 USER 等\n\n\n\n**通过Dockerfile 构建Tomcat 镜像**\n\n创建目录tomcat,用于存放后面的相关东西\n\n```\n# webapps目录将映射为tomcat容器配置的应用程序目录、logs目录将映射为tomcat容器的日# 志目录、conf目录里的配置文件将映射为tomcat容器的配置文件\n\nmkdir -p ~/tomcat/webapps ~/tomcat/logs ~/tomcat/conf\n```\n\n进入创建的tomcat目录，创建Dockerfile\n\n```docker\nFROM openjdk:8-jre\n\nENV CATALINA_HOME /usr/local/tomcat\nENV PATH $CATALINA_HOME/bin:$PATH\nRUN mkdir -p \"$CATALINA_HOME\"\nWORKDIR $CATALINA_HOME\n\n# 可以直接访问 https://hub.docker.com/_/tomcat/\n# 选择代码仓库，里面就有Dockerfile，\n# 自己复制下来然后自定义修改就行\n\nEXPOSE 8080\nCMD [\"catalina.sh\", \"run\"]\n```\n\n通过Dockerfile创建一个镜像，并命名。\n\n```\n docker build -t tomcat2.\n```\n\n创建完成后，我们可以在本地的镜像列表里查找到刚刚创建的镜像\n\n```\ndocker images|grep tomcat2\n```\n\n```\n# 运行容器\n# 将主机中当前目录下的test挂载到容器的/test\ndocker run --name tomcat -p 8080:8080 -v $PWD/test:/usr/local/tomcat/webapps/test -d tomcat  \n```\n\n### 0x06 总结\n\n至此就把Docker的一些基本的概念和使用进行了简单总结，看了一些资料，自己对Docker也有了一些了解和认识，特别是它设计一个理念和架构，对于复杂的应用开发部署真的做到了简单高效，上面总结了Docker应用的优势和基础的架构，自己也亲自装了Docker并创建了一些容器实例，熟悉了Docker的一些常用指令和使用Dockerfile创建Image，也算是一个简单的入门吧。因为接触并不是很多，至于它的具体应用场景个人还是不太清楚，但个人认为应该是很有应用前景的。","tags":["Docker"],"categories":["学习笔记"]},{"title":"regular-expression","url":"/2019/06/17/2019-06-17-regular-expression/","content":"\n### 0x00 概念\n\n正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。\n\n### 0x01 匹配单个字符\n\n**.** 可以用来匹配任何的单个字符，但是在绝大多数实现里面，不能匹配换行符；\n\n**.** 是元字符，表示它有特殊的含义，而不是字符本身的含义。如果需要匹配 . ，那么要用 \\ 进行转义，即在 . 前面加上 \\ 。\n\n**正则表达式**\n\n```\nnam. //匹配一个 nam 加任意字符的字符串，例如name\n```\n\n### 0x02 匹配一组字符\n\n**[ ]** 定义一个字符集合；\n\n0-9、a-z 定义了一个字符区间，区间使用 ASCII 码来确定，字符区间在 [ ] 中使用。\n\n**-** 只有在 [ ] 之间才是元字符，在 [ ] 之外就是一个普通字符；\n\n**^** 在 [ ] 中是取非操作。\n\n**正则表达式**\n\n```\nabc[^0-9] //匹配以 abc 为开头，并且最后一个字母不为数字的字符串\n```\n\n### 0x03 使用元字符\n\n#### 匹配空白字符\n\n| 元字符 | 说明                 |\n| ------ | -------------------- |\n| [\\b]   | 回退（删除）一个字符 |\n| \\f     | 换页符               |\n| \\n     | 换行符               |\n| \\r     | 回车符               |\n| \\t     | 制表符               |\n| \\v     | 垂直制表符           |\n\n\\r\\n 是 Windows 中的文本行结束标签，在 Unix/Linux 则是 \\n。\n\n\\r\\n\\r\\n 可以匹配 Windows 下的空白行，因为它匹配两个连续的行尾标签，而这正是两条记录之间的空白行；\n\n#### 匹配特定的字符类别\n\n**1. 数字元字符**\n\n| 元字符 | 说明                      |\n| ------ | ------------------------- |\n| \\d     | 数字字符，等价于 [0-9]    |\n| \\D     | 非数字字符，等价于 [^0-9] |\n\n**2. 字母数字元字符**\n\n| 元字符 | 说明                                          |\n| ------ | --------------------------------------------- |\n| \\w     | 大小写字母，下划线和数字，等价于 [a-zA-Z0-9_] |\n| \\W     | 对 \\w 取非                                    |\n\n**3. 空白字符元字符**\n\n| 元字符 | 说明                                  |\n| ------ | ------------------------------------- |\n| \\s     | 任何一个空白字符，等价于 [\\f\\n\\r\\t\\v] |\n| \\S     | 对 \\s 取非                            |\n\n\\x 匹配十六进制字符，\\0 匹配八进制，例如 \\x0A 对应 ASCII 字符 10，等价于 \\n。\n\n### 0x04 重复匹配\n\n- **+** 匹配 1 个或者多个字符\n- *** 匹配 0 个或者多个\n- **?** 匹配 0 个或者 1 个\n\n**正则表达式**\n\n```\n[\\w.]+@\\w+\\.\\w+ //匹配邮箱地址\n```\n\n[\\w.] 匹配的是字母数字或者 . ，在其后面加上 + ，表示匹配多次。在字符集合 [ ] 里，. 不是元字符；\n\n- **{n}** 匹配 n 个字符\n- **{m, n}** 匹配 m~n 个字符\n- **{m,}** 至少匹配 m 个字符\n\n\\* 和 + 都是贪婪型元字符，会匹配尽可能多的内容。在后面加 ? 可以转换为懒惰型元字符，例如 *?、+? 和 {m, n}? 。\n\n### 0x05 位置匹配\n\n**单词边界**\n\n**\\b** 可以匹配一个单词的边界，边界是指位于 \\w 和 \\W 之间的位置；**\\B** 匹配一个不是单词边界的位置。\n\n\\b 只匹配位置，不匹配字符，因此 \\babc\\b 匹配出来的结果为 3 个字符。\n\n**字符串边界**\n\n**^** 匹配整个字符串的开头，**$** 匹配结尾。\n\n^ 元字符在字符集合中用作求非，在字符集合外用作匹配字符串的开头。\n\n分行匹配模式（multiline）下，换行被当做字符串的边界。\n\n**正则表达式**\n\n```\n^\\s*\\/\\/.*$       //匹配代码中以 //开始的注释行\n```\n\n### 0x06 使用子表达式\n\n使用 **( )** 定义一个子表达式。子表达式的内容可以当成一个独立元素，即可以将它看成一个字符，并且使用 * 等元字符。\n\n子表达式可以嵌套，但是嵌套层次过深会变得很难理解。\n\n**正则表达式**\n\n```\n(ab){2,}   //匹配结果为ababab\n```\n\n**|** 是或元字符，它把左边和右边所有的部分都看成单独的两个部分，两个部分只要有一个匹配就行。\n\n**正则表达式**\n\n```\n(19|20)\\d{2}    //匹配结果1900 2010\n```\n\n### 0x07 回溯引用\n\n回溯引用使用 **\\n** 来引用某个子表达式，其中 n 代表的是子表达式的序号，从 1 开始。它和子表达式匹配的内容一致，比如子表达式匹配到 abc，那么回溯引用部分也需要匹配 abc 。\n\n**正则表达式**\n\n\\1 将回溯引用子表达式 (h[1-6]) 匹配的内容，也就是说必须和子表达式匹配的内容一致。\n\n```\n<(h[1-6])>\\w*?<\\/\\1>  //匹配 HTML 中合法的标题元素。如<h1>x</h1>\n```\n\n### 0x08 大小写转换\n\n| 元字符 | 说明                               |\n| ------ | ---------------------------------- |\n| \\l     | 把下个字符转换为小写               |\n| \\u     | 把下个字符转换为大写               |\n| \\L     | 把\\L 和\\E 之间的字符全部转换为小写 |\n| \\U     | 把\\U 和\\E 之间的字符全部转换为大写 |\n| \\E     | 结束\\L 或者\\U                      |\n\n**正则表达式**\n\n把文本 **abcd** 的第二个和第三个字符转换为大写。\n\n```\n(\\w)(\\w{2})(\\w)  //查找\n$1\\U$2\\E$3 //替换\naBCd //结果\n```\n","categories":["小把戏录"]},{"title":"软件工程：设计难于实现","url":"/2019/06/11/2019-06-11-software/","content":"\n### 0x00 前言\n\n记录一下我对软件工程的理解，说实话在校学习期间很难接触到真正意义上的软件开发，更别提会参考或采用软件工程的解决办法。更多的是编写一些很小很小而且漏洞百出的小程序，锻炼的只不过是对编程语言的熟悉和对一些算法的理解和掌握。而真正的软件开发应该不是这样的，虽然我目前还没接触到，但我知道肯定不是简单的编码，而是有一整套设计思路和开发流程的，因为这是质量和效率的保证。\n\n### 0x01 设计与实现\n\n对于软件的开发，我认为设计远比实现复杂，首先我们先忽略对需求的分析，就单纯从一个简单功能来看，设计对于整个开发都是十分重要的，设计不仅要考虑程序的整个流程和部署，还要考虑到最终结果是否是有意义的。就我个人而言，常常会因为设计而苦恼，首先是没有一个很好解决办法的思路，其次是设计不合理导致后续的实现异常复杂。也常因为自己写了一手好bug而感到奔溃，这些都不是实现的问题，更多的是设计不合理或者对于问题本身理解的偏差造成的。实现对于设计是相对容易的，无非就是编码，这和自己对编程语言掌握的程度有关，还有就是算法与数据结构的熟练程度有关。\n\n### 0x02 理论的意义\n\n理论的最大意义就是起到要个引导和规范作用，通过软件工程可以规范整个软件开发的流程和实施步骤，这也是为什么软件工程可以单独作为一门学科而存在的原因之一。软件工程把软件放在了一个产品的角度，从最开始的分析设计，开发实现，测试运维以及质量管理都提出了较为规范和通用的实施步骤和方法策略，从而使软件的开发难度降低，提高了生产效率。以前一直认为理论是无用的，实践才是硬道理，后来才发现自己对于理论的认知是有偏差的，理论并非夸夸奇谈，它的意义也并非限于其字面含义，而重要的是其提出的方法和理念。理论更像是人们总结出的经验，它并非局限于某个问题本身，而是针对某类问题的一个通用解决方案。理论研究和良好的理论体系对于一个行业的发展是至关重要的，我认为没有理论的支持，所有的设计和实现都是没有太大价值的。\n\n### 0x03 软件开发困境\n\n软件开发其实是一种实施细节，即使有很多理论的支持，还是抵不过多变复杂的技术，现在越来越多的框架，虽然免去了重复造轮子，但对于程序员来讲也并没减少负担，反而程序员需要去学习和了解这些框架和技术，完成开发任务。这些开发任务并非其他行业那样只要掌握了足够理论就可以解决多数问题，相反软件开发更多像是一种技术实施细节，这种实施细节只针对某个特定问题有用，换一个场景就未必有用了，所以在程序员行业，只有不断学习汲取新的东西才不会被淘汰。特别是这种实施细节对于软件开发是一种无法规避的难题，如果不了解是无法完成开发任务的，技术的更新迭代远比我们学习新技术的速度快，这是软件开发无法避免的问题，也是我们程序员不得不面对的难题。\n\n### 0x04 敏捷开发\n\n敏捷开发算是一种很好的开发策略针在目前状况下，我理解的敏捷开发是一种小而快的开发，适用于多变的小项。这种开发策略是一种可以针对具体需求进行随机应变的，可以理解为专注于某个需求进行精准开发。对于当下社会情形，精准显得越来越重要，随着社会分工越来越完善，协同合作也显得越来越重要，只有把工作划分到不同领域，才能提高生产效率，就像流水线一样；然后通过协同合作把各个领域的能力进行汇聚，才能发挥真正的价值，简单来说就是利用分工合作，提高效率汇聚价值。敏捷，我理解的就是高度的分工，互联网企业是分工合作体现的最明显的一类企业，无论从技术还是管理层都涉及到多个部门领域，而针对技术展开的部门和部门内部的工作组，都是分工的体现，在计算机行业想要完成任何一款产品研发都是要分工合作的，因为它涉及到多种各样的技术栈，而科技公司很难找到什么都精通的人才。为了适应市场需求，我们可能也只能进行精准学习，想要成为大牛，可能得不断学习，不断精进了。\n\n### 0x05 总结\n\n以上就是自己对于软件工程，对于软件开发以及将要投身于的IT行业的理解，自己写下这些东西可能毫无价值，但它代表的是当前的一些理解和思考，这可能是学生时期才会有的想法。多年以后，自己对于行业有了更深的接触和了解后，一定会有有一些不一样理解和思考的，那就等以后再说吧。","categories":["学习笔记"]},{"title":"计算机：组成原理和体系结构","url":"/2019/06/09/2019-06-09-computer-summary/","content":"\n### 0x00 前言\n\n大三这一年学习了组成原理和体系结构这两门偏底层的专业课程，虽然学的不怎么样，但还是或多或少有些不一样的感受，下面就梳理一下自己学到的东西，记录一下自己理解一些的东西。\n\n### 0x01 抽象\n\n对于计算机科班生来说计算机不再只是一台用于办公或计算的机器，而更多的是一种抽象的概念。计算机最核心的能力就是计算，而处理计算需要的是对数据的理解能力，在计算机的世界只有0和1，更准确的说是只有高低电平，这种脉冲信号才是真实存在的，这就是一种抽象。使用0和1来代表脉冲信号的高低电平，当然这种对应关系也只是相对的，这涉及的正是之前模电和数字逻辑课程所学的东西。有了数模电，其中的二极管，三极管，门电路才是构成计算机最基础最底层的东西。而计算机也正是通过这些器件一层一层的抽象，形成多种复杂的数据处理单元和数据通路，最终封装成为一个我们容易理解和使用的机器。\n\n### 0x02 集成电路\n\n计算机可以处理信息的方式就是将信息转化为0和1，在逻辑上表现为True 和 False，而在硬件上则是高低电平，在最开始的计算机计算就是通过这种高低电平的打孔计算，这处理起来是非常麻烦的，而且能够处理的数据量非常有限，甚至还没普通算术来的快。但随着硬件和集成电路的发展，计算机底层电路经过几代的更换后，计算机性能得到了飞速的发展，对于硬件的优化是对计算机至关重要的，集成电路的发展对计算各个硬件设计至关重要，从第一台计算诞生到至今，集成电路设计几乎一直是计算发展的核心，而这种最底层的设计需要多个领域技术的结合，包括电子，材料，物理等，所以技术难度很大，需要投入的成本也是巨大的，如果没有原始的技术积累是很难做到的。\n\n### 0x03 编码\n\n编码是计算机最有意思的地方，如何让程序成为计算机可以执行的指令，而指令又是如何装换为机器码的，这种机器码是怎么控制计算机电路的呢，这都是一些有趣的问题。对于计算机程序指令，最开始的认识是高级语言转换为汇编语言，而汇编由转换为可执行的机器码。那为何需要将高级语言转为汇编再转为机器码，而不是高级语言直接转为机器码呢？其实这个设计是为方便程序的优化和调试，高级语言转为汇编是需要编译器的，编译器可以处理好高级语言到汇编这一过程，而真正复杂的是汇编程序转换为机器码，这是需要物理电路实现的，通过机器码01序列来控制对应的寄存器和电路，来进行相应状态的切换，这就是计算机最基础的实现，但这种实现到底怎么实现的呢，我现在还是不太清楚，这可能涉及到EE的内容，但作为CS方向应该有一定的了解，之前也找了《编码:隐匿在计算机软硬件背后的语言》书来看，但只看了部分，等有时间在看一看深入了解一下。\n\n### 0x04 指令和程序\n\n指令简单理解就是控制计算机执行的命令，指令说到还是一串01的序列，只是将这串指令意义化了，就像给寄存器命名，而实际上指向的还是一个地址而已，这是我个人理解的，指令本身含义不大，关键的是它对电路的控制和状态转移的操作，这才是指令真正的意义，除了指令外，还有程序，命令，操作等概念，记得当时计组课上讲过，微程序是一组微指令的集合，微指令是一个单位时间内出现的一组微操作的描述语句，在微指令的控制字段中，每一位代表一个微命令。这些大概就是它们的具体区别吧。\n\n### 0x05 数据通路\n\n这是我们实验实现过的东西，当时使用Verilog编程实现简单MIPS数据通路，如果将实验拆分为各个模块那到并不是很难，分别实现存储器，运算器，控制单元，然后将这些模块组合，在加上程序计算器，IO模块，基本上就可以实现简单的数据通路，而且是单周期的所以理解起来相对比较容易。数据通路是CPU的核心框架，基本上就是实现了一个简单的CPU，比较复杂的是PC的寻址，指令的译码，以及IO操作，这种对于硬件的操作虽然实现是有一定难度的，但也是能一种更好理解计算机的方式。\n\n### 0x06 体系结构\n\n说到体系结构自然想到的就是冯诺依曼体系结构，现代计算机，大部分是基于冯诺依曼体系结构的，其核心就是存储程序和顺序执行，它定义了整个计算的基础框架，无论计算机怎么发展其基本原理都基本相同。体系结构特点包括了计算机处理的数据和指令用二进制表示，指令和数据都存储在同一个存储器中，顺序执行程序的每一条指令，硬件组成包括运算器，控制器，存储器，输入设备和输出设备。我们平时所接触的和学习都是围绕着这个体系所展开的，而其中的每一个部分想要将它理解透都是要花费很多精力的，后面计算机设计都是在这个基础上改进优化，对于后学者而言，能改进的东西越来越少，需要学习的是越来越多，就当下计算机的能力而言，硬件和体系结构的性能几乎已经达到了一个比较高的水平，如果想突破这种极限，可能需要一种新的体系结构来定义计算机了。\n\n### 0x07 处理器\n\n广义上处理器就是指平时所说的CPU，简单理解CPU就是控制程序执行，处理数据的一个单元，也可以理解为个集成电路，和上面提到的集成电路和数据通路类似，CPU是计算机的核心是必不可少的组成部分。微处理器的发展几乎代表了计算机的发展，而这里不得不提就是Intel(英特尔)，这个公司的发展史可以说是代表了这个微处理器的发展历程，包括8x86，奔腾等都是处理器发展的代表，包括后面发展起来的AMD, 高通等公司都是目前芯片领域的巨头，当然芯片不仅包括了处理器芯片，还包括了其他的功能芯片。说到这些，自己其实了解的真的太少了，关于芯片这部分其实我自己还是挺感兴趣的，对于这个设计流程包括功能特性以及工作原理其实还都想去了解一下的，有机会还得多看看书和找找资料。\n\n### 0x08 ISA\n\n指令集架构，说到这里又得感叹自己了解的太少了，对于指令集架构最主要分为CISC和RISC，当时老师讲课一直提到了，因为书上也没提到，所以感觉很懵，都不知道在讲什么，好多课都荒废了，后面还是查了资料才知道的。对于指令集架构无非就是涉及到指令寻址方式，操作数类型和表示方法，以及指令的编码等，还提到一个编译优化等，对于这些东西真的只是学个概念，想要真的弄明白还是要花费一些时间和精力的，况且就单纯老师上课讲的东西，也只是让我们了解一个大概。还有就是MIPS指令结构，这稍微了解的多一些，包括一些指令类型，寻址等，但平时用的太少所以也不熟。\n\n### 0x09 流水线\n\n流水线几乎是体系结构整本书的重点，其实就是讲的是调高程序并行度的一种方法，流水线主要是体现的是指令级的并行，通过流水线来提高程序效率，流水线虽然可以提高效率，但还是存在一些问题，比如一些数据冒险，控制冒险，结构冒险等，这些都是可以进行优化的，所以提出了一系列改进措施和调度策略，包括了scoreboard，tomasulo，分支预测等。其实只要理解了，其实并不复杂，我们也都是以传统5级流水线作为例子，几乎又把之前提到的东西重复了一遍，包括取指，译码，执行，访存和回写。当然比较难的还是对于汇编指令的不太熟悉，因为完全没有好好的去学习汇编，都是在例子上接触的一些，所以，有些时候弄起来很难得心应手。\n\n### 0x0A Cache\n\ncache是一个很重要的结构对于计算机来说，它位于是连接CPU和主存的一种高速缓存，由于空间局部性和时间局部性原理，所以可以通过cache缓存来提高CPU对于数据的访问效率，从而提高计算机性能，主存和cache的映射方式包括全相关，直接映射和组相连，连接方式不同效率和复杂度也不同。cache也是可以进行优化的包括多级cache，还有TLB，以及相关的替换策略都是为了提高计算机的性能。\n\n### 0x0B 线程级并行\n\n包括SISD，SIMD，MISD、MIMD，还包括向量机，GPU等，这部分了解的并不是太多。\n\n### 0x0C 量化方法\n\n量化方法就比较好理解了，主要就是对性能进行评估，使用一些指标比如说CPU时间，CPI，加速比，平均访存时间，还有功耗能耗等，其目的就还是可以量化计算机CPU的执行效率，以及性能提升，是衡量性能优化的指标。\n\n### 0x0D 总结\n\n大体上把计组和体系结构的学到东西梳理了一遍，才发现自己学到的东西几乎是碎片化的，自己的知识体系结构根本没有很清楚的逻辑，如果不去记录或者输出，真的不知道自己理解那些东西，其实大学学习更多的是了解一个概念，形成一个大体的知识架构，架构内部的东西是要靠我们自己填补的。\n\n想要去深入了解一个领域的知识是需要花费很多时间的，获取到的信息如果不进行加工处理内化到自己的知识体系里是无用的。这也是我在进行梳理时真正体会到的。很多东西很难通过三言两语叙述清楚，首先是自己对内容的不太熟悉，其次是没有一个清楚的表达目的。关于计组和体系结构，本身内容就比较抽象，其次就是练习的时间太少，还有就是学这些东西可能对自己意义不大，但学习这个事还是不能太功利，也不能太心急，对于我来说这两门课还算有些兴趣的，或多或少也算是了解了一些东西，至于考试成绩什么的那又是后话了。\n\n\n\n\n\n","tags":["计算机"],"categories":["学习笔记"]},{"title":"Blog Plans","url":"/2019/06/07/2019-06-07-blog-planning/","content":"\n自己搭建博客也好久了，一直都在倒腾，也花费了一些时间精力，当然也有很多收获。因为各种原因更新的频率很低，内容输出很少，主要不太清楚要输出那些方面的内容会比较好，所以结合自己的实际情况，给自己博客做一个规划吧。\n\n**为什么要写博客？**\n\n其实就是给自己找一块写字的地方，以前有做笔记的习惯，虽然记了但很少会拿来看，但仍然有一种充实感。现在很少手写笔记，所以有很多想法，或者值得纪念的东西，如果不进行记录很可能就会忘了，所以做成博客是一个不错方法，偶尔也可以感动一下自己，不是吗。\n\n其次是针对技术难题的记录，把一些技术难题记录下来，如果下次遇到也方便查找，减少重复踩坑的可能。当然，如果自己的文章能够帮助到其他人，那不是更好吗。只可惜目前技术水平太低，没有遇到啥技术难题，大多是一些学习笔记，之后尽量写一些技术类或者经验类文章，提升一下Blog的格调。\n\n写博客是一个学习的过程，你会因为博客认识更多优秀的人，他们文章可能会对的学习生活有所启发，也可能会解决你遇到的技术问题，或者给你提供了更多信息资讯，这些信息远比那些流量自媒体更有价值。\n\n如果能够维持博客固定更新的话，坚持做一件事，你会收获很多东西，从不要低估坚持这个东西，绳锯木断，水滴石穿，请相信坚持的力量。当然少一些功利主义，多些不为什么的坚持，可能会做得更好。\n\n\n\n**自己的博客计划**\n\n本博客采用的 Hexo + Github pages 搭建的静态博客，想着只更新一些个人笔记，也没必要推广啥的，对于访问速度也没太大要求，也不想弄啥SSL了，国内备案也挺烦的，在阿里云万网买的域名 smallseven.top 感觉还不错，格子小七这个昵称也还挺可爱的。所以在这个个人博客平台主要记录一些学习笔记，生活感想之类的，技术类的文章主要发一些有质量的。\n\n因为学习中常常会遇到一些杂七杂八的问题，都是一些小细节，所以不打算在个人博客里进行记录。我一般会在csdn进行发布，虽然csdn经常遭人吐槽，但是用来做做笔记还是挺好的，重要的是希望这些小问题的解答可以帮助到其他需要帮助的人，自己踩过的坑，希望别人可以避免掉，发扬程序猿的互帮互助精神。\n\n还有一个我比较喜欢的平台是博客园，个人觉得博客园的文章质量比csdn要高，讲的很详细，自定义主题也很多，所以体验比csdn要更舒服一些，我在博客园很少发文章，主要是关注一些优秀的博主，学习一些知识和技能。经常在园子里逛一逛能够了解一些多元化的东西，降低信息壁垒，也算是一种学习途径吧。\n\n\n\n**最后：如果你觉得一件事情有意义那就去做吧，如果你觉得做这件事能够让你快乐的话，那就Hold on，请相信时间的力量，它会给你答案**"},{"title":"六月，感想","url":"/2019/06/06/2019-06-06-my-feelings/","content":"\n今天是2019年6月6日，也是有一个很有意义的日子，熬过了艰难的一周考试，也总算可以放松一下了，虽然还有几门课程没有考，但复习难度并不算太大，所以也不用太担心。好久没有像现在这样舒心的做一些自己喜欢的事了，大概生活就是这样，得到的时候不懂得珍惜，失去了又感觉惋惜，忙中偷闲带来的娱乐感才是最强的。最近其实有很多想法的，但由于事情比较多，思绪也比较乱，也不知道从哪里开始说起，首先还是对自己近段时间的学习状况进行一些总结吧。\n\n上一次发了一篇感想是在新年那天，主要总结了大三上之前的一些关于学习的感想，还给自己加油鼓劲，没想到时间过得那么快，一下半年时间就过去了，仔细想想自己这半年来，收获成长真的没有预期的那么大，很容易陷入某种瓶颈，或者是存在某种不可抗力的因素，无论是学习还是生活，都没有很好的掌控。首先就说学习吧，这学期基本都是专业课，有比较难的核心课程，也有比较水的课程，而且基本所有课程都有实验或者课程任务，实验都是安排在了晚上，所以晚上时间几乎被占用，除了最开始那几周，自己有很多可以支配的时间外，后面都时间安排的都很紧，直到现在的考试周。也可能是我个人对于时间的规划不太合理，生活规律也没能很好的适应时间的分配，所以常常会感到时间不够用。\n\n记得三月份是我状态最好的时候，当时没有太重的课业任务，有很多时间去做些其他的事情，因为是大三了，所以找实习应该算是一件比较重要的事，看了很多春招秋招打法，说要提前一段时间准备，刷一些题，做一些项目，还有就是巩固一下自己自己学过的课程内容，因为春招问的都是基础，自己当时还是有这个意识的，但还是缺乏了充分的准备，在三月份的春招都没得到满意的结果，总结起来就是有意识但没能力，无论是理论基础，还是实践能力都不足够，机试和笔试对于我来说都是不小的挑战，只怪自己以前倒腾的太少，也可能是学习方法有问题，或者总结反思的不到位。后来自己也逐渐改变了打法战略，尽量不去关注那些琐碎的事或者与自己无关的事，尽量以及提升自身实力和技术水平为中心，撸代码，学技术，总结经验，那段时间自己的吸收了很多东西，同时对自己职业规划也有了一个比较清楚的计划。人只要忙起来就会觉得时间过得太快，可能是自己有略微的拖延症问题，所有事情都是几乎要到deadline才完成。现实就是这样，一些事情还没结束，另外一些些事情就已经开始了。所以在4,5月份过得很忙茫盲，因为没有一个量化的标准，所以感觉每天都在做事，但又不清楚做了些什么，一直处于一种繁忙，迷茫，甚至有点盲目的状态，很多计划都被打乱，也散失了很多机会。\n\n到了期末考试周，不得不停下手头上的事情好好准备复习，其实我自己对于考试成绩没太大要求，更多的是希望自己可以尽力而为，但大学很多考试结果真的不一定和付出的努力程度相关，有些科目随便弄一下就能得到一个不错的成绩，而有些科目，你即使花费了很多时间，而结果未必如你所愿。况且大多数科目都有平时成绩的构成，所以很多结果真的不是一场考试就可以决定的，当然也可能是自己不够强，毕竟难的科目大家都难，容易的大家都容易。所以大学考试更多的是一种学习能力的体现，而非努力程度。\n\n我自己是一个比较喜欢做计划和进行反思总结的一个人，做事情更看重的事情的过程，所以在很多事情上花了工费但结果未必满意的原因，如果事情过度的过程化，缺少一个清楚额目标的话，自己做事的效率会很低很低，这是我深有体会的。做事效率低一直是自己的一大缺点，自己也在想办法突破这种局限性，就像软件开发编程一样，如果真的所有事情都过于强调其过程，试图弄清楚它的原理，真的需要花费很多时间和精力，但有些东西如果不把原理弄明白，而是当纯的完成任务，那又有什么样意义呢？所以自己经常会在两者之间纠结，然而现实却只要求你有一个结果就行。\n\nPlanning 和deadline可以让自己提高效率，所以我自己也经常给自己做一些计划，比如看懂那些知识点，学习某种技能。但实际情况是，好多东西在学习时入门很简单，但要是深入到一定程度的话就很难，很容易放弃，所以就会造成了什么都会一定，什么又都不会的尴尬局面，其实在现实生活中，往往更需要掌握和精通一个领域的专家，而不是熟悉多个领域的杂家，一技之长真的很重要，当然对于我们来说，不应该给自己设限，还是应该尽量广泛的去了解多领知识，只有做到除了会某些事情外，其他的事也能做好的水平，才能让自己有更多的发展可能和试错机会。\n\n以前常常因为自己对于一些东西缺乏意识而感到烦恼，现在更多的是因为自己能力不足，不得不做的事没有办法做好，自己想做的事情又没有做到。所以意识和能力都很重要，在这个普遍贩卖焦虑的时代，想要不随波逐流，保持独立意志真的很难，除了撸起袖子加油干，还要多思考，只懂的努力是一件很恐怖的事情，现在社会更强调的是聪明的努力和有意义的努力。\n\n叙述了一堆有用没用的话，同时也让我想到了三年前的自己，2016年6月6日是自己高考前的一天，当时自己满怀信心，从未考虑过高考对于自己意味着什么，一心只想尽力而为。高中三年学习生活并没有想象中过得那么枯燥辛苦，更多的是一种平淡和规律，自己很体验那个过程，体验获得新知识的充实感，体验做对难题的成就感，体验和同学嬉笑娱乐的幸福感。大概这就是高中三年生活的意义吧，往事不过多重提，一切放在心里。曾经一直以梦想和奇迹来鼓励自己，用激情和勇气来为自己加油。而现在更多的是以不忘初衷，不负年华来激励自己，时间过得太快，已经忘记那个梦想初衷究竟是什么了，以后的路还很远，如果不知道自己想要什么，那就让自己变得更好吧。\n\n\n\n\n\n","categories":["随笔集"]},{"title":"关于Navicat for MySQL 的使用小结","url":"/2019/05/30/2019-05-30-navicat-mysql/","content":"\n最近都在做数据库的实验，通过实验了解了一些SQL的语法，也更加熟悉了mysql的使用，实验从最开始数据库的创建，表的创建，包括添加一些条件约束，创建索引触发器等都涉及到了。到后面有关mysql的权限管理，以及通过powerdesigner进行数据库建模设计，和使用Java 编程对数据库进行增删改查，几乎包含了所有数据库基础操作。通过实验，不仅是熟悉一些操作，更多的是了解认识更多东西。实验我使用的是Navicat，mysql，sql的基础语法太多，用到去查就行，这里主要记录一些偏实践性的东西，算是一个小总结吧。\n\n#### 1 、命令行界面查看mysql 版本\n\n```\nmysql> select version();\n+-----------------+\n| version()       |\n+-----------------+\n| 10.1.32-MariaDB |\n+-----------------+\n1 row in set\n```\n\n也可以使用`select version() from dual；`命令，这里的 dual  是数据库里的一个默认表，在没有引用表的情况下，允许将dual指定为虚拟表名。在Oracle中使用的比较多，是一个oracle内部表，它仅包含一行一列，不论我们做什么操作（不要删除记录）它都只有一条记录。\n在Mysql，SQL Server 等数据库中也都有dual 表，不过在mysql中的dual表没有值，`select * from dual` 这种语句会报错。\n\n#### 2、MySQL 和 MariaDB\n\n我使用的xmapp的一个工具包，里面包括了mysql，但是在使用时我发现了我是MariaDB，不是mysql，然后就简单了解了一下mariaDB 和 mysql 的区别。\n\nMariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可。MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。\n\nMariaDB的API和协议兼容MySQL，另外又添加了一些功能，以支持本地的非阻塞操作和进度报告，所以所有使用MySQL的连接器、程序库和应用程序也将可以在MariaDB下工作。\n\n但两者之间也存在不兼容性，MariaDB 的文档中列出了 MySQL 和 MariaDB 之间的数百个不兼容问题。因此，我们无法通过简单的方案在这两个数据库之间进行迁移。\n\n#### 3、数据库存储引擎\n\n数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以 获得特定的功能。\n\n可以使用`show engines` 命令查看MySQL 使用的引擎；\n\n> MySQL 支持的存储引擎包括：InnoDB、MyISAM、Memory、CSV、Archive、Blackhole、Merge、Federated、Example等\n>\n> MariaDB 支持的存储引擎包括：XtraDB、InnoDB、MariaDB ColumnStore、Aria、Archive、Blackhole、Cassandra Storage Engine、Connect、CSV、FederatedX、Memory、Merge、Mroonga、MyISAM、MyRocks等\n\n数据库可以支持多少个存储引擎其实并不太重要，满足需求才是最重要的。如果想了解不同数据库存储引擎的区别可以参考这篇文章 [数据库—四种存储引擎](https://www.cnblogs.com/domi22/p/8059403.html)。\n\n#### 4、Navicat的帮助文档\n\nNavicat提供了特别详细的帮助文档可以点击帮助菜单打开，也可以直接使用按`f1`打开。下面是Navicat for MySQL 一些常用的快捷键。\n\n```\nctrl+q            打开查询窗口\nctrl+/            注释sql语句\nctrl+shift +/     解除注释\nctrl+r            运行查询窗口的sql语句\nctrl+shift+r      只运行选中的sql语句\nF6                打开一个mysql命令行窗口\nctrl+d            查看表结构详情，包括索引 触发器，存储过程，外键，唯一键\nctrl+l            删除一行\nctrl+n            打开一个新的查询窗口\nctrl+w            关闭一个查询窗口\nctrl+tab          多窗口切换\n```\n\n#### 5、sql 脚本的导入导出\n\n1. 可以直接点击右键点击数据库，运行SQL文件 或者转储SQL文件，就可以将已有的sql 文件导入数据库和将数据库保存为sql文件。也可以右键单击数据库，选择文件传输，这里可以选择不同的连接和数据格式，可以有选择的导入导出传输。\n\n2. 通过命令行导出sql文件\n\n   ```\n   mysqldump -h 127.0.0.1 -uroot -ppassword databasename >D:/back_databasename.sql\n   ```\n\n   > 使用命令行，先进入mysql的安装目录。我这里是xmapp安装的，所以切换到C:\\xampp\\mysql\\bin\n   >\n   > mysqldump -h 127.0.0.1 -uroot -ppassword databasename >D:/back_databasename.sql\n   >\n   > 用户名为：root，与-u之间可有空格（-h后也可由空格）密码为：password（你自己的密码），注意！-p后面不可有空格，直接跟密码。数据库名称为：databasename（你自己要导入导出的数据库名），导出路径为：D:/back_databasename.sql（根据自己实际情况修改）\n\n3. 通过命令行还原sql文件，上面步骤相似\n\n   ```\n   mysql -h 127.0.0.1 -u root -ppassword -f databasename <D:/back_databasename.sql --default-character-set=gbk\n   ```\n\n4. 使用命令将数据库下表中的数据导出成文本文件\n\n   ```\n   mysql> use hhh;  // 使用hhh数据库\n   mysql> show tables; //查看数据库中的表\n   mysql>select * from user into outfile 'out.txt'; //将user表保存为文本文件out.txt\n   ```\n\n#### 6、使用xmapp启动mysql\n\n1. 命令行进入，先在Xampp的控制面板(shell)开启MYSQL，直接进入路径启动\n\n   > 命令行切换至xmapp安装目录下的mysql目录下的bin目录\n   >\n   > 比如：C:\\xampp\\mysql\\bin\n   >\n   > mysql -u root -p 回车 \n   >\n   > 要求输入密码（如果是第一次登陆，直接回车，默认密码 \"\"）修改密码\n\n2. 修改密码\n\n   > 命令行切换至xmapp安装目录下的mysql目录下的bin目录\n   >\n   > 比如：C:\\xampp\\mysql\\bin\n   >\n   > 使用命令修改密码：mysqladmin -u root -p password 新密码\n   >\n   > 修改密码后 mysql -u root -p 登录时就需要输入密码了\n\n3. 配置环境变量\n\n   > Path变量中加入C:\\xampp\\mysql\\bin \n   >\n   > win+R -> cmd回车\n   >\n   > mysql -u root -p 回车 \n   >\n   > 要求输入密码（如果是第一次登陆，直接回车，默认密码 \"\"）\n\n#### 7、root 和 非root的区别\n\n我在使用xmapp时，启动mysql，并通过Navicat连接了数据库后，创建了一些数据库，在Navicat里面的命令行界面可以查看到我创建的数据库，但是在xmapp shell 里面进入mysql 却没有显示我创建的数据库。\n\n**原因**：是我在使用Navicat连接mysql时，使用的是root身份，但通过xmapp shell 进入mysql，我是直接启动的mysql，并没有使用root 进登录的。所以无法查看root身份下的创建的数据库，只是有几个系统默认的数据库。\n\n**解决方法**：使用命令 mysql -u root -p 进入mysql。这时就可以通过查看自己创建的数据库了。\n\n**重要**：以后在使用数据库时要区分以什么身份登录root 和非root有很大区别，对于数据库的管理权限也有所不同，具体情况具体分析。","tags":["mysql"],"categories":["学习笔记"]},{"title":"关于前端学习的小总结","url":"/2019/05/02/2019-05-02-study-html/","content":"\n记录一下近期的学习心得，由于参加一个比赛需要一个简单的web页面来展示结果，所以需要取学习一些前端的开发的技术。之前也看过一些 web 页面的知识，但没有亲自去尝试过，这次正好有机会去进行更深入的了解。\n\n### 0x01 前端基本功\n\n要说前端开发，首先得有一些基本功，就是我们平时说的 HTML CSS JavaScript。这些是构建一个网页的基础，之前搭博客我了解过一些HTML和JS的东西，只限于看得懂，也做过一些页面的修改，但是亲手编写的话，还是有一定的困难，不过好在可以查资料，照葫芦画瓢，还是能做出来一些。\n\n之前尝试过开发一款微信小程序，好多东西都是参考着网上的教程一步一步的做，其中也涉及了大量的网页前端的知识，业务逻辑实现都是用的 JS 当时主要是参考了微信小程序的开发文档，它提供很多可以直接使用的API，如果是实现简单功能的话，会调用就行，当时做的是一款天气预报的小程序，数据来源是百度地图的API，比较有挑战的是 WXSS 样式设计，类比于Web页面的CSS，可以这么说页面好不好看取决于你的样式表设计和布局，因为没有系统学习过，当时还是花了很长时间去设计CSS，尽管如此，最后的页面还是惨目忍睹。\n\n再说这次页面的编写，有了之前的基础，这次在JS 和 CSS 的设计和实现上感觉容易多了，也更加了解了一个页面的构成。一个 HTML 页面定义了整个网页的结构，把所有CSS 和 JS 都包含起来。当然大多数开发者是很少会直接在HTML里面定义CSS 和JS的，通常是将它们放在单独的文件夹，通过引入进行调用。\n\n下面这个例子就是个简单的HTML页面，其中包含了页面布局的定义，CSS的定义，以及一个简单 JS 脚本。在HTML页面里CSS是通过`<style></style> `标签定义引用的，一般在HTML的`<head></head>`内引入，也可以直接在标签内进行定义，CSS 样式多变难记，不过十分容易理解，在使用时可以查找相关资料。JS脚本实现的逻辑功能，在页面里 JS 是通过`<script></script>` 标签定义引入的，一般情况  JS 在页面内定义位置不影响，是全局的，通过使用JavaScript 能够大大增强HTML的交互性。\n\n对于HTML页面来说，整体结构就是head、body；整个页面需要`<div></div>`等各种标签进行组合，一个功能完善并且好看的页面是需要HTML，CSS，JS 共同协调构建的。\n\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <title>这个是标题</title>\n        <style type=\"text/css\">\n\t\tbody{\n\t\t    height: 100%;\n\t\t\twidth: 100%;\n\t\t\tbackground-color: yellow;\n\t\t\n\t\t}\n        /*标签选择器*/\n        p{\n            color:red;\n        }\n        /*类选择器*/\n        .first{\n            color:red;\n        }\n        /*id选择器*/\n        #first{\n            color:green;\n        }\n    </style>\n\n    </head>\n    <body>\n\t\t<div>\n        <h1>这是一个一个简单的HTML,h1\n            <p id=\"test\">Hello World！</p>\n        </h1>\n        <h2>这是一个一个简单的HTML,h2</h2>\n\t\t<p style=\"color:orange;font-size:18px\">在HTML中使用css样式</p>\n\t\t</div>\n    </body>\n    \n     <script type=\"text/javascript\">\n        var mystr = document.getElementById(\"test\")\n        document.write(\"p标签修改之前：\"+mystr.innerHTML+ \"</br>\");\n        mystr.innerHTML=\"hello web!\"\n        document.write(\"p标签修改之前：\"+mystr.innerHTML + \"</br>\");\n    </script>\n</html>\n```\n\n\n\n### 0x02 浅谈 JavaScript\n\n对于前端开发来说，应该比较复杂的就是业务功能实现这部分了，我在刚接触 JS 的时候也是摸不着头脑，最开始连代码都看不太懂，更别说写。不过接触多了，慢慢的也就熟悉了。\n\n首先需要了解什么是DOM（文档对象模型），它定义了访问 HTML 和 XML 文档的标准， 是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。其中包含了大量的对象，通过对象调用可以实现一些特定的功能，比如常用的Document、Event 事件、Form表单等。\n\n在这次网页编写时我还使用了 jQuery，它属于 JavaScript 的一个库，可以极大的简化 JS 编程，功能也十分强大，如果有前面说的基础，那也很容易学。在使用 jQuery 的时候需要使用`<script>` 标签将 jQuery 添加到网页中，`<script>` 标签应该位于页面的`<head> `部分。src 可以是下载到本地js，也可以是远程当然 jquery.js 链接。\n\n```html\n<html>\n<head>\n<script type=\"text/javascript\" src=\"/jquery/jquery.js\"></script>\n<script type=\"text/javascript\">\n    $(document).ready(function(){\n    $(\"button\").click(function(){\n    $(\"p\").hide();\n    });\n    });\n</script>\n</head>\n\n<body>\n<h2>This is a heading</h2>\n<p>This is a paragraph.</p>\n<p>This is another paragraph.</p>\n<button type=\"button\">Click me</button>\n</body>\n</html> \n\n```\n\n为实现与服务器交换数据并更新部分网页，我还去了解一些 AJAX。异步的 JavaScript 和 XML，这是一种用于创建快速动态网页的技术，其最主要的优势是可以在不重新加载整个网页的情况下，对网页的某部分进行更新，更能体现 Web 应用的动态性和实时性。\n\nAJAX 虽然看起来比较复杂，但还是比较容易理解，整个创建过程的格式都是固定的，需要考虑的主要是事件的触发以及元素的更改，也就是什么时候调用 ajax，以及修改那些数据，通常使用的方法是使用 document.querySelector() 属性选择器来进行操作的。\n\n```html\n<script >\n\t//1.建立xmlHttpRequest对象\n\t//2.使用OPEN方法与服务器建立连接此步注意设置http的请求方式（post/get）\n\t//3.设置回调函数，在回调函数中针对不同的响应状态进行处理\n\t//4.向服务器端发送数据， 如果是POST方式就不为空\n\n\t// 可以简写为 var xmlHttp = new XMLHttpRequest();\n\tif(window.XMLHttpRequest) {\n\t\t// 建立xmlHttpRequest对象\n\t\tvar xmlHttp = new XMLHttpRequest();\n\t\tif(xmlHttp.overrideMimeType) {\n\t\t\txmlHttp.overrideMimeType(\"text/xml\");\n\t\t}\n\t   }\n    else if(window.ActiveXobject) {\n\t\tvar activeName = [\"MSXML2.XMLHTTP\", \"Microsoft.XMLHTTP\"];\n\t\tfor(var i = 0; i < activeName.length; i++) {\n\t\t\ttry {\n\t\t\t  xmlHttp = new ActiveXobject(activeName[i]);\n\t\t\t  break;\n\t\t\t } catch(e) {}\n\t\t\t}\n\t   }\n\t   if(!xmlHttp) {\n\t\talert(\"创建xmlhttprequest对象失败\");\n\t   }\n\telse {}\n\t\t\n\t// 如果是POST方式，注意设置请求头信息, GET方式可以不设置\n\t// xmlHttp.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\")\n\txmlHttp.open(\"get\",\"getData.php?name=\"+ name,true)\n\t\t\n\t// 设置回调函数\n\txmlHttp.onreadystatechange= callback;\n\tfunction callback(){\n\tif(xmlHttp.readyState == 4 && xmlHttp.status == 200){      \n\t\t//判断交互是否成功获取服务器返回的数据 \n\t\tvar responseText =xmlHttp.responseText;\n\t\tdocument.getElementById(\"info\").innerHTML = responseText;\n\t   }\n\t}\n\t//向服务器端发送数据\n\txmlHttp.send(null);\n</script>\n```\n\n通过实际上手，自己也尝试了一些 JS 的编写，其实大多数编程的一个套路，只要思想了解了，稍微了解一些语法就能实现一些简单的功能，重要的是多尝试和多实践。\n\n\n\n### 0x03 Bootstrap 框架\n\nBootstrap 是目前最受欢迎的前端框架，是基于HTML，CSS， JavaScript的。开发框架最主要的目的就是方便开发，提供一些列通过模板，开发者可以通过引用修改，完成自己的功能，不需要自己重复早轮子。\n\n之前我也重来没有接触过前端框架，也不知道该如何使用，通过这次亲手实践，对前端框架有了一个更深入的了解。在使用Bootstrap的时候只需要访问它的官网，可以下载源码，也可以直接使用BootstrapCDN将预编译的 CSS 或 JS 文件引入页面。网站还提供了一些样式，自己可以选择自己需要的进行修改使用。\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n   <meta charset=\"utf-8\"> \n   <title>在线尝试 Bootstrap 实例</title>\n   <link rel=\"stylesheet\" href=\"https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css\">  \n   <script src=\"https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js\"></script>\n   <script src=\"https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js\"></script>\n</head>\n<body>\n\n      <h1>Hello, world!</h1>\n\n</body>\n</html>\n```\n\n\n\n### 0x04 XML和JSON\n\n在 Web 开发中不可避免需要与数据进行交互，最典型的两种数据格式是xml 和 json。xml 实际上是一种扩展性标记语言，可以标记数据和定义数据类型。而json则是一种轻量级的数据交换格式，可在不同平台之间进行数据交换。两者各有优缺点，但是在对数据进行解析时 json 要稍微容易些，可读性也更强。\n\n在实际开发中，包括后端开发中数据格式也常常为JSON。下面通过两个实例进行比较一下：\n\n<1>.用XML表示中国部分省市数据如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<country>\n  <name>中国</name>\n  <province>\n    <name>云南</name>\n    <citys>\n      <city>保山</city>\n      <city>昆明</city>\n    </citys>  　　\n  </province>\n  <province>\n    <name>四川</name>\n    <citys>\n      　<city>成都</city>\n      　<city>乐山</city>\n    </citys>　\n  </province>\n  <province>\n    <name>新疆</name>\n    <citys>\n      <city>乌鲁木齐</city>\n    </citys>\n  </province>\n</country>\n```\n\n<2>.用JSON表示中国部分省市数据如下：\n\n```json\nvar country =\n        {\n            name: \"中国\",\n            provinces: [\n            { name: \"云南\", citys: { city: [\"保山\", \"昆明\"]} }, \n            { name: \"四川\", citys: { city: [\"成都\", \"乐山\"]} },\n            { name: \"新疆\", citys: { city: [\"乌鲁木齐\"]} }\n            ]\n        }\n```\n\n\n\n### 0x05 PHP 真好！\n\n在进行Web开发时，前端的问题解决了，就需要考虑后端服务器的问题，如果构建动态网页的话，不可避免的需要与服务器进行数据交互，一般情况下后端代码都是后端程序员编写，然后会留出一些接口给前端程序员调用。\n\n这次网页的编写因为需要进行数据交互，所以我尝试了最容易上手的服务器脚本语言PHP，毕竟它是最好的编程语言嘛，虽然之前一直在说这个梗，但一直没有去接触了解，现在尝试了一些，果然是好用啊。\n\n```php\n<?php\n\t//第一个PHP代码\n\t//设置页面编码格式\n\theader('content-type:text/html;charset=utf-8');\n\n\techo \"hello PHP\";\n\techo '<br>';\n\t\n\techo \"PHP 是世界上最好的语言！\";\n\techo '<br>';\n\t\n\t$name = \"ppd\";\n\techo \"name: $name\";\n\n\tfor($i = 0; $i < 10; $i++){\n\t\techo \"666\";\n\t\techo \"<br>\";\n\t}\n?>\n\n```\n\n### 0x06 小结一下\n\n经过不断踩坑尝试，了解和学到了很多东西，其实很多东西比想象中的要容易，在没有动手做之前总觉得什么都太难，也不想去尝试，其实迈出第一步，后面会好很多。\n\n解决问题的能力很重要，要把学习和解决问题划分开，学习需要的循序渐进，系统掌握。而解决问题更重的是针对问题本身，找到其解决的办法，最常用的方法莫过于搜索查找。前者是理论基础，后者是实践经验，二者都需要培养提高。\n\n差不多根据自己了解的前端开发做了一个总结，内容都是很基础很简单的，如果深入的学习了解可能会有更多的发现和感悟。\n\n","tags":["前端"],"categories":["学习笔记"]},{"title":"选择blog主题为Hexo-Casper","url":"/2019/04/12/2019-04-12-hexo-blog/","content":"\n\n\n选择 blog 主题 Hexo-Casper，这个主题的卡片样式我很喜欢，而起可以动态适应，page页可以添加摘要显示图片，可以让blog 避免了呆板，显得灵活有个性，page页内可以添加图片指定，可以为文章配图，能突出文章内容。\n\nrecent post，category，tag 页以卡片样式置于页面底端，不影响文章的阅读，布局很合理也很美观，PC端和移动端适应都比较好。页面的 footer 设计的十分简洁，没有过多无意义的内容，看起来很舒服。\n\n之前尝试过的几个主题对评论功能适应的不是很好，这次使用[Valine](https://valine.js.org/)，开启了评论功能 ，适应的还不错，个人比较满意。\n\nsocial 链接提供了很多选项，像 Twitter，Facebook 支持但在国内也无法访问，微博太偏向娱乐化，所以我只贴了 github 链接。事实上social 功能对于博客其实作用不大，只需在about上加一个自己的联系方式就行，我认为。\n\n当然这个主题好像也存在一些问题，比如怎么开启 rss，还有其他一些可能存在的小问题，不过问题不大，对于blog的整体体验没什么影响。\n\n之前我试过一些主题，总是会因为一些问题感觉使用起来不方便，所以更换过好几次theme，这次Hexo-Casper，个人感觉还是比较满意的。顺便把之前的几篇文章迁移过来，看了一下也很适应，只是没有引入摘要图片，这篇文章是新主题的第一篇文章，把“黑洞”照片作为了摘要图片。\n\n关于blog主题Hexo-Casper，大概就这些吧。","tags":["hexo"],"categories":["小把戏录"]},{"title":"MkDocs构建项目文档流程","url":"/2019/03/31/2019-03-31-mkdocs/","content":"\n发现很多开源的项目文档，技术说明文档都是使用 mkdocs 构建，自己也了解了一下，确实很简单，快速。它的主题也很简洁，大方，作为技术项目说明或者笔记文档是相当合适的。\n\n构建部署流程大致如下，详细可以参考官方完整指南。\n\n环境：\n\n* 支持Windows/Linux/macOS\n* 需要安装 Python 2.7 +\n* 需要 pip\n\n1、安装MkDocs \n\n```\n$ pip install mkdocs\n```\n\n运行 `mkdocs help` 可以检查是否正确安装。\n\n2、输入以下命令构建项目\n\n```\n$ mkdocs new project\n```\n\n`project` 是指项目名，你要在那个目录下创建，就切换到那个目录下  Windows的cmd 命令行和Linux的终端命令都是类似操作。\n\n构建好的项目里有一个配置文件 `mkdocs.yml`, 和一个包含文档源码的 `docs` 文件夹. 在 `docs` 文件夹里包含了一个名为 `index.md` 的文档. \n\n3、启动内建服务器，进行预览\n\n```\n$ mkdocs serve\n```\n\n它会自动使用8000 端口，在浏览器中打开` <http://127.0.0.1:8000/> `就可以完成效果的预览。\n\n之后就是修改配置文件 `mkdocs.yml` ，自己可以添加一些配置信息，包括站点名称，文档页面等，很简单。\n\n4、使用以下命令,创建新的页面\n\n```\n$ curl 'jaspervdj.be/lorem-markdownum/markdown.txt' > docs/about.md\n```\n\n其实根本不用那么麻烦，在Windows下只用像创建文件目录那样操作即可，所有的文件都在`docs` 文件目录内。\n\n5、主要是修改配置文件 `mkdocs.yml`，这个决定了你的站点结构。\n\n```yml\nsite_name: LYDSDOCS\n\nnav:\n- Home: index.md\n- CSDocs:\n        - 操作系统: csdocs/OSNotes.md\n        - 数据结构: csdocs/data-structure.md\n        - 软件工程: csdocs/software.md\n\n- About: about.md\n\ntheme: readthedocs\n```\n\n6、站点生成\n\n```\n$ mkdocs build\n```\n\n该命令创建了一个 `site` 新目录. 里面的文件就是你的站点资源文件，你可以把这些文件部署到服务器上或者github page上，就可以进行访问了。\n\n大概流程就这些，其实和 hexo 生成站点差不多，一些具体的细节可以参考官方文档。[MkDocs 中文文档](https://markdown-docs-zh.readthedocs.io/zh_CN/latest/)\n\n","tags":["markdown"],"categories":["小把戏录"]},{"title":"认识 Shell Bash Cmd","url":"/2019/03/28/2019-03-28-linux-shell/","content":"\n\n\nWindows 系统中的 cmd 的某些命令和 dos 中的命令相似，所以有很多人把二者混为一谈，dos 本身就是一个系统，我们大概几乎可能接触不到了，而我们平时使用的 cmd 命令行是属于Windows系统的一部分，是一种桌面应用。另外 cmd 也不是 shell，虽然都是命令解释器，但 bash 要比 cmd 强大的多，当然Windows也有强大的shell叫windows power shell。\n\n\n\n对于我们常说的 Shell，它既是一种脚本语言，又是一种应用程序。Shell 是 UNIX/Linux 下的脚本编程语言，它无需编译，是解释执行的。另外 Shell 还是用户和应用程序与内核沟通的桥梁，它的一端连接着 UNIX/Linux 内核，它提供了用户与内核进行交互操作的一种接口，它接收用户输入的命令并把它送入内核去执行。\n\n\n\nShell管理我们与操作系统之间的交互：等待我们输入，向操作系统解释我们的输入，并且处理各种各样的操作系统的输出结果。不同系统有不同的shell，如bash、C shell、windows power shell 等等；在linux系统中，通常是Bourne Again shell ( 即bash).\n\n\n\nTerminal 在Linux 系统中打开终端后，就可以输入Shell 命令了。\n\nBash 是shell 的一种，最常用的shell之一。\n\ngit Bash 方便在windows下使用git命令的模拟终端。\n\nPuTTY是一个Telnet、SSH、rlogin、纯TCP以及串行接口连接软件。\n\nXshell是一款功能强大且安全的终端模拟器，支持SSH、SFTP、TELNET、RLOGIN和SERIAL。\n\n","tags":["shell"],"categories":["学习笔记"]},{"title":"RISC指令集的五个周期","url":"/2019/03/16/2019-03-16-rsic-instruction/","content":"\nRISC(reduced instruction set computer,精简指令集计算机)简称为精简指令集。RISC把执行指令的精力主要放在了经常使用的指令上面。本文主要介绍了在RISC指令集中一条指令的五个主要执行CC（Clock Cycle，时钟周期）的主要涵义以及内容。\n\n这五个时钟周期分别为：IF(Instruction fetch，取指令)，ID(Instruction decode/register fetch cycle，指令解码)，EX（Execution/effective address cycle，执行），MEM(Memory access，内存访问)， WB(Write-back cycle，写回)。\n\n**IF**：根据PC（program counter，程序计数器）中所存储的内存地址，在内存中找到该地址所指向的指令，并将该指令存储在寄存器中。同时，PC指向下一条指令，完成这个操作要求PC加4（以32位指令集为例，如果是64位则要加8）。\n\n**ID** :  操作从IF阶段获取来的指令。将指令解码，最终找到指令所需要的寄存器中存储的数据。如果该指令只一条跳转指令，那么在这一阶段需要根据跳转指令的意义对获取的值进行比较，如果比较结果为true则执行跳转，如果比较结果为false则不执行跳转，继续下一条指令的执行；如果指令需要对指令中某些位进行填充，也在ID阶段完成，比如对高四位进行填充以满足指令结果是32位；计算可能跳转的指令的地址。   \n\n**EX** : ALU（Arithmetic Logic Unit，算术逻辑单元）对ID阶段的结果进行计算。在ID阶段已经获得了指令计算所需要的寄存器的值，那么在EX阶段需要根据指令的意义对这些寄存器的值进行计算。计算根据指令的不同变得不同。主要有三种类型的ALU计算：1. ALU根据ID中补充的地址，对有效的地址单元进行计算，最终得到所需要的内存的地址；2. 根据指令的意义，对从寄存器中获取的值，进行操作，比如对两个寄存器的值进行相加；3. 根据寄存器的值以及补充的值，计算出立即数的结果。    \n\n**MEM**：如果当前指令是Load指令，那么，根据EX计算出的内存地址，从内存中获取对应的值；如果当前指令是store，那么，根据EX计算出的内存地址和寄存器的值，将寄存器的值存入该内存地址中。其他的指令一般不会设计内存的访问。   \n\n**WB**：将计算出来的最终的寄存器的值写入到register file（寄存器文件）中。这部操作包括从内存中获取的值以及通过算术运算得到的结果。 \n\n以上五个时钟周期便是一条RISC指令执行的主要步骤。","tags":["RISC"],"categories":["计算机"]},{"title":"This is my first micro-entrepreneurship","url":"/2019/01/20/2019-01-20-entrepreneurship/","content":"\n\n\n今年寒假，花了十天时间筹备了一个简单的微创业项目，结果虽然并不理想，但还是有些收获，在此对整个项目做一个简单总结。\n\n### 项目发起\n\n这个项目主要是做一个线上的编程课外培训班，这个项目是好几个月前朋友就跟我提起过的，因为和我本人专业相关，而且出于朋友间的关系，我是比较支持的。朋友跟我简单讲了项目的一些立意和初期计划，我们达成了共识，而且寒假自己也能腾出手来弄，索性就尝试一下。\n\n### 项目运营\n\n因为是微创业项目，也不打算盈利，重在尝试体验。到了寒假我们就开始着手准备，经过朋友的联系，大多数合伙人都是高中要好的朋友。本身项目不大，所以团队人数不多，包括三个运营小姐姐，还要三个讲师小哥哥，我呢就是其中一个。\n\n项目运营之前朋友做过一些市场调查，了解到现在编程培训还是比较有市场的，我们的面向群众主要是小学初中零基础的同学，让他们来体验编程，接触编程，或者是通过课程培养一些有关编程的兴趣，这也是我的一个初衷，因为自己就是大学才开始接触编程，以至于后面学习起来稍显费劲。\n\n我们主要设置了三门语言的学习，其中包括 Scratch，Python还有 C++，我们的想法是让孩子有一定的选择。因此我们也安排了试讲环节，主要是让家长和孩子了解编程，鼓励他们来学习。\n\n宣传环节主要是借助微信公众号平台，对编程，对课程，对讲师进行宣传。发动了我们周围一切能调动的资源，不过最后的结果和预想的还是有一定的差距的。\n\n### 项目总结\n\n项目最终的结果不太理想，但我们也收获了很多东西，下面列一些项目主要存在的问题，主要是是依据我个人的实践体验：\n\n#### 遇到的问题\n\n1. 没有很好的平台。现在做编程培训的太多了，一个好的平台至关重要，项目开始是我们没有一个很好的平台去做宣传，就连授课方式，我们也是最后才敲定的采用QQ线上投屏的。\n2. 宣传受众面窄。我们主要采取的是微信公众号平台宣传，首先是我们的朋友圈朋友多半不太需要这方面的服务，其次是我们家乡那边的对于编程概念还是不太理解看重。这是和我们最开始理想化状态差的最远的。\n3. 课程内容设置。我个人认为是课程内容不太有针对性，我们应该集中一个点去突破，而不是多门语言的选择，其实如果我们主打一门语言或者一个方向会更加好，用户也能清楚通过课程他们能够获得什么。\n4. 线上交流的不方便性。因为小伙伴都是不同学校的，大家交流都是通过线上，好多东西交流时都不是很方便，想法可能无法清除的表达，相互的建议也不是很多。当然交流的过程倒是还挺好，大家都比较亲切。\n\n#### 收获的东西\n\n1. 初次体验，知道了创业之路的艰辛，也体验了一把简单创业的感觉，虽然失败了，但成就感满满，如果有机会，下次可能会做的更好。\n2. 得到很多朋友的支持，虽然是微信宣传，但大多数朋友都帮忙宣传推荐，得到很多朋友的支持，也体会到浓浓的朋友情谊。\n3. 线下的用心准备和线上的交流，通过线下的花时间准备上课内容，收集资料，制作课件，都尽了自己最大的努力去争取做到最好。线上的试讲课准备，到实际讲解都经过提前排练，那种认真做事的感觉，真的很好。\n4. 团队协作发挥更多的能量，我们每个人都按事先约定完成每个人的任务，其中相互帮助，互给建议，让我们这新手团队散发出最大的能量。\n\n### 个人总结\n\n下面谈一谈个人的一个总结，通过这次活动我尝试了一些新的东西，也学到了一些东西。首先是我对Python语言的再次熟悉，因为计划是我负责Python语言的教学，我从新去了解Python，包括软件的安装以及基础概念回顾，我都重新弄了一遍。\n\n其次是线上直播教学，投屏授课是第一次，虽然只有一次试讲课，但是体验是我从看其他人的网课，到自己制作网课的一个转换。未来互联网的发展会越来越好，我们一个学会利用和使用互联网。\n\n对知识付费这个概念有了新的认识，其实现在网上有很多免费的资源，当然也有收费的。收费的一定会比免费的好吗？不一定，免费的到底是不是完全公益化的？也不好说但知识付费这个概念和互联网共享这个关系还是值得仔细思考的。\n\n合作交流是我最看重的东西，良好的交流合作可以让工作更加顺利，谦虚温和的态度更能加速合作进程，当然想法和建议也是不可缺少的，只有更新互补，才能共同进步。\n\n#### 未来战略\n\n通过这次简单的项目，我自己也思考了很多，对自己也有了一个新的定位。首先直接还是要苦练技术，把技术提高到一个档次，必须有一技之长。其次是向阔度发展，了解相关技术，熟悉掌握当下社会需要的技能，也应该多了解其他领域的东西，积累一些知识面或谈资。另外，就是保持好奇心，保持学习动力，积极学习新技术新知识，及时巩固基础知识和技能，完成知识闭环，形成自己的知识体系。当然最重要的是保持良好心态，保持纯真性格，做自己喜欢的事，做自己认为有意义的事。\n\n![curious](http://wx2.sinaimg.cn/large/00709Ldkly1fzdjhpd46vj30qo0egmyl.jpg)","tags":["分享"],"categories":["随笔集"]},{"title":"Hexo + github page + markdown 搭建静态博客","url":"/2019/01/12/2019-01-12-github-page/","content":"\n学习是一个渐进式是过程，需要不断摸索前行，凡是遇到好玩都去尝试，然后就会发现更多有趣的东西。\n\n我最开始是想要在github上了解一些开源的项目，然后注册了账号，然后就学习使用Git进行版本控制；因为要写readme，然后了解了markdown，学习了基本语法，然后习惯使用它写文档；通过github page搭建静态博客，学习了一点html，后来发现了hexo，然后使用hexo + github page搭建博客...做了一个简单的脑图：\n\n\n\n\n\n![img](http://wx2.sinaimg.cn/mw690/00709Ldkly1fz3qrvyblgj30mh0jxq4z.jpg)                                     \n\n我一开始并不知道想做什么或是如何去做，所有的都是因为好奇，然后不断尝试。这一路走来，也可以说是踩坑无数。接下来就记录一些遇到的坑以及解决办法。\n\n\n\n### 1、关于Git和GitHub\n\n#### 关于Git\n\nGit是目前世界上最先进的分布式版本控制系统（没有之一），是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的分布式版本控制系统。据说是Linus 花了两周时间自己用C 写出来的！\n\n在这里也没有必要列举Git的优点和其具体的工作原理。关于Git的使用教程，网上更是一大堆，学习起来并不难，如果有Linux基础的话进更是得心应手。这里推荐两个教程：\n\n第一个是：[廖雪峰Git教程](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000) \n\n第二个是：[RUNOOB网站Git教程](http://www.runoob.com/git/git-tutorial.html) <http://www.runoob.com/git/git-tutorial.html>\n\nGit学习最开始比较难的是命令记不住，比如git commit，git branch等等，很容易记混乱，需要多加练习才能熟能生巧。\n\n**我遇到过的几个问题：**\n\n1. 不熟悉命令，只会 git clone，后来通过耐心学习教程，并通过实践，慢慢的才领悟到Git的精髓。\n\n1. 不会多人共同开发项目，多人开发也不好亲自实践。比较麻烦，为了体验学习多人开发项目，最后不得已又注册一个github账号（感觉都点傻），做了模拟开发体验。\n\n1. 也就是因为注册了两个github账号，可我只有一个Git呀，所以要配置环境，生成两份秘钥，使用Git时要区别是哪个账号，这个坑花费了我好长时间才解决的。现在想想还是觉得挺值得的。毕竟以后可能要在不同平台上进行代码托管。\n\n总的来说，学习Git还是比较容易，用到什么学什么是比较快的。最好作一些记录方便下次使用。当然如果有足够的时间和精力，可以根据教程进行系统详细的学习。\n\n#### 说说github\n\n说到 git 就必须要提一下github，作为最大的开源代码托管平台，对于程序猿都应该不陌生。这个平台汇聚了巨大的资源，包括开源项目，以及一些教程，还有很多的awesome summary。\n\ngithub优点有很多，当然也有一些缺点，在这里不多评说。针对开源托管平台，类似网站有很多，包括gitlab，码云等等，不过这些都可以通过git进行版本控制的。\n\ngithub使用很简单，就是注册账号，配置信息进行，如果只想体验或看项目的话，甚至不需要学习git。\n\n**关于github注意几点:**\n\n1. 注册时起一个有意义的名字，看个人情况吧，尽量避免花里胡哨（程序员的强迫症 >_<）。\n\n1. 遵守一些相关规定，比如说文明上网，不要发布一些不好的东西。尊重作者和版权信息，虽然是开源，但还是有必要对作品一些信息进行声明，不要抄袭。\n\n1. 学会写readme，如果要维护一个开源项目，希望可以写出相关的说明文档，还有就是尽量使用English。\n\n关于github如何使用，有官方的指导教程，网上也有很多教程和博客，写的都很详细，在此就不写了，可以参考以下两篇文章：\n\n[Github使用教程（一）](https://www.cnblogs.com/liuleilei/p/6486665.html)<https://www.cnblogs.com/liuleilei/p/6486665.html>\n\n[Github 简明教程 ](http://www.runoob.com/w3cnote/git-guide.html)<http://www.runoob.com/w3cnote/git-guide.html>\n\n#### 关于github page\n\ngithub page 是 github 提供的一个站点平台，可以利用它写文档，搭建博客。而且github本身也有很多主题可以选择，关于这方面也有很多教程。我也不想写具体搭建过程了。\n\n我最开始就是使用github page，说实话不是很方便，而且我也不会HTML，因此我还学了一段时间的HTML5，写了几个简单网页，CSS真的很烦人，后来终于从入门到放弃了。\n\n然有找到了一个很好用的 blog 模板（那时候还不到hexo）。然后就git clone 下来，修改配置。根据网上一步一步的弄，终于搞定了我的 第一个版本 blog ，后来在此基础上修改了很多。但是发现通过这种方式搭建博客越来越不方便，而且觉得那个博客太花里胡哨，最终....我开始使用 Hexo 了。\n\n使用Hexo + github page 搭建博客太方便了，接下来看看如何使用hexo + github page搭建静态博客以及需要主要的问题。\n\n\n\n### 2、使用Hexo + Github page 搭建博客\n\n前面文章已经介绍了有关 github 和 git 的使用说明方法，有讲了自己通过github page搭建静态博客的踩坑经历，现在来说说自己通过Hexo + github page搭建博客遇到的问题。\n\n#### 关于Hexo\n\nHexo是一个比较简单的站点生成工具，而且它有很多博客主题，生成，发布都是十分方便的，所以也广受大家喜欢，因此也有很多关于hexo搭建博客的教程，它自己也有官方的使用指导说明。\n\n使用Hexo 首先需要安装 node.js 。一开始我不知道这是什么，也不知道怎么使用，没时间且怕麻烦，所以一直没有安装。后来才发现特别简单，根本不麻烦，而且很好用。随便网上一搜就有安装教程，而且对Windows用户也很友好，只需一点基本的命令行命令就行。（经验：管它会不会，先安装，再捣腾）。\n\n#### 选择主题\n\nHexo有很多主题可以选择，网上参考推荐也有很多，看个人爱好吧。这个可以参考一个知乎的回答：\n\n[有哪些好看的 Hexo 主题？](https://www.zhihu.com/question/24422335#answer-13939146)\n\n为了避免以后折腾，建议选择一个比较满意的且个性化配置多一点主题，方便自己调整，也省去一些不必要到重复修改。\n\n#### 修改配置\n\n首先需要访问博客主题开源主页，基本上都有详细的使用说明，按照使用步骤操作就行，其中可能会用到一些 js的包，使用npm直接安装就行。配置教程网上有很多，还有许多个性化的配置。我也就不写了，但是我配置时也是参考网上的教程。有两篇比较全面并且不错的教程可以参考：\n\n[hexo的next主题个性化教程](https://www.jianshu.com/p/f054333ac9e6) <https://www.jianshu.com/p/f054333ac9e6>\n\n[hexo + next主题优化](https://blog.csdn.net/sunshine940326/article/details/69933696) <https://blog.csdn.net/sunshine940326/article/details/69933696>\n\n需要说明的是，每个主题的配置是不一样的，但绝大多数时类的。善于使用搜索引擎，不会就搜就行。需要注意的是：边配置边测试，使用hexo server做本地调试，方便查找因为配置错误而出现的问题。\n\n#### 生成创建发布\n\n主要是利用Hexo进行生成创建发布，需要的是熟悉hexo的几条常用命令。\n\n```\nhexo new post post-name //创建新文章\nhexo server //本地调试\nhexo g //生成\nhexo d //发布\n```\n\n这里需要注意的发布到github平台或者其他，需要进行配置，主要修改的是根目录下的 `_config.yml` 配置文件。只要配置OK，其它一切都好办。\n\n#### 遇到的问题\n\n在搭建博客我也遇到很多问题，有很多想法也试着去实现，有些成功了有些失败了。遇到一个需要注意的问题：\n\n1. 一定要详细阅读hexo主题说明，按照指导进行配置。\n2. 一定要分清楚是Hexo根目录下的 `_config.yml` 配置文件还是hexo 主题的的 `_config.yml` 配置文件。\n3. 个性化配置时，遵守一定的规范，修改一些css样式和js时一定符合规范，不要强制更改。\n4. 需要安装插件和资源包时，先查阅说明，如果遇到网络问题可以想想办法。比如使用淘宝镜像cnpm代替npm。\n\n#### 小结一下\n\n其实在使用hexo搭建博客时会遇到一些没有见过的问题，不过通过搜索引擎基本上都能解决，顺便培养一下信息检索能力。关于配置，并不是三言两语就能说清楚，通过一些教程说明，可以详细的了解很多。我自己在搭建博客时遇到的一些问题，大多都解决了，实在解决不了就换个方法尽量避免。\n\n\n\n### 3、介绍Markdown\n\n对于markdown，用两个字形容就是“好用”，写文章方便，语法简单，不需要为排版烦恼。特别是配上 Typora 编辑器，更加顺手，标题段落分明，注释超链接方便，支持代码公式块，可以导入导出。而且现在好多平台都支持markdown了。\n\n现在我已经是比较熟悉markdown在来写markdown使用方法和基本语法意义基本不大。但刚开始学那会儿不太熟悉，还是走了很多弯路。建议还是什么不会查什么，边学边记录。如果要系统的学，推荐官方使用说明：\n\n[MarkDown-语法说明](http://www.markdown.cn/) <http://www.markdown.cn/>\n\n#### 关于写文章\n\n通过hexo + github page 搭建的博客平台，支持的就是Markdown编写的博客文章。如果熟悉markdown，写文章也就没什么讲究。\n\n注意几点：\n\n1. 分清楚文章层次结构，各级标题含义清楚\n2. 正文内容要求不大，可随意发挥。\n3. 链接使用要规范，包括文字链接，图片链接。\n4. 代码公式引入最好使用块结构。\n\n总的来说，写文章要求不是很多，更需要注重的文章本身的内容。当然需要注意的是图片如果使用URL的话，选择稳定的图床，要不然可能会失效。\n\n\n\n### 总结\n\n本篇大致对使用Git，搭建博客，写文章进行了总结。但多数是一些自己的经历，觉得需要注意的点。没有涉及太多技术层面的东西，一是因为网上有很多，我不见得写的比他们详细；二是好多东西我已经掌握，再来写已经意义不大。所以引用了一些比较好参考链接，方便以后查阅学习。\n\n私以为工具很重要，只要用好工具，效率就会提升，当然能力就会提高，最后也会孰熟能生巧，做更深入的学习探讨。","tags":["Git"],"categories":["小把戏录"]},{"title":"指令周期的基本概念","url":"/2019/01/02/2019-01-02-instructions-cycle/","content":"\n\n\n最近一直在复习计算机组成原理，好多知识点都不是很清楚，PPT上写的也比较模糊，特别是讲解控制器和指令的部分，好多图演示的不太清楚。还好我发现了一篇文章，它把指令周期的基本概念和指令周期的数据流都进行了详细的讲解。我觉得写的很好，又怕自己以后不记得了，想看时找不到，所以就把它转载了。\n\n原文地址：http://media4.open.com.cn/l603/fushi/0903/jisuanjzcyl/web/lesson/char8/j2.htm?tdsourcetag=s_pctim_aiomsg\n\n\n\n## 第二节　指令周期\n\n### 一、指令周期的基本概念\n\nCPU每取出并执行一条指令所需的全部时间叫指令周期，也即CPU完成一条指令的时间叫指令周期，如下图所示。图中的取指阶段完成取指令和分析指令的操作，又叫取指周期；执行阶段完成执行指令的操作，又叫执行周期。在大多数情况下， CPU就是按取指－执行－再取指－再执行……的顺序自动工作的。\n\n![img](http://media4.open.com.cn/l603/fushi/0903/jisuanjzcyl/web/lesson/char8/image/s4.gif)\n\n由于各种指令操作功能不同，因此各种指令的指令周期是不相同的。例如无条件转移指令JMP X， 在执行阶段不需访问主存，而且操作简单，完全可以在取指阶段的后期将转移地址X送至PC， 以达到转移的目的。这样， JMP X指令的指令周期就是取指周期。又如一地址格式的加法指令ADD X，在执行阶段首先要从X所指示的存储单元中取出操作数，然后和ACC的内容相加，结果存于ACC，故这种指令的指令周期在取指和执行阶段各访问一次存储器，其指令周期就包括两个存取周期。再如乘法指令，其执行阶段所要完成的操作比加法指令多得多，故它的执行周期超过了加法指令，如下图所示。\n\n![img](http://media4.open.com.cn/l603/fushi/0903/jisuanjzcyl/web/lesson/char8/image/s5.gif)\n\n此外，当遇到间接寻址的指令时，由于指令字中只给出操作数有效地址的地址，因此，为了取出操作数，需先访问一次存储器，取出有效地址，然后再访问存储器，取出操作数。这样，间接寻址的指令周期就包括取指周期、间址周期和执行周期三个阶段，其中间址周期用于取操作数的有效地址，因此间址周期介于取指周期和执行周期之间，如下图所示。\n\n![img](http://media4.open.com.cn/l603/fushi/0903/jisuanjzcyl/web/lesson/char8/image/s6.gif)\n\n由第五章可知，当CPU采用中断方式实现主机与I/O交换信息时，CPU在每条指令执行阶段结束前， 都要发中断查询信号，以检测是否有某个I/O提出中断请求。如果有请求，CPU则要进入中断响应阶段，又称中断周期。在这阶段， CPU必须将程序断点保存到存储器中。这样，一个完整的指令周期应包括取指、间址、执行和中断4个子周期，如下图所示。由于间址周期和中断周期不一定包含在每个指令周期内，故图中用菱形框判断。\n\n![img](http://media4.open.com.cn/l603/fushi/0903/jisuanjzcyl/web/lesson/char8/image/s7.gif)\n\n总之，上述4个周期都有CPU访存操作， 只是访存的目的不同。取指周期是为了取指令，间址周期是为了取有效地址，执行周期是为了取操作数(当指令为访存指令时)，中断周期是为了保存程序断点。这4个周期又可叫CPU的工作周期，为了区别它们，在CPU内可设置4个标志触发器，如下图所示。\n\n![img](http://media4.open.com.cn/l603/fushi/0903/jisuanjzcyl/web/lesson/char8/image/s8.gif)\n\n图中的FE、IND，EX和INT分别对应取指、间址、执行和中断4个周期，并以“1”状态表示有效；它们分别由1→FE、1→IND、1→EX和1→INT4个信号控制。\n设置CPU工作周期标志触发器对设计控制单元十分有利。 例如，在取指阶段，只要设置取指周期标志触发器FE为1， 由它控制取指阶段的各个操作，便获得对任何一条指令的取指命令序列。又如在间接寻址时，间址次数可由间址周期标志触发器IND确定，当它为“0”状态时，表示间址结束。再如对于一些执行周期不访存的指令(如转移指令，寄存器类型指令)，同样可以用它们的操作码与取指周期标志触发器的状态相“与”，作为相应微操作的控制条件。\n\n\n\n### 二、指令周期的数据流\n\n为了便于分析指令周期中的数据流，假设CPU中有存储器地址寄存器MAR、存储器数据寄存器MDR、程序计数器PC和指令寄存器IR。\n\n#### 1. 取指周期的数据流\n\n![img](http://media4.open.com.cn/l603/fushi/0903/jisuanjzcyl/web/lesson/char8/image/s9.gif)\n\n上图是取指周期的数据流。PC中存放现行指令的地址，该地址送到MAR并送至地址总线， 然后由控制部件CU向存储器发出读命令，使对应MAR所指单元的内容(指令)经数据总线送至MDR，再送至IR，与此同时CU控制PC内容加1，形成下一条指令的地址。\n\n#### 2. 间址周期的数据流\n\n![img](http://media4.open.com.cn/l603/fushi/0903/jisuanjzcyl/web/lesson/char8/image/s10.gif)\n\n间址周期的数据流如上图所示。一旦取指周期结束，CU便检查IR中的内容，以确定其是否有间址操作， 如果需间址操作，则MDR中指示形式地址的右N位将被送至MAR，又送至地址总线，此后CU向存储器发读命令，并获取有效地址并存至MDR。\n\n#### 3. 执行周期的数据流\n\n由于不同的指令在执行周期的操作不同，因此执行周期的数据流是多种多样的， 可能涉及到CPU内部寄存器间的数据传送、或对存储器(或I/O)进行读写操作、或对ALU的操作，因此，无法用统一的数据流图表示。\n\n#### 4. 中断周期的数据流\n\nCPU进入中断周期要完成一系列操作， 其中PC当前的内容必须保存起来，以待执行完中断服务程序后可准确返回到该程序的间断处，这一操作的数据流如下图所示。\n\n![img](http://media4.open.com.cn/l603/fushi/0903/jisuanjzcyl/web/lesson/char8/image/s11.gif)\n\n图中由CU把用于保存程序断点的存储器特殊地址（如堆栈指针的内容）送往MAR，并送到地址总线上， 同时将PC的内容（程序断点）送到MDR，并命令存储器写，最终使程序断点经数据总线存入存储器。此外，还需将中断服务程序的入口地址送至PC，为下一个指令周期的取指周期作好准备。\n\n ","tags":["指令周期"],"categories":["计算机"]},{"title":"2019，加油","url":"/2019/01/01/2019-01-01-planning-study/","content":"\n\n\n学习计算机两年多，除了上课老师教的那些东西和强制的学业任务之外，自己也不断摸索着去了解学习一些新的东西，难免走过一些弯路。回想自己的学习之路真的是踩了许多坑，好在有一些收获。\n\n2018，让我感受最深的是我知道了自己很多不知道的东西，尝试了一些从没有尝试过的东西。说实话，我个人是比较喜欢钻研技术的，对于新鲜事物也能保持好奇心，充满求知欲，我也知道自己不太喜欢科研，更多的是匠人精神，所以希望通过自己的学习努力了解更多的技术，当然还要开阔自己眼界，提高自己的格局。\n\n2018是一些事情的开端，用一些关键来形容学习方面的话大概就是：数学模型，机器学习，图形图像，算法，FPGA，操作系统，网络，开源，区块链，数字经济等等。这些看似常识的东西，曾经却一次又一次地刷新过我的认知。我也知道，自己很多很多东西是自己不知道的，所以希望19年自己可以了解得更多。\n\n2018过得很快，自己追求的东西也逐渐具体化，因为我明白盲目的努力是没有任何意义的，所以19年可以根据按照自己的计划去努力，向着自己想要到达的地方去前行。\n\n向前有路，未来可期！2019，加油。","tags":["2019"],"categories":["随笔集"]},{"title":"Optimized C++：Proven Techniques for Heightened Performance","url":"/2018/09/07/2018-09-07-optimized-cpp/","content":"\n\n## C++性能优化指南   \n这是一篇关于C++性能优化指南的学习笔记，主要是通过阅读学习Kurt Guntheroth著的Optimized C++：Proven Techniques for Heightened Performance。 这是一本知识量和信息量很大的一本书书，书里详细介绍了影响C++程序性能的原因，也给出了很多提高性能的优化策略。   \n书中不仅讲解了软件和系统方面的相关内容，还涉及了计算机的硬件组成的基础知识，使读者可以全面的了解计算机和程序设计。书中介绍的方法是具有通用性的，可以延伸至其他的编程语言，个人认为这是一本可以提升程序设计能力、感受到优化之美的一本值得一读的好书。\n\n![book](http://wx4.sinaimg.cn/bmiddle/00709Ldkly1fyqxjdyyesj30jg0dywgx.jpg)\n-------------------\n**以下是我关于本书的学习笔记**   \n\n## Catagory\n1. [C++代码优化策略总结](#C++代码优化策略总结)\n2. [影响优化的计算机行为](#影响优化的计算机行为)\n3. [性能测量](#性能测量)\n4. [优化字符串的使用](#优化字符串的使用)\n5. [优化动态分配内存的变量](#优化动态分配内存的变量)\n6. [优化热点语句](#优化热点语句)\n7. [使用更好的库](#使用更好的库)\n8. [优化算法](#优化算法)\n9. [优化查找和排序](#优化查找和排序)\n10. [优化并发](#优化并发)\n\n---\n\n## C++代码优化策略总结\n1、用好的编译器并用好编译器（支持C++11的编译器，IntelC++（速度最快）、GNU的C++编译器GCC/G++（非常符合标准），Visual C++（性能折中），clang（最年轻Mac OS x））。    \n\n2、使用更好的算法。（绝大多数高效的程序都有高效的算法）。  \n\n3、使用更好的数据结构（不同的数据结构在使用内存管理器的方式也有所不同）。 \n\n4、使用更好的库（熟悉和掌握标准C++模板库对于进行性能优化的开发员是必须的技能，Boost Project 和 Google Code 公开了很多有用的库）。  \n\n5、减少内存分配和复制（减少对内存管理器的调用是一种非常有效的优化手段）。  \n\n6、优化内存管理（内存管理器的调度，丰富的API）。 \n\n7、提高并发性（多个处理核心执行指令）。\n\n\n## 影响优化的计算机行为 \n1、计算机的主内存是比较慢的（通往主内存的接口是限制执行速度的瓶颈（冯*诺伊曼瓶颈），（摩尔定理）每年处理器的核心的数量都会增加，但是计算机的性能未必会提高，因为这些核心只是等待访问内存的机会（内存墙memory wall））。  \n\n2、计算机内存的访问方式（并非以字节为单位），某些内存访问会比其他的更慢（分为一级高速缓存（cache memory）、二级高速缓存、三级高速缓存、主内存、磁盘上的虚拟内存页）。 \n\n3、内存的容量是有限的，每个程序都会与其他程序竞争计算机资源，计算比做决定快。  \n\n4、在处理器中，访问内存的性能开销远比其他操作的性能开销大，非对齐访问所需要的时间是所有字节都在同一字节中的两倍。  \n\n5、访问频繁使用的内存地址的速度比访问非频繁使用的地址快，访问相邻地址的内存的速度比访问相互远隔的地址的内存快。 \n\n6、访问线程间共享的数据比访问非共享的数据资源慢很多。当并发线程共享数据时，同步代码降低了并发量。  \n\n7、有些语句隐藏了大量的计算，从语句的外表上看不出语句的性能开销会有多大。\n\n\n## 性能测量\n1、90/10规则：一个程序会花费90%的运行时去执行10%的代码。   \n2、只有正确且精确的测量才是准确的测量。  \n3、分辨率不是准确性  \n4、在Windows上，clock()函数提供了可靠的毫秒级的时钟计时功能。在Windows8和之后的版本中，GetSystemTimePreciseAsfileTime()提供了亚微秒的计时功能。   \n5、计算一条C++语句对内存的读写次数，可以估算出一句C++ 语句的性能开销。\n\n\n## 优化字符串的使用\n1、由于字符串是动态分配内存的，因此他们的性能开销非常大。它们在表达式中的行为与值类似，它们的实现方式中需要大量的复制。   \n\n2、将字符串作为对象而非值可以降低内存分配和复制的频率。  \n\n3、为字符串预留内存空间可以减少内存分配的开销。 \n\n4、将指向字符串的常量引用传递给函数与传递值的结果几乎一样，但是更加高效。  \n\n5、将函数的结果通过输出参数作为引用返回给调用方会复用实参的存储空间，这可能比分配新的存储空间更加高效。  \n\n6、即使只是有时候会减少内存分配的开销，仍然是一种优化。\n\n## 优化动态分配内存的变量\n1、在C++程序中，乱用动态分配内存的变量是最大的“性能杀手”。\n\n2、C++变量（每个普通数据类型的变量；每个数组，结构体或类实例）在内存中的布局都是固定的，它们的大小在编译时就已经确定了。\n\n3、每个变量都有它的存储期（生命周期），只有在这段时间内变量所占用的存储空间或者内存字节中的值才是有意义的。为变量分配内存的开销取决于存储期（静态存储期、线性局部存储期、自动存储期、动态存储期）。\n\n4、C++变量的所有者决定了变量什么时候会被创建，什么时候会被析构（变量所有权是一个单独的概念，与存储期不同）。动态变量的所有权必须有程序员执行并编写在程序逻辑中，它不受编译器控制，也不由C++定义。具有强定义所有权的程序会比所有权分散的程序更高效。\n\n5、在C++中，动态变量是由 new 表达式创建，由 delete 表达式释放的。它们会调用C++标准库的内存管理函数。\n\n6、智能指针会通过耦合动态变量的生命周期与拥有该变量的智能指针的生命周期，来实现动态变量所有权的自动化。C++允许多个指针和引用指向同一个动态变量，共享了所有权的动态变量开销更大。\n\n7、静态的创建类成员并且在有必要时采用“两段初始化”，这样可以节省为这些成员变量分配内存的开销。\n\n8、让主指针来拥有动态变量，使用无主指针替代共享所有权。\n\n9、从性能优化的角度上看，使用指针或是引用进行赋值和参数传递，或是返回指针或引用更加高效，因为指针和引用时存储在寄存器中的。\n\n10、当一个数据结构中的元素被存储在连续的存储空间中时，我们称这个数据结构为扁平的，相比于通用指针链接在一起的数据结构，扁平数据结构具有显著的性能优势。\n\n\n\n\n## 优化热点语句\n1、除非有一些因素放大了语句的性能开销，否则不值得进行语句级别的性能优化，因为所能带来的性能提升不大。\n\n2、循环中的语句的性能开销被放大的倍数是循环的次数。函数中的语句的性能开销被放大的倍数是函数被调用的次数。被频繁地调用的编程惯用法的性能开销被放大的倍数是其被调用的次数。\n\n3、从循环中移除不变性代码（当代码不依赖于循环的归纳变量时，它就具有循环不变性），不过现代编译器非常善于找出循环中被重复计算的具有循环不变性的代码。\n\n4、从循环中移除无谓的函数调用，一次函数调用可能会执行大量指令，这是影响程序性能的一个重要因素，如果一个函数具有循环不变性，那么将它移除到循环外有助于改善性能。有一种函数永远都可以被移动到循环外部，那就是返回值只依赖于函数参数而且没有副作用的纯函数。\n\n5、从循环中移除隐含的函数调用；如果将函数签名从通过值传递实参修改为传递指向类的引用和指针，有时候可以在进行隐式函数调用时移除形参构建。\n\n6、调用函数的开销是非常小的，只是执行函数体的开销可能非常大，如果一个函数被重复调用多次则累积的开销会变得很大。函数调用的开销主要包括函数调用的基本开销、虚函数的开销、继承中的成员函数调用、函数指针的开销等。函数的调用开销虽然很大，但正因为函数调用才实现了程序的一些复杂的功能。\n\n6、调用操作系统的函数的开销是高成本的。\n\n7、内联函数是一种有效的移除函数调用开销的方法。\n\n\n\n## 使用更好的库\n1、C++为常用功能提供了一个简洁的标准库。   \n\n* 确定哪些依赖于实现的行为，如每种数据类型的最大值和最小值。   \n* 易于使用但是编写和验证都很繁琐的可移植的超越函数（超越函数指的是变量之间的关系不能用有限次加、减、乘、除、乘方、开方运算表示的函数），如正弦函数和余弦函数、对数函数和幂函数、随机数函数等等。   \n* 除了内存分配外，不依赖于操作系统的可移植的通用数据结构、如字符串、链表和表。   \n* 可移植的通用数据查找算法、数据排序算法和数据转换算法。  \n* 以一种独立于操作系统的方式与操作系统的基础服务相联系的执行内存分配、操作线程、管理和维护时间以及流I/O等任务的函数。  \n\n2、使用C++标准库的注意事项   \n\n* 标准库的实现中有bug，(标准库和编译器是单独维护的，编译器中也可能存在bug，标准需求的改变、责任的分散、计划问题以及标准库的复杂度都会不可避免地影响它们的质量)。   \n* 标准库的实现可能不符合C++标准，（库的发布计划和编译器是不同的，而编译器的发布计划与与C++标准不同，一个标准库的实现可能会领先或是落后于编译器）。   \n* 对于标准库开发人员来说，性能并非是最终要的事情，（因为库会被长期使用，所以库的简单性和可维护性更加重要）。  \n* 库的实现可能会让一些优化手段失效，C++标准库中的有些部分并非是有用的。  \n* 标准库不如最好的原生函数，（标准库没有为某些操作系统提供异步文件I/O等特性，性能优化人员只能通过调用原生函数，牺牲可移植性来换取运行速度）。\n\n\n3、C++标准库之所以提供这些函数和类，是因为要么无法以其他方式提供这些函数和类，要么这些函数和类被广泛地用于多种操作系统上。在对库进行性能优化时，测试用例非常关键；接口的稳定性是可交付的库的核心。   \n\n4、扁平继承层次关系（多数抽象都不会有超高三层类继承层次，一旦超高三次可能表明类的层次结构不够清晰，其引入的复杂性会导致性能的下降）。\n扁平调用链（绝大多数抽象的实现都不会超高三层嵌套函数的调用，在已经充分解耦的库中是不会包含冗长的嵌套抽象调用链的）。    \n\n\n## 优化算法  \n1、高效的算法是计算机科学一直研究的主题，计算机科学家十分重视算法和数据结构的研究，因为它是展示优化代码的典型事例。当一个程序需要数秒内执行完毕，实际上却要花费数小时时，唯一可以用成功的优化方法可能就是选择一种高效的算法了。算法是一个非常重要且不能简而概之的主题，可以参考《算法导论》，进行更深入的学习。   \n![book](http://wx4.sinaimg.cn/bmiddle/00709Ldkly1fyqxjeewsaj30eb0jm75z.jpg)\n\n2、优化模式\n开发人员研究算法和数据结构的原因之一是其中蕴含着用于改善性能的“思维库”，这些改善性能的通用技巧是非常的使用的，其中的一些模式也是数据结构、C++语言特性和硬件创新的核心。  \n\n* 预计算；可以在程序早期，通过在热点代码前执行执行计算来将计算从热点部分中移除。\n* 延迟计算；通过在正真需要执行计算时才执行计算，可将计算从某些代码路径上移除。\n* 批量处理；每次对多个元素一起进行计算，而不是一次只对一个元素进行计算。\n* 缓存；通过保存和复用高代价计算的结果来减少计算量，而不是重复进行计算。\n* 特化；通过移除未使用的共性来减少计算量。\n* 提高处理量；通过一次处理一大组数据来减少循环处理的开销。\n* 提示；通过在代码中加入可能会改善性能的提示来减少计算量。\n* 优化期待路径；以期待频率从高到低的顺序对输入数据或是运行时发生的事件进行测试。\n* 散列法；计算可变成字符串等大型数据结构的压缩数值映射（散列值）。在进行比较时，用散列代替数据结构可以提高性能。\n* 双重检查；通过先进行一项开销不大的检查，然后只在必要时才进行另外一项开销昂贵的检查来减少计算量。 \n\n\n## 优化查找和排序\n1、改善查找性能的工具箱，测量当前的实现方式的性能来得到比较基准，识别出待优化的抽象活动，将待优化的活动分解为组件算法和数据结构，修改或是替换那些可能并非最优的算法和数据结构，然后进行性能测试以确定修改是否有效果。\n\n2、标准库查找算法接受两个迭代器参数：一个指向待查找序列的开始位置，另一个则指向待查找序列的末尾位置（最后一个元素的下一个位置）。所有的算法还都接受一个要查找的键作为参数以及一个可选的比较函数参数。\n\n3、使用C++标准库优化排序，在能够使用分而治之算法高效地进行查找之前，我们必须先对序列容器排序，C++标准库提供了两种能够高效地对序列容器进行排序的标准算法——`std::sort()` 和 `std::stable_sort()`。\n\n\n\n## 优化并发\n1、并发是多线程控制的同步执行，并发的目标不是减少指令执行的次数或是每秒访问数据的次数，而是通过提高计算资源的使用率来减少程序运行的时间的。\n\n2、有很多机制能够为程序提供并发，其中有些基于操作系统或是硬件。C++标准库直接支持线程共享内存的并发模型。\n\n3、计算机硬件、操作系统、函数库以及C++自身的特性都能够为程序提供并发支持。  \n\n* 时间分隔；这是操作系统的一个调度函数，为每个程序都分配时间块。操作系统是依赖于处理器和硬件的。它会使用计时器和周期性的中断来调整处理器的调度。\n* 虚拟化；虚拟化技术是让操作系统将处理器的时间块分配给客户虚拟机，计算资源能够根据每台客户虚拟机上正在运行的程序的需求进行分配。\n* 容器化；容器中包含了程序在检查点的文件系统镜像和内存镜像，其主机是一个操作系统，能够直接提供I/O和系统资源。\n* 对称式多处理；是一种包含若干执行相同机器代码并访问相同物理内存的执行单元的计算机，现代多核处理器都是对称式多处理器。使用正真的硬件并发执行多线程控制。\n* 同步多线程；有些处理器的硬件核心有两个或多个寄存器集，可以相应地执行两条或多条指令流。最高效第使用软件线程的方法是让软件线程数量与硬件线程数量匹配。\n* 多进程；进程是并发的执行流，这些执行流有它们自己的受保护的虚拟内存空间，进程之间通过管道、队列、网路I/O或是其他不共享的机制进行通信，进程的主要优点是操作系统会隔离各个进程，使其不会互相干扰影响。\n* 分布式处理；是指程序活动分布在一组处理器上，这些处理器可以不同。分布式处理系统通常会被分解为子系统，形成模块化的，易于理解的和能够重新配置的体系结构。\n* 线程；线程是进程中的并发执行流，它们之间共享内存；与进程相比，线程的优点在于消耗的资源更少、创建和切换也更快。由于进程中的所有线程都共享相同的内存空间，所以一个线程写入无效的内存地址可能会覆盖掉其他线程的数据结构，导致线程奔溃或是出现不可预测的情况。\n* 任务；任务是一个独立线程的上下文中能够被异步调用的执行单元，任务运行的基础是线性池。基于任务的并发构建于线程之上，因此任务也具有线程的优点和缺点。\n\n4、如果没有竞争，那么一个多线程C++程序具有顺序一致性，理想的竞争一块短临界区的核心数量是两个。在临界区中执行I/O操作无法优化性能，可运行线程的数量应当少于或等于处理器核心数量。\n","tags":["C++","notes"],"categories":["学习笔记"]},{"title":"2018中国国际智能产业博览会","url":"/2018/08/25/2018-08-25-chongqing-sce/","content":"\n\n## 2018中国国际智能产业博览会\n### 1.博览会概况   \n坐标：重庆   \n主题：智能化：为经济赋能，为生活添彩！   \n形式：“会、展、赛、系列活动”\n\n### 2.个人经历和感想   \n我很荣幸能够作为志愿者参与到这次智博会的活动中，能够更加直观的体验到智博会。能够近距离的接触到一些高端会议、旁听到一些技术论坛、亲身体验到一些高科技产品，对于我个人是一次难得而又难忘的体验。在这次活动中，自己也有一些所思所感，借此记录分享一下。   \n\n首先是志愿服务方面，我从来没有参加过这样类似的志愿活动，平时主要是一些爱心公益，而这次不同，不但活动规格高，标准严，对于志愿者的选拨也都是仔细考核、认真挑选，所以很荣幸能够入选成为其中一员。为了活动的顺利举办，志愿服务更加到位，专门组织了长达一周的培训，从理论教学到场地彩排，为的就是办好这次智博会。经过培训，我自己的志愿服务水平得到很大的提高，礼貌礼仪、突发事件应急处置、应急救护常识、会务英语等这些方面的能力都得到很大提高，对于我个人而言是受益匪浅的。   \n\n第二是对大数据智能化时代的认知，这次活动开阔了我的眼界，能够近距离接触高端论坛，听专家学者院士做报告，听企业家阐述他们对智能化的认知，听大企业的未来行业发展规划。在这个互联网产业，数字经济的时代，机遇与挑战并存，我们这代人需要不断的学习新的知识，了解新的产物，才能不被这个社会淘汰。数字经济，大数据人工智能，云计算服务将是社会发展的动力，也是经济发展的动力。科技创新是提高国家综合国力的要素，商业模式的创新是满足社会需求，提高人们生活的水平的一大动力，也是企业生存发展的基本要素。总之，面对大数据智能化时代，对于社会个人能力显得尤为重要。   \n\n第三是对于科技产品的体验，智能化为生活添彩；科技给生活带来的改变体现到衣食住行方方面面，参观到许多大企业的科技产品，许多科技单位的研究成果，让人耳目一新；智能设备的智能体验成为了新的需求，有需求就会有产品，产品最终转化为利益和服务体验，这就是现代和未来的生活。好多高科技产品呈现在我的面前，有时候还不敢相信一个不可思议的idea竟成为现实。这次的科技体验，让我对未来生活有了新的憧憬。   \n\n最后，这次智博会对于重庆而言是相当有意义的，给重庆的经济发展注入新的动力，将人们的生活水平和生活质量。希望重庆发展得越来越好!   \n![sce](http://wx1.sinaimg.cn/large/00709Ldkly1fyqxjf04euj30qo0k075m.jpg)\n","tags":["智博会"],"categories":["分享"]},{"title":"计算机导论——计算机入门篇","url":"/2018/07/11/2018-07-11-computer-introduction/","content":"\n\n## 第一章 \n### 1、计算机系统的层次\n硬件层：包括计算机的各个部分，控制器，运算器（CPU）、存储器、输入设备和输出设备。  \n\n软件层：包括由汇编及高级语言等开发出来的应用程序。  \n\n操作系统层（OS）：是连接硬件和软件的中间桥梁，它由机器指令和广义指令组成。  \n\n>. 机器指令：指的是CPU能够直接识别并执行的指令；  \n>. 广义指令：是指系统定义和解释的软件指令;\n\n### 2、高级语言与汇编语言的区别\n汇编语言是一种功能很强的程序设计语言，也是利用计算机所有硬件特性并能直接控制硬件的语言。它是面向机器的程序设计语言；  \n\n高级语言是相对于汇编语言而言的，它是较接近自然语言数学公式的编程，基本脱离了机器的硬件系统，用人们更易理解的方式编写程序；包括很多种编程语言——常见的高级语言有：C语言、C++、VB、JAVA、C#等等  \n常用语句：表达式语句、函数调用语句、控制结构语句（for语句、while语句、if语句）。   \n\n\n### 3、解释性语言和编译型语言的区别和各自的特点\n**编译型语言：**用编译型语言写的程序执行之前需要一个专门的编译过程，通过编译系统（不仅仅是通过编译器，编译器只是编译系统的一部分）把高级语言翻译成机器语言，把源高级程序编译成机器语言文件，如Windows下的exe文件。以后就可以直接运行不需要编译；编译型语言有C/C++、Pascal/Object Pascal （Delphi）等。  \n\n**解释型语言：**用解释型语言编写的程序不需要编译。解释型语言在运行的时候才翻译，比如VB语言在执行的时候专门有一个解释器能够将VB语言翻译成机器语言，每一个语句都是执行的时候翻译。这样解释型语言每执行一次就要翻译一次，效率比较低；（但解释器能够在运行时动态优化代码）；解释型语言有JavaScript、VBScript、Perl、Python、Ruby、MATLAB。  \n\n**JAVA**是一种编译型-解释型语言；同时具备编译特性和解释特性（其实确切的说JAVA就是解释型语言，其所谓的编译过程只是将.Java文件编译成平台无关的字节代码.class文件，并不是C一样编译成可以执行机器语言）；  \n\n**Python**是一种面向对象、解释型计算机程序设计语言；Python语法简洁而清晰，具有丰富和强大的类库。（由Guido van Rossum于1989年底发明，第一个公开版发行于1991年）。  \n\n\n### 4、历代计算机的发展阶段和每个阶段的特点\n两类计算机：  \n1、通用型计算机(general purpose computers);  \n2、专用型计算机(special purpose computers);\n\n四代计算机：  \n第一代计算机所经历的时间为1946到1958年。处于这一时代的计算机的共同特点：体积较大；运算速度较低；存储容量不大；而且价格昂贵；使用也不方便。解决一个简单问题所编写的程序的复杂程度也难以表述。这一代计算机只在重要机构或科学领域研究部门使用，主要用于科学计算。   \n\n第二代计算机所经历的时间为1958年至1965年。这一时代的计算机全部采用晶体管作为电子器件，其运算速度比第一代计算机的提高了近百倍，体积为原来的几十分之一。在软件方面，开始使用计算机算法语言。这一代计算机不仅用于科学计算，还用于数据处理和事务处理及工业控制。   \n\n第三代计算机所经历的时间为1965年至1970年。这一时期的计算机的主要特征是以中、小规模集成电路为电子器件。一个重大突破是计算机出现了操作系统，计算机的功能越来越强，应用范围越来越广。它们不仅用于科学计算，还用于文字处理、企业管理、自动控制等事务。与此同时，还出现了计算机技术与通信技术相结合的信息管理系统，可用在市场管理、情报检索等领域。   \n\n第四代计算机是指1970以后采用大规模集成电路（LSI）和超大规模集成电路（VLSL）为主要电子器件制成的计算机。例如80386微处理器，面积约10mm*10mm的单个芯片上，可以集成大约32万个晶体管。第四代计算机的另一个重大分支是以大规模、超大规模集成电路为基础发展起来的微处理器和微计算机。\n\n \n\n## 第二章  计算与存储\n### 1、进制的概念\n二进制（二进制的一位称为一比特bit，把连续的八个比特称为一个字节）、八进制、十进制、十六进制；  \n基数和位权: 如果某一个进制采用R个基本符号，我们就称它为基R进制，R称为进制的‘基数’(base);进制中每一位的单位值称为‘位权’（weight）。  \n\n### 2、计算机为什么采用二进制\n1. 技术实现简单：计算机是逻辑电路，逻辑电路通常只有两种状态，开关的接通和断开，这两种状态正好用‘1’和‘0’表示。  \n2. 简化运算规则：两个二进制数和、积运算组合各有三种，运算规则简单，有利于简化计算机内部结构，提高运算速度\n3. 适合逻辑运算：逻辑代数是逻辑运算的理论依据，二进制只有两个数码，正好与逻辑代数中的“真”和“假”相吻合。\n4. 易于进行转转：二进制与十进制数易于相互转换。\n5. 用二进制表示的数据具有抗干扰能力强，可靠性高等优点。因为每位数据只有高低两种状态，当受到一定程度的干扰时，仍能可靠地分辨出它是高是低。   \n\n### 3、不同进制的快速转换\n以十进制为中间流转(‘除R取余法’、‘乘R取整法’)；R进制数转换为十进制数时，将各位数与它的位权乘积相累加；  \n\n十进制整数转换为R进制整数：可用十进制整数连续地除以R，每次除法获得的余数即为相应R进制数一位，最后按逆序输出结果。“除R取整法”；  \n十进制小数转换成R进制小数：可用十进制的小数连续地乘以R，用得到的整数部分组成R进制的小数，最后按顺序输出结果。“乘R取整法”；\n\n对于二进制数和八进制数、十六进制数之间的转换，有简便快速的“三位一并”和“四位一并法”。\n\n\n### 4、浮点数的表示方法\n在计算机中整数以外的其他数（带小数的数）被称为浮点数；   \n浮点运算的规则和整数的运算规则相同；   \n计算机使用类似科学记数的方法表示浮点数，包括指数e和尾数m以及带符号数的符号位；  \n二进制浮点数1.011×2^010在计算机中存为：  \n![img1](http://wx4.sinaimg.cn/large/00709Ldkly1fw4j8v1slej30b002mjr6.jpg)\n\n### 5、逻辑运算\n基本运算是由0和1的逻辑运算衍生而来;\n>. 真—假—>1-0  \n>. “与（AND）”、“或（OR）”、“非（NOT）”\n\n### 6、存储设备的类型和各种存储设备的特点\n计算机内部，各种信息都是以二进制编码的形式存储的。   \n计算机普通把单位信息分成以下三种：\n位（bit）、字节（Byte）、字（Word）（字是字节的组合；字长是32位（4个字节））;  \n常用单位：bit、B（Byte）、KB、MB、GB、TB、PB、EB.  \n\n符号的编码方式：ASCII码（美国信息交换标准码）、GBK字符集（国家标准扩展字符集）、统一字符编码Unicode。  \n\n存储设备：存放0和1组成的二进制信息的物理载体称为存储介质，存储介质加上配套电路等组件组成存储设备。  \n现在计算机常用的存储设备：  \n1. 寄存器（Register）  \n2. 高速缓存（Cache）  \n3. 内存（Main memory）  \n4. 外存（Storage）  \n5. 显存\n\n![img2](http://wx1.sinaimg.cn/large/00709Ldkly1fw4j8vnenxj30jr0f4aex.jpg)\n\n\n图示是目前计算机系统最基础的存储层次\n>.速度越快价格越高容量越小，离CPU越近;  \n>.速度越慢价格越低容量越大，离CPU越远\n\n计算机常见的存储介质：SRAM、DRAM（断电丢失保存信息）、磁盘、闪存。   \n**注：**RAM随机访问内存，这种存储器在断电时将丢失存储内容；ROM即只读内存，是一种能读出事先所存数据的固态半导体存储器。\n\n\n\n## 第三章  指令与函数\n\n### 1、CPU的组成  \n计算机两个核心部件分别是CPU（运算）和主存（存储）；   \nCPU的核心部件：程序计数器（PC）、指令寄存器（IR）、算术逻辑单元（ALU）。\n\n### 2、常用汇编指令的功能及功能指令格式\n汇编指令有“操作码”和“操作数”组成，操作码是指令执行的基本动作。   \n格式：load R1，（address）    \n注：address是内存地址，（address）表示这个地址内存储的值；\n>“R赋值”操作——mov指令；  \n>加法指令——add；  \n减法指令——sub；  \n左位移指令——shiftl；  \n右位移指令——shiftr；  \n“将R存回a的操作”——store指令；  \n\n控制结构的执行（if-else选择语句；分支跳转指令；while循环语句；for循环语句）；\n\n分支跳转：  \n比较x是否小于y——slt指令；格式：slt R4，R1，R2   \n“判断小于后等于”——sle指令;  \n“选择跳转到语句块”——beqz指令；\nbeqz R4，label2（如果R4为零则跳转到label2标记的指令块）。  \n“直接跳转到语句块”操作——goto指令；\n\n\n### 4、函数调用的调用过程\n程序语言中的函数和数学中的函数基本概念是相似的。程序语言中的函数也有参数，返回值，以及定义与调用。程序中的函数，就是将一些程序语句结合在一起的邮件，通过多次调用，函数可以不止一次的在程序中运行。   \n\n函数调用的好处：1.将大问题分成许多小问题；2.便于检测错误；3.实现封装和重用；4.便于维护。   \n\n函数调用的特点：（越早被调用的函数，越晚被返回）；因为程序在执行过程是是根据指令寄存器里的指令依次执行（除函数调用，调用后的返回以及控制结构），每次函数调用都有一个返回值，然后程序继续执行。   \n\n栈：栈是一种非常重要的数据结构，它按照先进后出的原则存储数据，即先进入的数据被压入栈底，最后的数据在栈顶，需要取数据的时候从栈顶开始弹出数据。所以它的特色是“先进后出”和“后进先出”；（只能从一端放数据和取数据）； \n\n\n\n\n## 第四章  编程与python初识\n### 1、Python优点\n软件质量高；提高开发效率；程序可一致性强；标准库的支持。  \n\n### 2、LIST STRING DICTIONARY三种内置数据结构的使用。\n数据类型结构图：    \n![img3](http://wx2.sinaimg.cn/large/00709Ldkly1fw4j8w2651j30ky0d10t5.jpg)   \n\n\n**列表（list）：***不同于数组，列表的元素类型可以是不一样的，（可以是整型，浮点型，字符串，还可以是列表）；序列的通用操作主要包括：索引、分片、链接（加）、重复（乘）；以及检查某个元素是否属于序列。 遍历，即要依次对列表中的所有元素进行访问（操作），对列表这种线性数据结构最自然的遍历方式是循环。 \n\n**字符串（string）：**同列表一样，字符串也实现了序列的通用操作和函数。但是字符串的内容是不可改变的；字符串对某一个索引所在位置进行赋值是不允许的。（字符串与数值型相互转化、字符串转化为列表）。   \n\n**字典（dictionary）：**字典是Python中唯一的映射类型。字典中的每一个元素都是一个键值对（Key：Value），而Key在字典中只会出现一次，也就是大家知道函数是不可以有一对多的映射关系。键key是集合X中的一个元素，而Value指的是集合Y中的一个元素，如f（key）=value；   \n\nPython字典是符合数据库数据表格的概念，它能够表示基于关系模型的数据库，即关系数据库。而现在主流的数据库Oracle、db2、sqlserver、svbase、mysql等都是关系数据库。  \n\n\n### 3、基本赋值语句和增强赋值语句的使用\n基本形式的赋值语句就是”变量X=值”；\n>.序列赋值；扩张序列赋值；多目标赋值；增强赋值语句（从C语言借鉴）。\n\n### 4、三种控制机构的熟练掌握\n1. if语句（elif）严格以缩进区别语块；  \n**注：**缩进反映代码逻辑性，缩进可由任意的空格和制表符组成，同一个语句块的缩进必须保持一致。一般来说，缩进的距离为4个空格键或者一个制表符。但是要注意，在同一段代码中，混合使用制表符和空格并不是·一个好习惯。因为不同的编辑器对制表符和空格混用的处理方式并不同，为了避免出错，最好采用同一形式的缩进。   \n\n2. While循环语句：（判读bool，continue语句，break语句）；  \n**注：**while循环语句也有else语句，只不过else一定要和while的break相结合考虑才有意义。  \n\n\n3. For循环语句：for循环通常用来遍历有序的序列对象内的元素。For循环语句——range函数的应用（Python的range函数通常用来生产整数列表）。\n\n\n### 5、函数调用过程的参数传递和变量使用\nPython进行函数调用时，参数的传递都是通过赋值的方式。Python中的数据结构有两种类型：可变类型与不可变类型。  \n可变类型有列表，字典等，而不可变类型有数字、字符串等。  \n对参数的修改会影响到可变类型的数据结构，而不会影响到不可变类型的数据结构。（列表做参数是传递指针指向堆heap）。  \n\n### 6、面向对象和面向对象编程的定义和特点\n面向过程是一种以事件为中心的编程思想：就是把解决问题的步骤写出了，程序一步一步的执行就能解决问题。   \n面向对象是一种以事物为中心的编程思想：会把问题的相关数据提取出来，将具有相同属性的物体抽象为类，并给类设计相应的方法。程序执行时，通常就是创建这个类的一个对象，调用这个类的方法，就可以解决问题。   \n\n注：相比面向过程语言，面向对象编程有更好的扩展性，思维方式更加自然（封装，继承，多态，重用）。\n\n### 7、类的定义和实例化\n类——对象：使用类生成对象的过程，叫做实例化。一个类可以包含多个已定义类型的变量，这些变量称为成员变量（也称属性），同时，还可以包含多个有该类实例化对象所使用的函数，这些函数称为成员函数。\n\n\n\n## 第五章 算法思想\n\n### 1、算法的五个重要特点\n1. 有限的运行步骤；\n2. 具有确定的执行步骤；\n3. 具有输入项；\n4. 具有输出项；\n5. 对于计算机系统的可行性；\n\n### 2、常用的算法思想\n点击查看 [常用算法的思想](https://smallseven.top/2018/07/08/algorithm-summary/)\n\n\n\n## 第六章 简单了解操作系统\n### 常见操作系统  \n生活中常见的操作系统有微软的Windows系列产品，Ubuntu、Fedora等Linux系统，苹果Mac OS系列产品，以及智能手机所使用的Android、IOS系统等等。   \n\n1. 计算机操作系统：诞生CP/M；远古霸主DOS；当代大亨Windows；诱人的小企鹅Linux；神奇的精灵FreeBSD（Unix）；多才多艺的艺术大师BeOS。\n2. 手机操作系统：Symbian（塞班）NOKIA、Linux（Android）、palm OS（Plam公司开发嵌入式操作系统）、BlackBerry（黑莓）、Windowsmobile，iOS（iPhone、iPodtouch、iPad）；   \n3. 基于Android的二次开发：Sense（HTC）、LG Optimus（LG）、CyanogenMod、小米MIUI（小米）、Emotion UI（华为）、Blur（摩托罗拉）、Flyme OS （魅族）、中国移动OMS   \n4. Brew（CDMA高通公司开发的封闭式系统）、HP webOS、MeeGo（诺基亚和英特尔）、Firefox OS（谋智公司）、BADA系统（韩国三星电子）、Tizen（英特尔MeeGo系统和三星LiMo系统的混合体）、Ubuntu手机操作系统（开发商canonical）。\n\n\n**操作系统的主要职能：**  \n1、管理文件系统，管理各种硬件资源，例如U盘、网盘、键盘等。  \n2、管理程序共享的资源，例如CPU、主存等（一个计算机系统会有多个程序同时在执行或等待执行）。  \n3、管理和调度多个程序的执行；  \n4、提供程序和硬件的衔接，提供各种系统的服务和接口；  \n5、设法维护系统的安全，尽量防止病毒（恶意软件）有意或无意的入侵；\n\n### 2、计算机的启动过程\n1. 启动自检阶段\n2. 初始化启动阶段\n3. 启动加载阶段\n4. 内核转载阶段\n5. 登录阶段  \n\n**注：**无论是台式机、笔记本、手机、所有设备开机启动过程中都会包括三个共同的阶段：启动自检阶段、初始化启动阶段、启动加载阶段；   \n这三个阶段主要由BIOS（Basic Input Output System）来完成的。BIOS是一组程序，包括基本输入输出程序，系统设置信息，开机后自检程序和系统自启动程序。  \n\n### 3、操作系统对硬件资源的管理\n操作系统管理计算机资源，是软件和硬件的中间接口。  \nCPU通常使用轮询和硬件中断两种方式检测设备的工作状态。 \n> I/O设备  CPU ：硬件中断  \n> 存储设备：异常\n\n\n### 4、操作系统对应用程序的服务：软件中断\n操作系统中设置了一组用于实现系统功能的子程序，称为系统调用函数（运行于内核态）。\n\n常用的系统的调用： \n1. 进程控制，如：fork（），exit（）等;  \n2. 文件系统操作控制，如：read（）、write（）等;  \n3. 系统控制，如：ioctl（）、time（）等;  \n4. 内存管理，如mmap（）、mprotect（）等;  \n5. 网络管理控制，如：sethostname（）、soket（）、bind（）等 ; \n6. 用户管理，如：getuid（），getgid（）等;  \n7. 进程间通信，如：signal（），kill（）等;  \n\n**(1)软件开发者如何统一的使用硬件资源？**  \n为了统一的使用硬件资源，软件开发者通过操作系统提供的用户接口程序，进入内核模式使用操作系统提供的服务来使用资源。也就是说，不论是QQ程序，或是Office程序，例如要读取一个文件的内容时，都可以调用read系统调用。这种统一接口的实现方式有利于开发者进行快速开发。只要开发者熟悉了操作系统所提供的系统调用后，便可进行不同上层软件的开发。   \n\n**(2)操作系统如何为硬件系统提供安全保证？**  \n对于硬件系统安全保证，则是因为控制硬件的底层程序均由操作系统提供，用户有理由相信操作系统不会做毁坏自己的事。所以，系统一旦进入内核态，就处于安全的状态。而上层应用软件运行自身代码段（非系统调用函数）时，不能切换到内核态，所以，程序无法通过自身代码段攻击下层硬件。\n\n\n### 5、进程的组成部分及状态转换图\n1. 一个进程包含了代码段、数据段、栈、堆、BSS段以及进程控制块等部分。  \n2. 代码段（Code segment/Text segment）通常是指用来存放程序执行代码的一块内存区域。  \n3. 数据段（Data segment）通常是指用来存放程序中已经初始化的全局变量的一块内存区域。  \n4. 栈（Stack）是用户存放程序临时创建的局部变量区域。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且等到函数调用结束后，函数的返回值也会被存放回栈中。由于栈这种数据结构具有先进后出特点，所以栈能够特别方便用于保存/恢复调用现场。  \n5. 堆（Heap）是用于存放进程运行中动态分配的内存段，它的大小并不固定，可根据进程运行的需要动态扩张或缩减。例如所有的类对象（objects）是存放在这个区域的。  \n6. BSS段（Block Started by Symbol）通常是指用来存放程序中未初始化的全局变量的一块内存区域。  \n7. 另外，操作系统为了统一管理进程，专门设置了一个数据结构，即进程控制块（Process Control Block，PCB），用来记录进程的特征信息，描述进程运动变化的过程。PCB是操作系统感知进程存在的唯一标识，进程与PCB是一一对应的。  \n![img4](http://wx3.sinaimg.cn/large/00709Ldkly1fw4j8wid9ij30he07i74s.jpg)  \n\n\n### 6、进程调度的常用策略及性能衡量指标\n**性能衡量指标：**  \n1. 周转时间（进程首次进入就绪队列到完成的时间间隔，刻画了用户需要等待输出结果的时间）。  \n2. 吞吐量（系统单位时间内完成任务的数量）。  \n\n**常用策略：** 先来先服务（FCFS）、短作业优先（SJF）。  \n\n\n### 7、目录树形结构，相对路径，绝对路径\n文件基本概念：文件命名、文件类型（普通文件、目录文件、块设备文件、字符设备文件）。\n\n目录树结构：  \n![img5](http://wx1.sinaimg.cn/large/00709Ldkly1fw4j8x2in7j30pk0c040d.jpg)  \n\n\n\n## 第七章 计算机相关\n\n### 1、大数据的四大特点\n**数据：**在计算机科学中，数据是指所有能输入到计算机并被计算机程序处理的，具有一点意义的数字、字母、符号和模拟量等通称。  \n**数据处理：**是对数据的采集、存储、检索、加工、变换和传输。\n\n**大数据：**大数据是一个广泛的概念，大数据的核心能力是发现规律和预测未来。  \n【高级数据公司IDC】 海量的数据规模（Volume）、快速的数据流转和动态的数据体系（Velovity）、多样的数据类型（Variety）、巨大的数据价值（Value）。  \n【亚马逊大数据科学家】 大数据是任何超过一台计算机处理能力的数据量。   \n【维基百科】 大数据（big data）指的是所涉及的资料量规模巨大到无法通过目前主流软件工具，在合理的时间内达到撷取、管理、处理并整理成帮助企业经营决策更积极目的的资讯。 \n\n\n","tags":["computer"],"categories":["学习笔记"]},{"title":"Algorithm thought","url":"/2018/07/08/2018-07-08-algorithm-summary/","content":"\n\n>* 算法在计算机的学习过程中是非常重要的，多对于一些常用的算法我们应该了解它的算法思想，所以，在此对一些常用算法思想做一个概念上的简单总结\n\n\n## 递归的基本概念\n\n一般来说，递归是一个过程或函数在它的定义或说明中又直接或间接调用它自己的一种方法。\n\n递归本质是把一个复杂的大问题层层转化为一个与原问题相似的小问题，利用小问题的解来构筑大问题的解。学习用递归解决问题的关键就是找到问题的递归式，有了递归式就可以知道大问题与小问题之间的关系，从而解决问题了。\n\n递归只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。它的能力在于用有限的语句来定义无限集合。正是如此，递归才能用很少的代码解决很复杂的问题。然而在使用递归解决问题时要特别注意，一定要有一个明确的递归结束条件，否则就会陷入无限循环中。例如在解决汉诺塔问题时，递归结束条件就是n=1。只要判断n=1，就停止继续调用Hanoi，开始返回值。\n\n习惯递归的思想后，可以在很短的时间里写出正确的程序。写递归程序的诀窍就是：（1）怎么分，怎么合；（2）怎么终止。\n\n>（平面划分问题，汉诺塔问题）\n\n## 分治法的基本思想\n\n分治法是我们计算机科学解决问题的一种基本方法。从字面上来理解就是是“分而治之”。它的基本思想是把一个复杂的问题分成两个或更多的相同或相似的互相独立的子问题，再把子问题分成更小的子问题，直到最后的子问题可以简单的直接求解，然后将这些子问题的解合并从而构造出原问题的解。而用分治法求解问题的时候，通常会用到递归的思想来求解子问题。\n\n>（找假币的例子）\n\n\n## 分治法与递归的联系与区别\n\n其实在我们用分治法解题时，往往能会用到递归的思想。分治法产生的子问题往往是原问题的较小模式，反复应用分治法，可以使子问题与原问题的类型保持一致，而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解，这就为使用递归提供了方便。在分治法中用递归的思想求解问题是计算机科学解决问题时常有的一种手段，由此也产生了很多高效的算法。\n\n \n\n## 贪心算法的基本概念\n\n贪心算法，又被称为贪婪算法，也是用来求解最优化问题的一种方法。一般来说，求解最优化问题的过程就是做一系列决定从而实现最优值的过程。最优解就是实现最优值的这些决定。动态规划考虑全局最优，得到的解一定是最优解。贪心算法是一种在每一步选择中都采取当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。贪心算法考虑局部最优，每次都做当前看起来最优的决定，得到的解不一定是全局最优解。但是在有最优子结构的问题中，贪心算法能够得到最优解。最优子结构就是局部最优解能决定全局最优解。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。虽然对于很多问题贪心算法不一定能得到最优解，但是它的效率高，所求得的答案比较接近最优结果。因此，贪心算法可以用作辅助算法或者直接解决一些要求结果不特别精确的问题。\n\n>（找零钱问题）\n\n \n\n## 动态规划的基本概念\n\n动态规划是求解最优化问题的一种方法。通常这种问题有很多解，每个解都对应一个值，最优化问题是希望找到一个对应最优值（最大值或最小值）的解。动态规划与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的，即子问题之间具有重叠的部分。在这种情况下，如果用分治法求解就会重复的求解这些重叠的部分。而动态规划只会对这些重叠的部分求解一次并用表格保存这些解，如此一来就可以避免大量的重复计算。动态规划最特别的地方是自底向上的求解子问题并将这些子问题的解保存起来。这种用空间换取时间的方式大大提高了求解问题的效率。\n\n>（求最优解，最长增长子数列，背包问题）\n\n## 动态规划求解问题的4个步骤\n\n动态规划求解问题一般可以分为4个步骤：\n\n1. 定义最优解的结构。\n2. 递归的定义最优解的值。\n3. 以自底向上的方式计算最优解的值。\n4. 用第（3）步中计算过程的信息构造最优解。\n","tags":["Algorithm"],"categories":["学习笔记"]},{"title":"（转）给新手程序员的一封信","url":"/2018/07/07/2018-07-07-letter-relay/","content":"\n\n## 给新手程序员的一封信 \n\n欢迎来到程序员的世界。在这个世界上，不是有很多人想创造软件并解决问题。你是一名hacker，属于那些愿意做一些有挑战性的事情的人。\n\n>“当你不创造东西时，你只会根据自己的感觉而不是能力去看待问题。” ——WhyTheLuckyStiff\n\n对于下面的文字你不必完全接受，所有这些来自一个其貌不扬的程序员。我喜欢把事情做到最好，而不是对原来的东西修修补补。\n\n仅仅是因为爱好开始做一些创新，这是一个很好的开始！如果你说“我要先学习一下再开始做”那么你永远不会真正开始。每个人都需要从某个地方开始，所以现在打开你的编辑器开始写代码吧。\n\n下面是一些很重要的建议，虽然有人并不认同，但我保证你看完我的分析以后会站在我这一边。一开始，先不要管算法和数据结构。大多数简单的程序不需要用到算法和数据结构，所以当你真正需要时再去学习。编程一段时间以后，你就会知道在哪些地方用到他们。这时知道算法的名字并了解它们的功能，然后找一些相关的论文去理解算法并动手编程实践。如果没有现成的函数库（其他程序员提供的可重用代码），你用自己喜欢的编程语言来实现它。\n\n1. 选择一门好的编程语言，一门你自认为可以用它快速地做出一些有用东西的语言。\n\n不要选择C语言作为你第一门编程语言。也许选择C语言会给你一种过时的满足感。虽然它比早期的汇编语言提供了更好语法描述，但是今天C（或者C++）不是能够快速编写软件的语言。毫不偏袒的说，我建议你学习一种动态语言。选择一种你觉得语法（文档）让你使用起来更舒服的编程。为此，你可能需要花费一些时间来在几种不同的语言之间进行比较。这么做目的不是为了让你感觉更好或者让编程更容易。更快地完成自己的作品并且能够看到成果，才是激励你编程的源动力。不要选择一门需要某种重量级的IDE（IDE是一种能够帮助你编写并运行代码的工具）才能轻松编程的语言。你所需要的仅仅是一个文本编辑器。（注：原文并没有标号，是我们加上的，请大家别忘记了哦，我们是从零开始数数的。:) ）\n\n　　2. 选择一个好的编辑器。\n\n编辑器对程序员而言，就是像是弓对弓箭手一样重要。这里有一些推荐的编辑器：\n\nSublimeText 2 – 如果你刚开始编程，推荐使用SublimeText 2,Emacs – 学习曲线陡峭，快捷键复杂。如果你想定制自己的使用习惯，需要学习Emacs Lisp.Vim – 不仅操作简洁而且它默认包含在linux的发行版中，所以深受大家欢迎。我开始使用了2年Emacs。由于Emacs的快捷键操作过于复杂，我的双手开始经常疼痛，这迫使我转向了Vim阵营。了解Vim的快捷键是非常有必要的。当你在远程的服务器上编辑代码时，你唯一不需要安装的编辑器就是Vim。\n注意！Emacs和Vim可能已经成为成为古董了。但是，它们都具备一些现代编辑器多不具备的功能。\n\n　　3. 选择一个你可以从中学到东西的操作系统\n\nWindows不会教会你任何东西。使用Windows你唯一学会的就是打开一个exe（可执行）文件来安装软件和使用它。可能刚开始的时候你会觉得很酷，但是长远来看，如果你立志成为一个web开发人员，可能还是要具备基本的linux知识，尤其是当你要发布程序的时候。Linux也允许你根据自己的要求来定制程序。Macs也很酷，但是我认为你现在经济上还负担不起。\n\n　　4. 不要通过复制粘贴来做备份\n\n一个新手程序员通常会把文件复制粘贴到一个临时目录下面来进行备份。这也许也是他们唯一知道的方法。不要那么做！你需要使用版本控制软件。我强烈推荐使用Git，它是个目前很流行的版本控制工具，而且使用起来非常简单。对一个Git新手，有一个良好的社区和很多参考资源来学习。（除了Git之外，还有mercurial, darcs, fossil等等。但是我还是建议从Git开始，我有很多的理由来支持Git，这里就不多费口舌了。）\n\n　　5. 知道去哪里寻求帮助\n\n参加一个和你相关的（你使用编程工具相关的）程序员社区。比如StackOverflow就是程序员的Facebook。那里没有消息状态和回复，取而代之的是问题和答案。除此之外还要学会使用IRC。IRC是一种老式的聊天室，现在还在被大多数开发人员用来分享技术信息和帮助解决问题。\n\n　　6. 培养你的礼仪\n\n知道什么时候问问题。你遇到的大多数问题都是别人碰到过并且在Internet上能够找到解答的。在IRC或者任何论坛里发问之前，先搜索一下google（或者blekko）来看看是不是有现成的答案。在IRC上问问题需要有耐心。永远记住，人们只是处于好心来免费帮助你。有时你发问以后需要几个小时才能有回复。所以，耐心等待。除此之外，记得问问题的时候要礼貌。世界很小，你怎么对待别人，别人就会怎么对待你。\n\n　　7. 结交朋友，技术书籍只能教你解决常见的问题（他们说：书是死的）\n\n当你在捣鼓一些程序或者从程序的作者那里学习，你能学到一些书本上没有的东西。当你散步的时候，请和遇到的朋友打招呼。你肯定不是唯一的程序员。和其他的程序员一起交朋友一起工作。你会注意到，当一群技术爱好者在一起的时候，不论话题是从什么地方开始，最后总是以技术话题收尾。这是必然的现象。所以你可以尽情参与。在你的黄金年龄努力编程，我能告诉你的是，我在开始6年前寻找朋友并开始讨论编程，从那时起才学到那些书本和文章不会我的东西。所以我总是说，我的编程经验有6年，因为只有那个时候开始，我才开始与人交流并开始感觉真正地开始学习编程。\n\n　　8. 参加开源项目\n\n为开源项目编写代码能带来回报。这不仅仅是帮助别人，你留下的代码会被其他人使用或（可能）改进。当别人给你的代码添加功能或者提出修改意见时，也是在提高你的编程水平。开源软件项目不一定要是一个大工程，编写一个下载youtube视频的小程序也是很有用的。更重要的是，你会惊奇地发现你编写的代码会成为与他人有效沟通的桥梁。\n\n最后，若干年之后如果本文的内容曾经对你有一点点的帮助，作为回报请写一封类似的信给希望开始编程并不知如何入手的朋友，有可能的话请纠正本文中过时的内容。\n\n智者说过，掌握某个东西需要10年或10000个小时，也就是汉语中的“十年磨一剑”，所以不用着急。\n\n\t【原】月光博客 http://www.williamlong.info/archives/2700.html \n\n   英文原文：An open letter to those who want to start programming\n\t\n   中文翻译：伯乐在线","tags":["分享"],"categories":["分享"]}]