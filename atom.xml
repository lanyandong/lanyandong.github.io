<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YDLAN</title>
  
  <subtitle>一起来探索吧！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://smallseven.top/"/>
  <updated>2019-11-07T15:06:23.812Z</updated>
  <id>http://smallseven.top/</id>
  
  <author>
    <name>YDLAN</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Talk is cheap. Show me the code.</title>
    <link href="http://smallseven.top/2019/11/07/2019-11-07-new-start/"/>
    <id>http://smallseven.top/2019/11/07/2019-11-07-new-start/</id>
    <published>2019-11-07T14:58:14.000Z</published>
    <updated>2019-11-07T15:06:23.812Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="随笔集" scheme="http://smallseven.top/categories/%E9%9A%8F%E7%AC%94%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>关于NoSQL,Redis,CAP,分布式系统</title>
    <link href="http://smallseven.top/2019/09/14/2019-09-14-redis-study/"/>
    <id>http://smallseven.top/2019/09/14/2019-09-14-redis-study/</id>
    <published>2019-09-14T14:31:06.000Z</published>
    <updated>2019-09-14T14:45:06.516Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Redis与NoSQL"><a href="#Redis与NoSQL" class="headerlink" title="Redis与NoSQL"></a>Redis与NoSQL</h3><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。区别与传统的数据库系统，是NoSQL(Not Only SQL )的其中一种，除此之外常用NoSQL还有MongoDB, Elasticsearch, Solr和Cassandra等。</p><a id="more"></a><h3 id="Redis支持的数据结构"><a href="#Redis支持的数据结构" class="headerlink" title="Redis支持的数据结构"></a>Redis支持的数据结构</h3><p>Redis允许的value数据结构类型有5种：String（字符串）、List（列表）、Set（集合）、Hash（哈希）、Zset（有序集合）。</p><ul><li><strong>String类型</strong>：是最简单的类型（内部看是一个byte数组，最大上限是1G），用于存储二进制序列字符串，整数数据，浮点数据。</li><li><strong>List类型</strong>：简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边）。</li><li><strong>Set类型</strong>：是String类型的无序集合，集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</li><li><strong>Hash类型</strong>：是一个键值(key=&gt;value)对集合，是一个String类型的field和value的映射表，hash特别适合用于存储对象。</li><li><strong>Zset类型</strong>：zset 和 set 一样也是String类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。zset的成员是唯一的,但分数(score)却可以重复。</li></ul><p>操作命令：增加，删除，查询，返回长度。</p><ul><li><strong>增加操作</strong>：String（set、mset），List（lpush 、rpush），Set（sadd），Hash（hset、hmset），Zset（zadd）</li><li><strong>删除操作</strong>：String（del），List（lpop、rpop），Set（srem，spop），Hash（Hdel），Zset（zrem）</li><li><strong>查询操作</strong>：String（get），List（lrange），Set（smembers），Hash（hkeys，hvals，hgetall），Zset（zrange）</li><li><strong>返回长度操作</strong>：List（llen），Set（scard），Hash（hlen），Zset（zcard）。</li></ul><h3 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h3><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。Redis 提供了两种持久化方式:RDB（默认） 和AOF 。</p><ul><li><strong>RDB</strong>：Redis DataBase缩写，功能核心函数rdbSave(生成RDB文件)和rdbLoad（从文件加载内存）两个函数。</li><li><strong>AOF</strong>：Append-only file缩写，每当执行服务器(定时)任务或者函数时flushAppendOnlyFile 函数都会被调用，AOF写入保存，根据条件将 aof_buf 中的缓存写入到 AOF 文件，根据条件调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。</li><li><strong>比较</strong>：AOF文件比RDB更新频率高，优先使用AOF还原数据。AOF比RDB更安全也更大，但RDB性能比AOF要好。</li></ul><p><img src="https://s2.ax1x.com/2019/09/14/n6jL9K.png" alt="redis"></p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。如何避免：</p><ul><li>对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。</li><li>对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。</li></ul><p><strong>缓存雪崩</strong>：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。应该使用加锁或者队列控制读写缓存线程的数量，或者使用二级缓存，让缓存失效的时间点尽量均匀。</p><h3 id="CAP理论与分布式系统"><a href="#CAP理论与分布式系统" class="headerlink" title="CAP理论与分布式系统"></a>CAP理论与分布式系统</h3><p>CAP原则又称CAP定理，指的是在分布式系统的设计中，没有一种设计可以同时满足 Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性）3个特性。</p><ul><li>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）</li><li>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li><li>分区容忍性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li></ul><p>分区容错无法避免，因此可以认为 CAP 的 P 总是成立。CAP 定理告诉我们，剩下的 C 和 A 无法同时做到。</p><ol><li>对于单机单库系统，数据一致性可通过关系型数据库的事务来满足，而且ACID特性中的C是指强一致性，各数据库本身都支持，而且很成熟。</li><li>分布式系统则需要以BASE理论作为指导，即以基本可用性和最终一致性作为目标。</li><li>远程RPC调用是一致性问题主要原因，异步解耦+消息队列可作为分布式系统满足最终一致性的优秀方案。</li></ol><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>MongoDB是一个基于分布式文件存储的数据库，它是一个介于关系数据库和非关系数据库之间的产品，其主要目标是在键/值存储方式（提供了高性能和高度伸缩性）和传统的RDBMS系统（具有丰富的功能）之间架起一座桥梁，它集两者的优势于一身。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Redis与NoSQL&quot;&gt;&lt;a href=&quot;#Redis与NoSQL&quot; class=&quot;headerlink&quot; title=&quot;Redis与NoSQL&quot;&gt;&lt;/a&gt;Redis与NoSQL&lt;/h3&gt;&lt;p&gt;Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。区别与传统的数据库系统，是NoSQL(Not Only SQL )的其中一种，除此之外常用NoSQL还有MongoDB, Elasticsearch, Solr和Cassandra等。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://smallseven.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Redis" scheme="http://smallseven.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Java基础强化——Reflection</title>
    <link href="http://smallseven.top/2019/09/02/2019-09-02-java-reflection/"/>
    <id>http://smallseven.top/2019/09/02/2019-09-02-java-reflection/</id>
    <published>2019-09-02T09:43:53.000Z</published>
    <updated>2019-09-02T13:44:48.678Z</updated>
    
    <content type="html"><![CDATA[<p>1、反射：在程序运行时通过一个类的对象获取这个类的信息的方法。</p><p>2、Class类：在java里万事万物皆对象，可以理解为是Class类的对象，Class有一些方法可以由类的对象获取类的信息。获取一个class的Class实例有三种办法，如下：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectionDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"><span class="comment">// 实例对象如何表示</span></span><br><span class="line">ClassDemo classDemo = <span class="keyword">new</span> ClassDemo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClassDemo是类，其实也是一个实例对象是基于Class的。</span></span><br><span class="line"><span class="comment">//方法1：（任何一个类都有一个隐含的成员变量class）</span></span><br><span class="line">Class c1 = ClassDemo.class; </span><br><span class="line"></span><br><span class="line"><span class="comment">//方法2：（通过getClass()方法获取一个对象的类信息）</span></span><br><span class="line">Class c2 = classDemo.getClass(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 两种表达式相同的</span></span><br><span class="line">System.out.println(c1 == c2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法3：通过Class的forName()方法</span></span><br><span class="line">Class c3 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">c3 = Class.forName(<span class="string">"reflection.ClassDemo"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也是相等的</span></span><br><span class="line">System.out.println(c2 == c3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以通过c1，c2, c3创建该类的对象</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ClassDemo classDemo2 = (ClassDemo)c1.newInstance(); <span class="comment">// 根据实际情况进行强制类型转换</span></span><br><span class="line">classDemo2.print();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// classdemo 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"class demo"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、静态加载和动态加载：静态加载时值程序在编译期的时候就完成了加载编译，比如new对象就是编译时加载的，已经创建好了对象实例。而动态加载时指在运行时需要使用的时候才进行加载，绕过编译且不报错。</p><p>4、通过反射API获取类信息：使用Class的提供的方法可以获取一个对象的类的信息，包括成员变量，成员方法，构造方法，甚至包括接口信息，继承关系等。Java的反射API提供的<code>Field</code>类封装了成员变量的所有信息，<code>Method</code>对象封装了方法的所有信息，<code>Constructor</code>对象封装了构造方法的所有信息。</p><p>5、动态代理：JDK提供的动态创建接口对象的方式，即没有实现类但是在运行期动态创建了一个接口对象的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个InvocationHandler实例，它负责实现接口的方法调用；</span></span><br><span class="line"><span class="comment">// 通过Proxy.newProxyInstance()创建interface实例，它需要3个参数：(使用的`ClassLoader`；需要实现的接口数组；用来处理接口方法调用的`InvocationHandler`实例。)</span></span><br><span class="line"><span class="comment">//将返回的`Object`强制转型为接口。 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">InvocationHandler handler = <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                System.out.println(method);</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">"morning"</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Good morning, "</span> + args[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Hello hello = (Hello) Proxy.newProxyInstance(</span><br><span class="line">            Hello.class.getClassLoader(), <span class="comment">// 传入ClassLoader</span></span><br><span class="line">            <span class="keyword">new</span> Class[] &#123; Hello.class &#125;,  <span class="comment">// 传入要实现的接口</span></span><br><span class="line">            handler); <span class="comment">// 传入处理调用方法的InvocationHandler</span></span><br><span class="line">        hello.morning(<span class="string">"Bob"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">morning</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、代理模式和反射机制：动态代理是设计模式当中代理模式的一种（为其他对象提供一种代理以控制这个对象的访问），JDK的动态代理主要是使用的是反射机制。常应用于AOP（面向切面编程）、RPC（远程过程调用），反编译，EventBus 2.x，动态生成类框架等。</p><p>优点：运行期类型的判断，动态类加载，动态代理使用反射；</p><p>缺点：性能是一个问题，反射相当于一系列解释操作，通知jvm要做的事情，性能比直接的java代码要慢很多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、反射：在程序运行时通过一个类的对象获取这个类的信息的方法。&lt;/p&gt;&lt;p&gt;2、Class类：在java里万事万物皆对象，可以理解为是Class类的对象，Class有一些方法可以由类的对象获取类的信息。获取一个class的Class实例有三种办法，如下：&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://smallseven.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="http://smallseven.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>基于SSM框架的秒杀系统开发过程</title>
    <link href="http://smallseven.top/2019/09/02/2019-09-02-ssm-seckill/"/>
    <id>http://smallseven.top/2019/09/02/2019-09-02-ssm-seckill/</id>
    <published>2019-09-02T09:43:48.000Z</published>
    <updated>2019-11-07T14:57:22.317Z</updated>
    
    <content type="html"><![CDATA[<p>利用 Spring + SpringMVC + Mybatis框架完成的的商品秒杀系统API，通过对SSM框架配置整合，实现商品秒杀功能。主要分为数据库的设计与实现，开发环境的搭建，编程实现秒杀功能接口，利用Redis完成后端缓存优化，通过事务控制完成并发优化等过程，下面是的详细记录。</p><a id="more"></a><h3 id="1、数据库的设计"><a href="#1、数据库的设计" class="headerlink" title="1、数据库的设计"></a>1、数据库的设计</h3><p>根据对功能的分析，主要实现的是的秒杀商品的展示，以及秒杀成功的一个明细表。所以只需要创建两个表，用于数据存储。</p><p>秒杀商品表设计：</p><table><thead><tr><th>秒杀id</th><th>秒杀商品名</th><th>商品库存</th><th>秒杀开始时间</th><th>秒杀结束时间</th><th>记录创建时间</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>秒杀成功表设计：</p><p>因为每个秒杀商品的秒杀id是不同的，所以根据id可以定位到商品，然后根据id和用户电话复合主键，来保证每一个用户只能够秒杀一件商品，并且创建秒杀成功明细单。</p><table><thead><tr><th>秒杀id</th><th>用户电话</th><th>秒杀状态</th><th>记录创建时间</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p>将数据库表的定义和操作写成规范的sql脚本，方便维护和更新。SQL脚本如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 数据库初始化脚本</span></span><br><span class="line"><span class="comment">-- 创建数据库</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> seckill;</span><br><span class="line"><span class="comment">-- 使用数据库</span></span><br><span class="line"><span class="keyword">use</span> seckill;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> seckill(</span><br><span class="line">  <span class="string">`seckill_id`</span> <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NUll</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'商品库存ID'</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">VARCHAR</span>(<span class="number">120</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'商品名称'</span>,</span><br><span class="line">  <span class="string">`number`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'库存数量'</span>,</span><br><span class="line">  <span class="string">`start_time`</span> <span class="built_in">TIMESTAMP</span>  <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'秒杀开始时间'</span>,</span><br><span class="line">  <span class="string">`end_time`</span>   <span class="built_in">TIMESTAMP</span>   <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'秒杀结束时间'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> <span class="built_in">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (seckill_id),</span><br><span class="line">  <span class="keyword">key</span> idx_start_time(start_time),</span><br><span class="line">  <span class="keyword">key</span> idx_end_time(end_time),</span><br><span class="line">  <span class="keyword">key</span> idx_create_time(create_time)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> AUTO_INCREMENT=<span class="number">1000</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'秒杀库存表'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 初始化数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">into</span> seckill(<span class="keyword">name</span>,<span class="built_in">number</span>,start_time,end_time)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">  (<span class="string">'2000元秒杀iphone6'</span>,<span class="number">100</span>,<span class="string">'2019-08-21 00:00:00'</span>,<span class="string">'2019-08-22 00:00:00'</span>),</span><br><span class="line">  (<span class="string">'1000元秒杀小米9'</span>,<span class="number">100</span>,<span class="string">'2019-08-21 00:00:00'</span>,<span class="string">'2019-08-22 00:00:00'</span>),</span><br><span class="line">  (<span class="string">'2000元秒杀华为P30'</span>,<span class="number">100</span>,<span class="string">'2019-08-21 00:00:00'</span>,<span class="string">'2019-08-22 00:00:00'</span>),</span><br><span class="line">  (<span class="string">'2000元秒杀OPPO Reno'</span>,<span class="number">100</span>,<span class="string">'2019-08-21 00:00:00'</span>,<span class="string">'2019-08-22 00:00:00'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 秒杀成功明细表</span></span><br><span class="line"><span class="comment">-- 用户登录认证相关信息(简化为手机号)</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> success_killed(</span><br><span class="line">  <span class="string">`seckill_id`</span> <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'秒杀商品ID'</span>,</span><br><span class="line">  <span class="string">`user_phone`</span> <span class="built_in">BIGINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户手机号'</span>,</span><br><span class="line">  <span class="string">`state`</span> <span class="built_in">TINYINT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">-1</span> <span class="keyword">COMMENT</span> <span class="string">'状态标识:-1:无效 0:成功 1:已付款 2:已发货'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> <span class="built_in">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(seckill_id,user_phone),<span class="comment">/*联合主键*/</span></span><br><span class="line">  <span class="keyword">KEY</span> idx_create_time(create_time)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'秒杀成功明细表'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- SHOW CREATE TABLE seckill;#显示表的创建信息</span></span><br></pre></td></tr></table></figure><h3 id="2、开发环境的搭建"><a href="#2、开发环境的搭建" class="headerlink" title="2、开发环境的搭建"></a>2、开发环境的搭建</h3><p>maven项目构建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=cn.ydlan.seckill -DartifactId=seckill -Dpackage=cn.ydlan.seckill -Dversion=1.0-SNAPSHOT -DarchetypeArtifactId=maven-archetype-webapp</span><br></pre></td></tr></table></figure><p>关于maven构建项目：</p><p>archetype是指maven的项目模板，有（cocoon-22-archetype-webapp，maven-archetype-quickstart，maven-archetype-webapp）三种，maven-archetype-webapp模板，生成的项目包WEB-INF目录，并且有web.xml和一个index.jsp。</p><p>pom.xml相关依赖配置：</p><ul><li><p>junit依赖，junit是使用编程的方式来进行测试，而junit4是使用注解的方式来运行junit。</p></li><li><p>日志管理输出依赖，slf4j,log4j,logback,common-logging。</p></li><li><p>数据库相关依赖，数据库连接与数据池配置。</p></li><li><p>MyBatis依赖，实现dao框架与mybatis自身实现的spring整合依赖。</p></li><li><p>Servlet web相关依赖。</p></li><li><p>spring依赖，包括spring核心依赖，dao依赖，web依赖，以及test依赖。</p></li></ul><h3 id="3、DAO层的设计与开发"><a href="#3、DAO层的设计与开发" class="headerlink" title="3、DAO层的设计与开发"></a>3、DAO层的设计与开发</h3><p>创建实体类和DAO接口：</p><ul><li>创建Seckill.java和SuccessKilled.java 两个实体类</li><li>分别创建这个两个类对应的DAO接口SeckillDao.java和SuccessKilledDao.java</li><li>创建映射文件SeckillDao.xml和SuccessKilledDao.xml</li></ul><p>mybatis与spring的整合：</p><ul><li>创建mybatis-config.xml配置文件，主要负责mybatis的配置。</li><li>创建一个jdbc.properties文件，保存jdbc数据库连接的配置。</li><li>创建一个spring文件夹存放spring的相关配置（spring-dao.xml）。</li></ul><p>Junit测试：</p><ul><li>分别创建SeckillDao.java和SuccessKilledDao.java两个接口的单元测试</li><li>单元测试需要使用注解进行配置，以及使用@Resource完成依赖注入。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置spring和junit整合，这样junit在启动时就会加载spring容器</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="comment">//告诉junit spring的配置文件</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(&#123;<span class="string">"classpath:spring/spring-dao.xml"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillDaoTest</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="4、Service层的设计与开发"><a href="#4、Service层的设计与开发" class="headerlink" title="4、Service层的设计与开发"></a>4、Service层的设计与开发</h3><p>接口设计：（如无必要，勿增实体）</p><ul><li>创建SeckillService接口，提供四个功能分别是查询全部秒杀记录，查询单个秒杀记录，获取秒杀接口，执行秒杀功能。</li><li>使用DTO来承接返回结果，创建Exposer实体类封装暴露的秒杀接口，创建SeckillExecution实体类封装秒杀执行情况。</li><li>处理秒杀重复和秒杀关闭异常，跳过编译期异常，适当的处理运行期异常情况。</li></ul><p>接口实现：</p><ul><li>根据秒杀id以及系统时间，判断秒杀接口是否暴露，并通过MD5对秒杀接口进行加密处理。</li><li>执行秒杀过程，验证消息，执行秒杀逻辑，修改数据库信息，处理异常情况。</li><li>创建枚举型保存常量字典，替换代码中的常量。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SeckillStatEnum &#123;</span><br><span class="line"></span><br><span class="line">    SUCCESS(<span class="number">1</span>,<span class="string">"秒杀成功"</span>),</span><br><span class="line">    END(<span class="number">0</span>,<span class="string">"秒杀结束"</span>),</span><br><span class="line">    REPEAT_KILL(-<span class="number">1</span>,<span class="string">"重复秒杀"</span>),</span><br><span class="line">    INNER_ERROR(-<span class="number">2</span>,<span class="string">"系统异常"</span>),</span><br><span class="line">    DATE_REWRITE(-<span class="number">3</span>,<span class="string">"数据篡改"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">private</span> String info;</span><br><span class="line"></span><br><span class="line">    SeckillStatEnum(<span class="keyword">int</span> state, String info) &#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>配置spring托管service：</p><ul><li>创建spring-service.xml文件，扫描service包下所有使用注解的类型。</li><li>配置事务管理器，注入数据库连接池，配置基于注解的声明式事务，默认使用注解来管理事务行为。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--扫描service包下所有使用注解的类型--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.ydlan.seckill.service"</span>/&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--注入数据库连接池--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--配置基于注解的声明式事务</span></span><br><span class="line"><span class="comment">   默认使用注解来管理事务行为--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>采用注解的方式将Service的实现类加入到Spring IOC容器中。</li></ul><p>创建service层的单元测试：</p><ul><li>创建SeckillServiceTest Junit测试，自动注入对象，测试接口中每个方法的正确性。</li></ul><h3 id="5、Web层的设计与开发"><a href="#5、Web层的设计与开发" class="headerlink" title="5、Web层的设计与开发"></a>5、Web层的设计与开发</h3><p>SpringMVC 的理论部分：</p><ul><li>SpringMVC的运行流程（Handler和Controller）</li><li>HTTP请求地址映射原理，设计优雅的RESTful</li><li>注解映射技巧（RequestMapp注解），请求方法细节处理</li></ul><p>配置SpringMVC 的整合：</p><ul><li>在web.xml 中配置DispatcherServlet，将配置文件加载到DispatcherServlet里，完成Mybites -&gt; spring -&gt; springMVC的无法整合。</li><li>创建spring-web.xml文件，配置spring MVC（开启springmvc注解模式，静态资源默认servlet配置，配置JSP 显示ViewResolver，扫描web相关的bean）。</li><li>实现SeckillController，使用注解将方法注入容器，通过@RequestMapping注解定义URL 请求和Controller 方法之间的映射，使Controller 就能够被外界访问到。</li></ul><p>前端交互过程：</p><ul><li>Bootstrap开发界面，利用开发框架提供的CSS样式，可以完成简单而漂亮的前端界面。</li><li>jQuery开发交互界面，使用CDN 获取公共js，获取jQuery Cookie操作插件和countDown倒计时插件，自定义交互逻辑脚本。</li><li>交互逻辑脚本实现，封装秒杀相关ajax的url，模块化JS，执行交互逻辑以及数据回传显示。</li></ul><h3 id="6、高性能优化"><a href="#6、高性能优化" class="headerlink" title="6、高性能优化"></a>6、高性能优化</h3><p>使用Redis缓存：</p><ul><li>Redis的使用：下载解压，进入解压文件里，使用命令行执行make，然后在启动Redis server，然后使用执行命令’redis-cli -p 6379’查看运行情况，这里的端口需要自己设置。</li><li>项目中使用Redis：添加相关的依赖，包括jedis和protostuff-core以及protostuff-runtime序列化的依赖。</li><li>在DAO层设计一个RedisDao,作为数据的缓冲cache。并通过序列化和反序列化操作，实现对象的存取。改造exportSeckillUrl方法,一定要先注入redisDao。</li><li>写存储过程,然后去，Mysql控制台执行储存过程。</li></ul><p>事务控制优化：</p><ul><li>调整事务的执行顺序（SQL的顺序），通过的事务的调整控制，减少虚拟机的GC操作，提高系统的运行效率。</li><li>改造SeckillController中的execute方法调用,把一开始调用普通方法的改成调用储存过程的那个方法。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用 Spring + SpringMVC + Mybatis框架完成的的商品秒杀系统API，通过对SSM框架配置整合，实现商品秒杀功能。主要分为数据库的设计与实现，开发环境的搭建，编程实现秒杀功能接口，利用Redis完成后端缓存优化，通过事务控制完成并发优化等过程，下面是的详细记录。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaEE" scheme="http://smallseven.top/categories/JavaEE/"/>
    
    
  </entry>
  
  <entry>
    <title>2019中国国际智能产业博览会</title>
    <link href="http://smallseven.top/2019/08/29/2019-08-29-cse2019/"/>
    <id>http://smallseven.top/2019/08/29/2019-08-29-cse2019/</id>
    <published>2019-08-29T08:18:29.000Z</published>
    <updated>2019-08-30T01:42:03.659Z</updated>
    
    <content type="html"><![CDATA[<p>今年的智博会还是有一些亮点的，去年作为志愿者没有时间参观会展，今年作为一名观众，花了了大概三四个小时把展馆走了一圈，发现还是有一些亮点的。我就对比看一下，就能感受到科技和产业的发展的一个简单趋势了。</p><h3 id="5G是今年最大的亮点"><a href="#5G是今年最大的亮点" class="headerlink" title="5G是今年最大的亮点"></a>5G是今年最大的亮点</h3><a id="more"></a><p>虽然去年也有类似5G的展但都没有实实在在的产品落地，今年不一样，有很多产品已经落地了。虽然上半年已经有报道关于5G产品，但在咱这地方确实没有机会体验到，这次刚好有机会可以体验一下。</p><p>5G手机，5G芯片，5G视频传输，反正5G带动的整个生态是非常强大的，5G的赋能让AI大数据，物联网和工业互联网的应用更加可行和可靠。三大运营商都推出了5g的解决方案。中兴亮相了5G的机站还有刚发布的中兴天机Axon10 Pro，体验感十足。</p><p><img src="https://s2.ax1x.com/2019/08/29/mqyaG9.jpg" alt="5g"></p><p>由5G带动的一系列产业也慢慢有起色，像比物联网，5G传输应用在展会中也有出现。除此之外还有5G芯片，物联网芯片，手机芯片也都亮相了。</p><p><img src="https://s2.ax1x.com/2019/08/29/mqyBKx.jpg" alt="5gcore"></p><h3 id="AI技术广泛应用"><a href="#AI技术广泛应用" class="headerlink" title="AI技术广泛应用"></a>AI技术广泛应用</h3><p>除了5G以外，还有一些看点的就是AI，今年AI的产品应用比去年多了很多，AI的产品和应用基本成为现在大公司的基本布局。展会上有AI作画，AI语音识别，以及广受欢迎的图像识别，现在的图像识别已经能够做到又快又准，而且还能结合大数据进行分析，基本上已经比较成熟了。不过很多公司的产品都大同小异没啥看点。在我看来AI的最重要的还是算法PK吧。</p><p><img src="https://s2.ax1x.com/2019/08/29/mqyd2R.jpg" alt="ai"></p><h3 id="工业互联网和自动化"><a href="#工业互联网和自动化" class="headerlink" title="工业互联网和自动化"></a>工业互联网和自动化</h3><p>工业互联网产业化基本已经定型，自动化水平越来越高，使用工业机器人来完成一系列工作已经成为提高生产力的重要方法。在展会上各种各样的工业机器人实操演示，还有各种应用解决方案在，只有我们想不到的，没有啥是做不到的。技术真的能改变生活！</p><p><img src="https://s2.ax1x.com/2019/08/29/mqyt54.jpg" alt="gongye"></p><p><img src="https://s2.ax1x.com/2019/08/29/mqyUPJ.jpg" alt="gongye2"></p><h3 id="技术带来的生活体验"><a href="#技术带来的生活体验" class="headerlink" title="技术带来的生活体验"></a>技术带来的生活体验</h3><p>通过参展我发现了一些新的东西，就是目前一些大型互联网科技公司，做产品越来越注重用户的个人体验了，无论是从整个生态来讲还是单一的产品来说，大公司对于用户的体验和审美都有导向做作用，产品的设计更加的人性化，产品的理念更加新颖有创造力。</p><p><img src="https://s2.ax1x.com/2019/08/29/mqyrqK.jpg" alt="google"></p><p><img src="https://s2.ax1x.com/2019/08/29/mqyJVU.jpg" alt="8k"></p><h3 id="高校科研和国际合作"><a href="#高校科研和国际合作" class="headerlink" title="高校科研和国际合作"></a>高校科研和国际合作</h3><p>展区还有高校的科研展区，国际展区，以及全国个省展区，还有重庆本地各县区展区，我都仔细的逛了一圈，有亮眼的黑科技，也有很平常的应用，虽然参差不齐，但却很全面。我们可以预见重庆发展会越来越迅速的。</p><p><img src="https://s2.ax1x.com/2019/08/29/mqyYaF.jpg" alt="gaoxiao"></p><p><img src="https://s2.ax1x.com/2019/08/29/mqyDr6.jpg" alt="gouji"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今年的智博会还是有一些亮点的，去年作为志愿者没有时间参观会展，今年作为一名观众，花了了大概三四个小时把展馆走了一圈，发现还是有一些亮点的。我就对比看一下，就能感受到科技和产业的发展的一个简单趋势了。&lt;/p&gt;&lt;h3 id=&quot;5G是今年最大的亮点&quot;&gt;&lt;a href=&quot;#5G是今年最大的亮点&quot; class=&quot;headerlink&quot; title=&quot;5G是今年最大的亮点&quot;&gt;&lt;/a&gt;5G是今年最大的亮点&lt;/h3&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>智力算法和一些有趣的算法题（LeetCode）</title>
    <link href="http://smallseven.top/2019/08/21/2019-08-21-leetcode-ac/"/>
    <id>http://smallseven.top/2019/08/21/2019-08-21-leetcode-ac/</id>
    <published>2019-08-21T09:31:25.000Z</published>
    <updated>2019-08-21T11:49:48.582Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些有意思的智力算法和一些有趣的算法题。</p><h2 id="除数博弈"><a href="#除数博弈" class="headerlink" title="除数博弈"></a><a href="https://leetcode-cn.com/problems/divisor-game/" target="_blank" rel="noopener">除数博弈</a></h2><p><strong>题目描述：</strong></p><p>爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。</p><p>最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：</p><p>选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。<br>用 N - x 替换黑板上的数字 N 。<br>如果玩家无法执行这些操作，就会输掉游戏。</p><a id="more"></a><p>只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。</p><p><strong>题解思路：</strong></p><p>可以依次举例数字N的值，以及爱丽丝获胜的的情况，比如：</p><table><thead><tr><th>N的值</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>A先手</td><td>x</td><td>(2)1</td><td>(3)1</td><td>(4)1-(2)1</td><td>(5)1-(3)1</td><td>(6)1</td><td>(7)1</td></tr><tr><td>B后手</td><td>x</td><td>x</td><td>(2)1</td><td>(3)1</td><td>(4)1</td><td>(5)1</td><td>(6)1</td></tr><tr><td>A获胜</td><td>false</td><td>true</td><td>false</td><td>true</td><td>false</td><td>true</td><td>false</td></tr></tbody></table><p>由已知的数学规律：奇数的因子（约数）只能是奇数，偶数的因子（约数）可以是奇数或偶数。然后举几个例子就能够发现一些其他规律：当N为奇数的时候，先手(A)只能够选择奇数，此时<code>奇数-奇数=偶数</code>，则一下个玩家面对的数据就为偶数，当玩家面对偶数时，可能会选择偶数因子也可能选择奇数因子，由规律发现只有先手数据为偶数时，A才能够获胜，相反情况则B获胜，所以在玩家最佳状态选择除数因子都会遵循：<code>N-除数因子 = 奇数</code>，这样对手就不会获胜了。</p><p><strong>代码实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">divisorGame</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2的幂"><a href="#2的幂" class="headerlink" title="2的幂"></a><a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noopener">2的幂</a></h2><p><strong>题目描述：</strong></p><p>给定一个整数，编写一个函数来判断它是否是 2 的幂次方。</p><p><strong>解题思路：</strong></p><p>传统解法：不停地去除以 2，看最后的迭代商是否为 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n ==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(n % <span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            n=n/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用二进制的解法：如果一个数是 2 的次方数的话，那么它的二进数必然是最高位为 1，其它都为 0 ，那么如果此时我们减 1 的话，则最高位会降一位，其余为 0 的位现在都为变为 1，那么我们把两数相与，就会得到 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; ((n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3的幂"><a href="#3的幂" class="headerlink" title="3的幂"></a><a href="https://leetcode-cn.com/problems/power-of-three/" target="_blank" rel="noopener">3的幂</a></h2><p><strong>题目描述：</strong></p><p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。</p><p><strong>解题思路：</strong></p><p>与上面2的幂的解法类似，第一个方法是不停地去除以 3，看最后的迭代商是否为 1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">3</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">n = n / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种思路是将整数转换为3进制数的字符串，然后判断最高是否为1，其余位为0，但是3进制转换需要写一个转换方法，有点麻烦。</p><p>所以可以再换一个思路，因为<code>3的次幂的质因子只有3</code>，因为根据数论相关定理，不考虑排列顺序的情况下，每个正整数都能够以唯一的方式表示成它的质因数的乘积。比如：1没有质因子。2、4、8、16等只有1个质因子：2（2是质数，4 = 2^2，8 = 2^3，如此类推），3的次幂的质因子只有3（3、9、27、81…）。</p><p>又因为给定的是整数，故而题目中所给整数范围内最大的 3 的幂次的因子只能是 3 的幂次，而1162261467 是 3 的 19 次幂，是整数范围内最大的3的幂次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; <span class="number">1162261467</span> % n == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4的幂"><a href="#4的幂" class="headerlink" title="4的幂"></a><a href="https://leetcode-cn.com/problems/power-of-four/" target="_blank" rel="noopener">4的幂</a></h2><p><strong>题目描述：</strong></p><p>给定一个整数 (32 位有符号整数)，请编写一个函数来判断它是否是 4 的幂次方。</p><p><strong>解题思路：</strong></p><p>直观思路，循环num=num/4检测num%4是否为0，直到num为1为止。注意，需考虑num为0的情况，否则会陷入死循环，码代码多考虑一些边界特殊情况.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num%<span class="number">4</span> != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            num = num/<span class="number">4</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不使用循环的解法：我们知道num &amp; (num - 1)可以用来判断一个数是否为2的幂，其中4的幂是2的幂的一个子集，所以对2的幂做一些限制条件，4的幂都是在16进制下的第1和4位，即0101，所以我们只需和数(0x55555555) 进按位与，得到的数还是其本身，则可以肯定其为4的次方数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfFour</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num &gt; <span class="number">0</span> &amp;&amp; (num&amp;(num-<span class="number">1</span>)) == <span class="number">0</span> &amp;&amp; ((num&amp;<span class="number">0x55555555</span>)==num); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一些有意思的智力算法和一些有趣的算法题。&lt;/p&gt;&lt;h2 id=&quot;除数博弈&quot;&gt;&lt;a href=&quot;#除数博弈&quot; class=&quot;headerlink&quot; title=&quot;除数博弈&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/divisor-game/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;除数博弈&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;题目描述：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。&lt;/p&gt;&lt;p&gt;最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：&lt;/p&gt;&lt;p&gt;选出任一 x，满足 0 &amp;lt; x &amp;lt; N 且 N % x == 0 。&lt;br&gt;用 N - x 替换黑板上的数字 N 。&lt;br&gt;如果玩家无法执行这些操作，就会输掉游戏。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://smallseven.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://smallseven.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>利用Struts+Hibernate构建学生管理系统遇到的一些问题</title>
    <link href="http://smallseven.top/2019/08/18/2019-08-18-ssh-test/"/>
    <id>http://smallseven.top/2019/08/18/2019-08-18-ssh-test/</id>
    <published>2019-08-18T13:51:56.000Z</published>
    <updated>2019-08-21T14:27:00.567Z</updated>
    
    <content type="html"><![CDATA[<p>私以为在学习过程中多一些BUG是有好处的，通过BUG可以学习很多新的东西，以及解决问题方法。当然遇到BUG首先应该仔细看报错信息，然后准确定位问题，不要盲目的百度检索。下面就来记录一下利用Struts+Hibernate构建学生管理系统遇到的一些问题，如果以后出现类似问题，方便查阅。</p><a id="more"></a><h3 id="1-jar包配置问题"><a href="#1-jar包配置问题" class="headerlink" title="1. jar包配置问题"></a>1. jar包配置问题</h3><p>本次项目的开发环境为：Struts2.3 + hibernate3.0 + MySQL5.0，由于使用的是Eclipse，并没有使用Maven进行项目构建，所以所有的环境和需要的jar都需要手动配置。项目需要导入需要的核心jar包，包括：hibernate-core包，struts2-core包，mysql驱动包 junit单元测试包。</p><p>所需要的jar包，大多可通过百度查的官方下载地址（<a href="https://mvnrepository.com/" target="_blank" rel="noopener">https://mvnrepository.com/</a>），下载需要的jar，然后导入到项目的WEB-INF目录下的lib目录中。</p><h3 id="2-配置struts环境"><a href="#2-配置struts环境" class="headerlink" title="2. 配置struts环境"></a>2. 配置struts环境</h3><p>配置struts只需要简单的两部：</p><ol><li>修改web.xml, 配置过滤器。这里需要弄清楚struts使用的版本。</li><li>创建struts.xml 并将文件保存在Java Resources 下的src目录下，struts.xml 是用来拦截请求转发至对应Action的，所以要完成Action注册。</li></ol><p>下面是一个简单的struts.xml配置例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE struts PUBLIC</span></span><br><span class="line"><span class="meta">        "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"</span></span><br><span class="line"><span class="meta">        "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Struts xml的配置文件 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 所有匹配*.action的请求都由struts2处理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.action.extension"</span> <span class="attr">value</span>=<span class="string">"action,,"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 是否启用开发模式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constant</span> <span class="attr">name</span>=<span class="string">"struts.devMode"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"default"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">namespace</span>=<span class="string">"/"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 如果不指定method，那么默认方法是execute--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--name:Action类的名字，具有唯一性，页面上通过name来访问Action类 --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"test"</span> <span class="attr">class</span>=<span class="string">"test"</span> <span class="attr">method</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 配置结果集 :name属性的值一定要与execute方法的返回值一致--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"test"</span>&gt;</span>test.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-hibernate相关配置"><a href="#3-hibernate相关配置" class="headerlink" title="3. hibernate相关配置"></a>3. hibernate相关配置</h3><p>创建hibernate.cfg.xml文件,并将文件保存在Java Resources 下的src目录下。配置文件包括两个核心部分：一个是property属性，主要配置的是数据库的链接。另外一个是mapping属性，指定关联的 .hbm.xml文件。</p><p>另外指定currentSession()方法所得到的Session由谁来跟踪管理，thread指Session由当前线程来跟踪管理，这是一种事务配置的方式，实质上是只当前session通过当前执行的线程来跟踪和界定。</p><p>hibernate还有一个很牛的feature就是可以用HQL，这是完全可以把查询映射到你OO模型的查询语言，我们可以不用过多关注SQL的编写，而更关注于数据和数据、对象和对象之间的关系。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration PUBLIC</span></span><br><span class="line"><span class="meta">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.password"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/studentms?useUnicode=true&amp;amp;characterEncoding=utf-8<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dialect"</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 执行操作时是否在控制台打印SQL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定自动生成数据表的策略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定currentSession()方法所得到的Session由谁来跟踪管理，thread指Session由当前线程来跟踪管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.current_session_context_class"</span>&gt;</span>thread<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定关联的 .hbm.xml文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"entity/Students.hbm.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"entity/Users.hbm.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于实体和表的映射，需要生成相关.hbm.xml映射文件，用于向Hibernate提供关于将对象持久化到关系数据库中的信息，持久化对象的映射定义可全部存储在同一个映射文件中，也可将每个对象的映射定义存储在独立的文件中。后一种方法较好，因为将大量持久化类的映射定义存储在一个文件中比较麻烦，而且将难以调试和隔离特定类的映射定义错误。</p><h3 id="4-设计接口和实现类"><a href="#4-设计接口和实现类" class="headerlink" title="4. 设计接口和实现类"></a>4. 设计接口和实现类</h3><p>面向接口编程是OOP的设计原则之一，目的是就是降低程序的耦合性，接口定义统一的编程规范，实现类可以根据具体的业务逻辑实现特定的功能，既利于程序的扩展，也利于程序的维护。</p><p>在对数据库进行管理时，可以利用Hibernate的 SessionFactroy接口，创建会话工厂对象，它充当数据存储源的代理，并负责创建Session对象。一般情况下，一个项目通常只需要一个SessionFactory就够，然后在其他类中调用其中的方法就OK了。下面就是一个简单的创建会话对象的类方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.boot.registry.StandardServiceRegistryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.cfg.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.service.ServiceRegistry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 会话工厂类,目的获得SessionFactory对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHibernateSessionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SessionFactory sessionFactory; <span class="comment">//会话工厂属性</span></span><br><span class="line"><span class="comment">// 构造函数保证单例模式</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MyHibernateSessionFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//共有的静态方法，获得会话工厂对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SessionFactory <span class="title">getSessionFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(sessionFactory==<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="comment">//创建配置对象</span></span><br><span class="line">Configuration config = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line"><span class="comment">//创建服务注册对象  </span></span><br><span class="line">ServiceRegistry serviceRegistry = <span class="keyword">new</span> StandardServiceRegistryBuilder().applySettings(config.getProperties()).build();</span><br><span class="line"><span class="comment">//创建sessionFactory</span></span><br><span class="line">sessionFactory = config.buildSessionFactory(serviceRegistry);</span><br><span class="line"><span class="keyword">return</span> sessionFactory;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> sessionFactory;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用Hibernate的Query，Transaction和Session可以完成数据库事务的管理操作，Query负责执行各种数据库查询。它可以使用HQL语言或SQL语句两种表达方式。它的返回值一般是List，需要自己转换。Transaction接口负责事务相关的操作，一般在Hibernate的增删改中出现，但是使用Hibernate的人一般使用spring)去管理事务。</p><p>这里值得注意的是Hibernate的Session接口， Session可以看作介于数据连接与事务管理一种中间接口，有时也称Session是一个持久层管理器，因为它包含这一些持久层相关的操作，如存储持久对象至数据库，以及从数据库从获得它们。</p><p>在Hibernate中，实例化的Session是一个轻量级的类，创建和销毁它都不会占用很多资源，这不同于JSP 应用中的HttpSession，一般情况我们会会HttpSesion 对象称为用户session。</p><h3 id="5-设计Action控制器"><a href="#5-设计Action控制器" class="headerlink" title="5.  设计Action控制器"></a>5.  设计Action控制器</h3><p>在项目中Action承担着一个控制业务调度和管理跳转的功能，Action就像是服务员，顾客点什么菜，菜上给几号桌，都是ta的职责；所以当实现功能后，需要在struts.xml 中进行注册，与JSP的请求相对应，并完成相应的界面调用。</p><p>Struts接受的表单数据的方式有几种方式，分别是实体类对象，属性驱动，模型驱动的方式和表达式驱动等，具体采用哪种需要根据具体的业务逻辑来选择，没有最好的，只有最合适的。</p><p>可以直接使用Validator(验证器)框架对表单数据进行验证，而不需要用户编写代码去验证，拦截器是在Action提交之前，动态的拦截Action，然后查询配置文件，如果当前的Action配置了拦截器，那么就相应的实例化出拦截器对象，并串联成表，最后一个一个调用拦截器。</p><p>拦截器只对Action进行处理，对其余的不进行处理。拦截器可以读取值栈中的东西，就像登录验证时，拦截器可以读取Session的内容。拦截器一次创建可以多次被调用，只要是使用拦截器的Action，Action执行几次，拦截器就同样执行几次。</p><h3 id="6-项目框架"><a href="#6-项目框架" class="headerlink" title="6. 项目框架"></a>6. 项目框架</h3><p>项目中没有使用spring进行解耦，而是将hibernate和struts进行整合，项目也基本上符合MVC的一个设计理念：</p><p>Entity对应数据库表的实体类，Dao层是使用hibernate连接数据库、操作数据库（增删改查）定义了一些列操作数据库的接口，Service层：引用对应的Dao数据库操作。在一定程度上Dao层和Service可以写在一起。以上几层综合起来类似于MVC的模型层。</p><p>Action层：处理业务调度和管理跳转，引用对应的Service层，结合Struts的配置文件，跳转到指定的页面。起到一个控制层的作用。</p><p>最后是JSP表现的视图层，可以通过编写JSP进行请求和数据显示，这里可以使用struts的一些标签，通过用户session读出数据。JSP真的太难写了ORZ…前后端分离是相当有必要的，使用页面模板也是很有必要的。</p><p>整个项目的调用流程基本上是：<strong>JSP—Action—Service—DAO—Hibernate</strong>。整个项目框架的优点是：利用Struts负责Web层，进行请求拦截。利用Hibernate负责持久化层，完成对数据库的crud操作。</p><h3 id="7-问题总结"><a href="#7-问题总结" class="headerlink" title="7. 问题总结"></a>7. 问题总结</h3><p>通过上面的总结，把项目构建的重要步骤和项目的框架流程都进行分析，从零开始，一步步的构建一个完整项目，真的能够学到很多东西。熟能生巧，多看多思多动手，技术能力自然就有增长咯。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;私以为在学习过程中多一些BUG是有好处的，通过BUG可以学习很多新的东西，以及解决问题方法。当然遇到BUG首先应该仔细看报错信息，然后准确定位问题，不要盲目的百度检索。下面就来记录一下利用Struts+Hibernate构建学生管理系统遇到的一些问题，如果以后出现类似问题，方便查阅。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaEE" scheme="http://smallseven.top/categories/JavaEE/"/>
    
    
      <category term="JavaEE" scheme="http://smallseven.top/tags/JavaEE/"/>
    
  </entry>
  
  <entry>
    <title>秋招之前</title>
    <link href="http://smallseven.top/2019/08/12/2019-08-12-before-recruitment/"/>
    <id>http://smallseven.top/2019/08/12/2019-08-12-before-recruitment/</id>
    <published>2019-08-12T01:01:05.000Z</published>
    <updated>2019-08-12T03:21:39.933Z</updated>
    
    <content type="html"><![CDATA[<p>接近八月中旬，秋招也陆陆续续的开始了。回想自己的春招经历，也是惨目忍睹，由于缺乏准备和自身能力的欠缺，错失了很多很好的机会。春招的试错，为秋招的准备提供了一个很好的指导，通过自己近段时间的学习和查缺补漏，技术栈和基础知识都得到了提升和巩固。但面对秋招，我觉得还是有很大的欠缺，下面就总结一下自己近段时间所学以及要努力提升的东西。</p><a id="more"></a><p>从暑假实习结束回到学校，首先将上个学过的课程内容进行了简单的整理总结，因为上个学期的很多课程都还是比较重要，比如数据库，Java等都是自己将来工作中会常常使用的，嵌入式和计算机体系结构这些课程是对计算有更深入的了解，在之前的几篇博文中也总结了自己通过课程学习的所思所感所获。我们学的很多东西都很基础，对于自己职业发展也并没有很明显的帮助，所以将很多关键性的东西我都将其总结并同步到Github上了，如果以后涉及到了的话方便查看。</p><p>总结春招的失误的教训，很多原因是由于基础不劳造成的，所以花费了一些时间来巩固基础的内容，包括操作系统，计算机网络，还有数据结构和算法。回顾了之前记录的笔记和参考了网上的一些内容，把计算机网路和操作系统的核心内容提取了出来，并构建了自己的Learning Notes（<a href="https://smallseven.top/mkdocs-notes/">https://smallseven.top/mkdocs-notes/</a>）。花费时间比较多的是数据结构和算法，之前学习的时候只是了解了大致的思想，并没有通过编程去实现它，这次通过Java编程实现了常用的排序算法和一些基础的数据结构，对这些知识又有了新的认识。</p><p>关于Java的基础，将《Java基础教程》过了一遍，了解了一些不常用的方法和工具包。《Java编程思想》这本书写得比较详细深入，只看了几章自己觉得欠缺的内容。另外《Java数据结构和算法》基本上看完一遍，并把一些例子实现了。为了拓展内容还专门看了一些清华邓俊辉的数据结构，不愧是大师讲的内容，思路惊奇并且理论依据充足，记忆最深的是在讲Hash时，关于Hash函数的设计和减少冲突的算法就讲了很多种，并且都进行性能分析和对比，让人受益匪浅，如果有时间可以深入的了解一下。为了查缺补漏快速的过了一遍清华郑莉的Java基础课程，内容比较简单但还是有一些额外的收获，比如了解了更多关于Object类，继承多态，抽象类等方面的东西。通过对基础的复习，很多内容得到了巩固，最缺乏的就是练习了。</p><p>关于Java Web开发的学习，学习过程并没有很清楚的路线，这也正是我比较担心的东西，Java后台开发涉及的东西很多，如果每一样都要学会才去上手实践，这大概可能不太现实，所以自己零零碎碎的学了一些东西，首先把SpringMVC框架的底层内容了解了一下，其次是将程序猿DD的SpringBoot的基础教程看了一遍。看完之后感觉学到了东西，又感觉什么也没学到，自己也很方。关于框架的学习还真得找大佬取取经。另外，还看了《深入理解Java虚拟机》，对于其中的Java内存模型，垃圾回收有了更深入的认识。至于Java的设计模式还没有看，但对OOP的设计原则有了一些了解。</p><p>关于自己的技术栈，大致应该是以Java语言为核心的后端开发为主，去学习了解更多框架，熟悉业务流程，前后端分离以及近些年前端的崛起，后端也越来越苦逼，总有学不完的框架，而这些框架大多为了提高开发效率而屏蔽了底层实现细节，这对于开发人员是好是坏？自己的技术路线该如何选择，上天还是入地，这真是一个值得思考的问题。对于现在我自己的技术能力对于强大的后端开发而言，真的是连入门都算不上，这一点我自己十分清楚。对于一个应届生而言，大概其核心竞争力就是学习能力和专业基础知识，还有各方面的综合软实力，对于技术能力可能并不是企业关注的重点，但技术仍可能也是衡量一个人学习能力的一个重要指标，至少我认为。</p><p>说了那么多，还是简单的列一下计划吧：</p><ul><li>抓紧时间弄几个有技术含量的项目，首先是巩固自己的知识，其次计算机本来就是实践出真知的一门学科，Coding是最基础的。尽量挖掘技术深度，这是一个区别于大数人的好办法，熟练精通某项技能是有必要的，而不是单纯的了解一些东西。</li><li>结果才是反映能力的核心，做事尽量以结果为导向，有明确的目标才更容易坚持，过程啥的自己体会就够了。经常给自己一些正反馈，小小的成就感是很有必要的，尝试一些小的东西并做到完美，给自己一些正反馈会更加有动力。</li><li>适当的压力是有必要的，经常做一些To Do List不仅可以提高效率还可以驱动自己，我现在已经开始了TWIL计划，记录每周所学，另外还计划每周至少一篇技术文章，花费一些时间，坚持做一件小事。</li><li>警惕注意力劫持，这是最近了解到的一个词语，说的是很多信息流劫持了我们的注意力，会导致工作效率下降。所以应该注意这一点，自己的计划是主动屏蔽一些不相关的信息流，控制自己的好奇清晰，减少刻意强迫的行为。</li></ul><p>这是写在秋招之前的一篇小的总结，也安排了一些适当的计划。希望自己可以身体力行，做事时能够沉得下心，多一些专注力，一步一个脚印的来。保持积极良好的心态，秋招加油！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;接近八月中旬，秋招也陆陆续续的开始了。回想自己的春招经历，也是惨目忍睹，由于缺乏准备和自身能力的欠缺，错失了很多很好的机会。春招的试错，为秋招的准备提供了一个很好的指导，通过自己近段时间的学习和查缺补漏，技术栈和基础知识都得到了提升和巩固。但面对秋招，我觉得还是有很大的欠缺，下面就总结一下自己近段时间所学以及要努力提升的东西。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔集" scheme="http://smallseven.top/categories/%E9%9A%8F%E7%AC%94%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>Java Web开发入门总结篇</title>
    <link href="http://smallseven.top/2019/07/24/2019-07-24-learn-spring/"/>
    <id>http://smallseven.top/2019/07/24/2019-07-24-learn-spring/</id>
    <published>2019-07-24T14:41:07.000Z</published>
    <updated>2019-08-12T03:21:36.129Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java-Web-相关概念"><a href="#Java-Web-相关概念" class="headerlink" title="Java Web 相关概念"></a>Java Web 相关概念</h3><p>在Java开发中很多概念性的名词，对于一个开发人员来说，是有必要了解它们的基本概念和含义的，要不然在看一些技术文章时会很懵，或者会混淆一些基础概念性的东西。就此，我对自己所理解的一些概念性的东西进行简单的梳理。</p><a id="more"></a><p><strong>Java EE</strong>：(Java Platform Enterprise Edition)是Java面向企业应用的一个平台，类似于一种标准规范，就目前的各种表达如J2EE，JavaEE，JEE其实说的都是同一个东西。JavaEE 比JavaSE (Java Platform, Standard Edition)增加面向企业的开发支持，包括Servlet，WebSocket，EL，EJB 等。</p><p><strong>Servlet</strong>：是Web开发离不开的组件，Servlet 是一套用于处理 HTTP 请求的 API 标准，也可以理解为运行在Server端的小程序，用于响应客户端的HTTP请求。和Servlet对应的有一个Applet，这是运行于客户端的一种小程序组件，主要应用于web浏览器端。</p><p>另外，不得不提的是<strong>JSP</strong>（Java Server Pages），它是一种高度抽象的Servlet，JSP在运行期间会被编译成Servlet，其实本质上Servlet和JSP没啥区别，但JSP写起来要方便的多。</p><p><strong>EJB</strong>： （Enterprise JavaBean）也是JavaEE的一个组件，面向更加复杂的企业业务，对于Web开发来说，EJB不是必须的。对于上面提到的Servlet，如果要运行的话需要Servlet Container，而常用的Container包括Tomcat，JBoss，Jetty等。对于EJB而言，同一样也需要EJB Container，JBoss提供了EJB的支持，但Tomcat并不支持EJB。</p><p><strong>SSH</strong>：（Struts+Spring +Hibernate）是一个Java Web开发的合成框架。Struts进行流程控制，Spring进行业务流转，Hibernate进行数据库操作的封装。事实上JavaEE开发可以仅使用Servlet和JSP技术，在JSP上构建View，实现业务逻辑。但随着技术的进步和发展，纯JSP技术可能并不能满足业务需求和开发效率的要求，所以衍生了一些列如SSH的结合框架。</p><p>Struts更多的是面向JSP和View，而Spring则是一个非常庞大的框架，其中包括了SpringMVC，SpringBoot 以及 SpringCloud 等用于 Web 开发的工具。而Hibernate则是一种ORM框架，是一种对象关系映射关系，简化了数据的处理和访问。</p><p><strong>SSM</strong>：（Spring+SpringMVC+MyBatis）同样是一个Java Web开发的合成框架，是标准的MVC模式，将整个系统划分为表现层，controller层，service层，dao层四层。Spring实现业务对象管理，Spring MVC负责请求的转发和视图管理，MyBatis作为数据对象的持久化引擎。</p><p>至此，关于Java Web开发的一些概念词汇大致梳理了一遍，但都没有详细讲解它们的基本原理和架构，这需要在具体的实践中去体验。另外需要注意的是区分JavaEE，Java Web，Spring它们的关系，<strong>JavaEE可以理解为是一种Java的标准，而Java Web则是指Java的应用开发方向，而Spring则是Java Web开发的框架。</strong></p><h3 id="Spring-框架模块"><a href="#Spring-框架模块" class="headerlink" title="Spring 框架模块"></a>Spring 框架模块</h3><p><strong>Spring有七大功能模块，分别是Spring Core，AOP，ORM，DAO，WEB，Context，MVC。</strong></p><p><img src="https://s2.ax1x.com/2019/07/25/eZjFC4.gif" alt="spring"></p><p>每个模块的作用如下：</p><ul><li><p><strong>核心容器（Spring Core）</strong>：核心容器提供 Spring 框架的基本功能。核心容器的主要组件是 BeanFactory，它是工厂模式的实现。BeanFactory 使用<em>控制反转</em> （IoC） 模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。</p></li><li><p><strong>Spring AOP</strong>：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功能集成到了 Spring 框架中。所以，可以很容易地使 Spring 框架管理的任何对象支持 AOP。Spring AOP 模块为基于 Spring 的应用程序中的对象提供了事务管理服务。通过使用 Spring AOP，不用依赖 EJB 组件，就可以将声明性事务管理集成到应用程序中。</p></li><li><p><strong>Spring DAO</strong>：JDBC DAO 抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向 JDBC 的异常遵从通用的 DAO 异常层次结构。</p></li><li><p><strong>Spring ORM</strong>：Spring 框架插入了若干个 ORM 框架，从而提供了 ORM 的对象关系工具，其中包括 JDO、Hibernate 和 iBatis SQL Map。所有这些都遵从 Spring 的通用事务和 DAO 异常层次结构。</p></li><li><p><strong>Spring Context</strong>：Spring 上下文是一个配置文件，向 Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如 JNDI、EJB、电子邮件、国际化、校验和调度功能。</p></li><li><p><strong>Spring Web 模块</strong>：Web 上下文模块建立在应用程序上下文模块之上，为基于 Web 的应用程序提供了上下文。所以，Spring 框架支持与 Jakarta Struts 的集成。Web 模块还简化了处理多部分请求以及将请求参数绑定到域对象的工作。</p></li><li><p><strong>Spring MVC 框架</strong>：MVC 框架是一个全功能的构建 Web 应用程序的 MVC 实现。通过策略接口，MVC 框架变成为高度可配置的，MVC 容纳了大量视图技术，其中包括 JSP、Velocity、Tiles、iText 和 POI。</p></li></ul><p><strong>Ioc Container</strong>：反转控制模式它是Spring的一个基础，也是最重要的。它不创建对象，但是描述创建对象的方式，在代码中也不直接与对象和服务连接，但在配置文件中描述了哪一个组件需要哪一项服务。在Spring框架中，IoC容器的实现模式主要有两种是：</p><ol><li>通过JavaBean属性（例如 setter 方法）分配依赖性。</li><li>依赖性以构造函数的形式提供，不以JavaBean 属性的形式公开。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**IoC容器创建 HelloWorldService 对象，是通过 setter 方法传递 HelloWorld 对象到HelloWorldService。**/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldService</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> HelloWorld helloWorld;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HelloWorldService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依赖注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHelloWorld</span><span class="params">(HelloWorld helloWorld)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.helloWorld = helloWorld;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloWorld <span class="title">getHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.helloWorld;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><p>Spring web MVC框架提供了MVC(模型 - 视图 - 控制器)架构和用于开发灵活和松散耦合的Web应用程序的组件。 MVC模式导致应用程序的不同方面(输入逻辑，业务逻辑和UI逻辑)分离，同时提供这些元素之间的松散耦合。</p><ul><li>模型(Model)封装了应用程序数据，通常它们将由<code>POJO</code>类组成。</li><li>视图(View)负责渲染模型数据，一般来说它生成客户端浏览器可以解释HTML输出。</li><li>控制器(Controller)负责处理用户请求并构建适当的模型，并将其传递给视图进行渲染。</li></ul><p>模型 - 视图 - 控制器(MVC)框架是围绕DispatcherServlet设计的，它处理所有的HTTP请求和响应。</p><p><img src="https://s2.ax1x.com/2019/07/25/eZjk8J.png" alt="DispatcherServlet"></p><p><strong>DispatcherServlet</strong>的请求处理工作流：</p><ol><li><p>在接收到HTTP请求后，DispatcherServlet会查询HandlerMapping以调用相应的Controller。</p></li><li><p>Controlle接受请求并根据使用的<code>GET</code>或<code>POST</code>方法调用相应的服务方法。 服务方法将基于定义的业务逻辑设置模型数据，并将视图名称返回给DispatcherServlet。</p></li><li>DispatcherServlet将从ViewResolver获取请求的定义视图。</li><li>当视图完成，DispatcherServlet将模型数据传递到最终的视图，并在浏览器上呈现。</li></ol><h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><p>SpringBoot 是构建在 SpringMVC 基础上的新一代 Web 开发框架。相比 SpringMVC，SpringBoot 的配置更简单，上手更容易。在纯的Spring MVC配置中，要启动一个web程序demo，需要进行很多配置，包括一些复杂的Annotation，Controller是需要理解和明白的。但是在Spring Boot中，减少了大量的配置，提供了一种简单应用程序入门的方式。</p><p>Spring Boot会根据使用<code>@EnableAutoConfiguration</code>批注添加到项目中的依赖项自动配置应用程序。spring boot应用程序的入口点是包含<code>@SpringBootApplication</code>注释和<code>main</code>方法的类。<br>Spring Boot使用<code>@ComponentScan</code>注释自动扫描项目中包含的所有组件。为了更好的适应包扫描机制，避免一些特殊的配置工作，可以参考下面的工程结构。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">com</span><br><span class="line">  +- example</span><br><span class="line">    +- myproject</span><br><span class="line">      +- Application.java</span><br><span class="line">      |</span><br><span class="line">      +- domain</span><br><span class="line">      |  +- Customer.java</span><br><span class="line">      |  +- CustomerRepository.java</span><br><span class="line">      |</span><br><span class="line">      +- service</span><br><span class="line">      |  +- CustomerService.java</span><br><span class="line">      |</span><br><span class="line">      +- web</span><br><span class="line">      |  +- CustomerController.java</span><br><span class="line">      |</span><br></pre></td></tr></table></figure><ul><li><p><code>root package</code>：<code>com.example.myproject</code>，所有的类和其他package都在root package之下。</p></li><li><p>应用主类：<code>Application.java</code>，该类直接位于<code>root package</code>下。通常我们会在应用主类中做一些框架配置扫描等配置，我们放在root package下可以帮助程序减少手工配置来加载到我们希望被Spring加载的内容</p></li><li><p><code>com.example.myproject.domain</code>包：用于定义实体映射关系与数据访问相关的接口和实现</p></li><li><p><code>com.example.myproject.service</code>包：用于编写业务逻辑相关的接口与实现</p></li><li><p><code>com.example.myproject.web</code>：用于编写Web层相关的实现，比如：Spring MVC的Controller等</p></li></ul><p><strong>使用IDEA Spring Boot工程的两种方法</strong></p><ol><li><p>使用Maven构建项目：通过访问<a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a> 生成一个基础项目下载解压，用IDE 以Maven项目导入。</p></li><li><p>使用Intellij IDEA中的Spring Initializr工具，直接创建生成。</p></li></ol><h3 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h3><p>以上就是我关于Java Web，以及Spring框架的了解，至于Spring Cloud还没来得及去仔细学习，最开始自己是使用Eclipse构建项目，觉得Eclipse是世界上最好的IDE，但自从入坑Java web项目后，需要配置Tomcat，编写Servlet和JSP，进行各种Annotation以及SSH和SSM环境的搭建，真的是太麻烦了，常常在深夜红着眼睛和各种配置BUG做斗争，也时常因为环境配置问题而导致心态奔溃选择了放弃。但自从使用了IDEA，使用了Spring Boot，搭建应用分分钟搞定，再也不会因为环境配置的问题而烦恼，终于可以快乐地写代码了，于是我就已经知道我再也回不到Eclipse时代了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java-Web-相关概念&quot;&gt;&lt;a href=&quot;#Java-Web-相关概念&quot; class=&quot;headerlink&quot; title=&quot;Java Web 相关概念&quot;&gt;&lt;/a&gt;Java Web 相关概念&lt;/h3&gt;&lt;p&gt;在Java开发中很多概念性的名词，对于一个开发人员来说，是有必要了解它们的基本概念和含义的，要不然在看一些技术文章时会很懵，或者会混淆一些基础概念性的东西。就此，我对自己所理解的一些概念性的东西进行简单的梳理。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://smallseven.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>Hash-Map-HashMap</title>
    <link href="http://smallseven.top/2019/07/19/2019-07-19-hash-map/"/>
    <id>http://smallseven.top/2019/07/19/2019-07-19-hash-map/</id>
    <published>2019-07-19T03:02:45.000Z</published>
    <updated>2019-07-19T03:40:35.306Z</updated>
    
    <content type="html"><![CDATA[<p>在平时coding时虽然经常会用到<code>HashMap</code>，但没有仔细思考它的实现原理，也常常将<code>HashTable</code>，<code>HashMap</code>，<code>TreeMap</code>等概念特性混淆，最主要原因是不太理解它们的底层逻辑，后面仔细思考了一下，发现自己竟然分不太清Hash和Map，后面查了一些资料，总算是弄明白了一些，记录一下。</p><a id="more"></a><h3 id="Hash是啥？"><a href="#Hash是啥？" class="headerlink" title="Hash是啥？"></a>Hash是啥？</h3><p><code>Hash又</code>称散列，它表示的是通过一个输入值，通过装换算法输出一个对应的值，这个装换算法是一种映射关系，又叫做<code>Hash函数</code>，hash函数能够使对一个数据的访问过程更加有效，通过hash函数，数据元素可以快速的被定位。hash算法也并不是唯一的，在不同的应用中有不同的hash算法，比如常见的的<code>FNK</code>算法，<code>CRC</code>系列算法，<code>MD5</code>，<code>SHA-1</code>等。</p><h3 id="HashTable是啥？"><a href="#HashTable是啥？" class="headerlink" title="HashTable是啥？"></a>HashTable是啥？</h3><p><code>HashTable</code>是hash函数的一个主要应用，使用散列表能够快速的查找数据记录，是一种可以根据键值对直接访问的数据结构，它通过把关键码映射到表中的一个位置来访问记录，从而加快了查找的速度，<code>HashTable</code>是数组和链表的结合，使用Hash函数将被查找的键转化为数组的索引，然后根据索引就可以定位到数据记录，当然在进行转化时会发生hash冲突，如果单桶存储的数据条目过多，将会导致性能下降，这时候就需要考虑是否要使用rehash方法进行扩容了。</p><h3 id="Map是啥？"><a href="#Map是啥？" class="headerlink" title="Map是啥？"></a>Map是啥？</h3><p><code>Map</code>是一种关联容器，它提供了一对一的数据处理能力，这与上面所述的hash好像是一个东西，但其实并非这样，在网上也很难找到这两者的具体定义和区别，我个人理解的是Hash更强调的是一种算法，而<code>Map</code>则是一种数据结构（容器），维基百科中是这样定义Map的：</p><blockquote><p> <strong>map</strong>：In computer science, an associative array, map, symbol table, or dictionary is an abstract data type composed of a collection of (key, value) pairs, such that each possible key appears at most once in the collection.</p></blockquote><p>在C++的STL中<code>Map</code>是一个标准容器，在Java中<code>Map</code>是定义的一个接口，我们常用的<code>HashMap</code>，<code>LinkedHashMap</code>都实现了该接口。</p><h3 id="HashMap是啥？"><a href="#HashMap是啥？" class="headerlink" title="HashMap是啥？"></a>HashMap是啥？</h3><p><code>HashMap</code>存储数据采用的是散列表结构（数组+链表的结构），在JDK8中<code>HashMap</code>的底层数据结构已经变为数组+链表+红黑树的结构，这主要原因是为了减少之前提到的hash冲突带来的影响。</p><p><strong><code>HashMap</code>的基本原理</strong>是散列表+拉链法，就是在往<code>HashMap</code>中put元素时，会先根据key的hash值得到这个元素在数组中的位置（即下标），然后把这个元素放到对应的位置中。如果这个元素所在的位子上已经存放有其他元素了，那么在同一个位子上的元素将以链表的形式存放，新加入的放在链头，最先加入的放在链尾。</p><p>实际情况下，我们希望HashMap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素是我们想要元素，而不用再去遍历链表。最容易的做法就是把hashcode对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是“模”运算的消耗是比较大的，在Java中选择了另外一种更快速，消耗更小的方式：<strong>首先算得key得hashcode值，然后跟数组的长度-1做一次“与”运算（&amp;）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>HashMap</code>中get()方法的执行过程是：首先计算key的<code>hashcode</code>，找到数组中对应位置的某一元素，然后通过key的equals方法在对应位置的链表中找到需要的元素。所以<code>hashcode</code>与<code>equals</code>方法是找到对应元素的两个关键方法，通过改写key对象的<code>equals</code>和<code>hashcode</code>方法，我们就可以将任意的业务对象作为map的key。在判断两个对象是否真的相等时，必须保证它们的<code>hashcode</code>相同，且保证调用 <code>equals()</code>方法返回true。</p><h3 id="TreeMap是啥？"><a href="#TreeMap是啥？" class="headerlink" title="TreeMap是啥？"></a>TreeMap是啥？</h3><p><code>TreeMap</code>在存储数据时是安装特定顺序存储的，并非像<code>HashMap</code>那样无明显顺序，最主要的原因是其底层原理不同，<code>TreeMap</code>的本质是红黑树，红黑树理解起来是比较复杂的，在此就不做展开了。</p><h3 id="补充1：HashMap扩容"><a href="#补充1：HashMap扩容" class="headerlink" title="补充1：HashMap扩容"></a>补充1：HashMap扩容</h3><p>在JDK7中，<code>HashMap</code>数据结构是数组+链表的方式，<code>HashMap</code>内存储数据的Entry数组默认是16，如果没有对Entry扩容机制的话，当存储的数据一多，Entry内部的链表会很长，这就失去了<code>HashMap</code>的存储意义了，所以<code>HasnMap</code>内部有扩容机制来进行处理。</p><p>在<code>HashMap</code>内部有：变量size，记录<code>HashMap</code>的底层数组中已用槽的数量；变量threshold，它是<code>HashMap</code>的阈值，用于判断是否需要调整<code>HashMap</code>的容量（threshold = 容量*加载因子）；变量DEFAULT_LOAD_FACTOR = 0.75f，默认加载因子为0.75。</p><p><code>HashMap</code>扩容的条件是：当size大于threshold时，对<code>HashMap</code>进行扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//举个例子假如现在有三个元素（3,5,7）要放入map里面，table的的容量是2，如下</span></span><br><span class="line">[<span class="number">0</span>]=<span class="keyword">null</span>  </span><br><span class="line">[<span class="number">1</span>]=<span class="number">3</span>-&gt;<span class="number">5</span>-&gt;<span class="number">7</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">//现在将table的大小扩容成4，分布如下：</span></span><br><span class="line">[<span class="number">0</span>]=<span class="keyword">null</span>  </span><br><span class="line">[<span class="number">1</span>]=<span class="number">5</span>-&gt;<span class="number">7</span>  </span><br><span class="line">[<span class="number">2</span>]=<span class="keyword">null</span>  </span><br><span class="line">[<span class="number">3</span>]=<span class="number">3</span></span><br></pre></td></tr></table></figure><p>在JDK8里面，<code>HashMap</code>的底层数据结构已经变为数组+链表+红黑树的结构了，因为在hash冲突严重的情况下，链表的查询效率是O(n），所以JDK8做了优化对于单个链表的个数大于8的链表，会直接转为红黑树结构算是以空间换时间，这样以来查询的效率就变为O(logN)。</p><p>简单总结就是，JDK7里面是先判断table的存储元素的数量是否超过当前的<code>threshold=table.length*loadFactor（默认0.75）</code>，如果超过就先扩容，在JDK8里面是先插入数据，插入之后在判断下一次<code>++size</code>的大小是否会超过当前的阈值，如果超过就扩容。 </p><h3 id="补充2：区别Collection和Map"><a href="#补充2：区别Collection和Map" class="headerlink" title="补充2：区别Collection和Map"></a>补充2：区别Collection和Map</h3><p>Collection 和Map 是Java容器类库的两种主要类型，最主要的区别在于Collection保存的是单个元素，而Map保存的是一个键值对。</p><p>下面例子展示了一些基本类型的容器，第一个 fill() 可以用于所用类型的Collection，这些类型都实现了用来添加新元素的 add() 方法。而第二个 fill()  使用与Map，它们都实现了添加键值对的 put()  方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="comment">// 容器的打印</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintingContainers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Collection <span class="title">fill</span><span class="params">(Collection&lt;String&gt; collection)</span></span>&#123;</span><br><span class="line">        collection.add(<span class="string">"rat"</span>);</span><br><span class="line">        collection.add(<span class="string">"cat"</span>);</span><br><span class="line">        collection.add(<span class="string">"dog"</span>);</span><br><span class="line">        collection.add(<span class="string">"dog"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> collection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> Map <span class="title">fill</span><span class="params">(Map&lt;String, String&gt; map)</span></span>&#123;</span><br><span class="line">        map.put(<span class="string">"rat"</span>, <span class="string">"Fuzzy"</span>);</span><br><span class="line">        map.put(<span class="string">"cat"</span>, <span class="string">"Rags"</span>);</span><br><span class="line">        map.put(<span class="string">"dog"</span>, <span class="string">"Bosco"</span>);</span><br><span class="line">        map.put(<span class="string">"dog"</span>, <span class="string">"Spot"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="comment">// List 类型</span></span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> ArrayList&lt;String&gt;()));</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> LinkedList&lt;String&gt;()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set 类型</span></span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> HashSet&lt;String&gt;()));</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> TreeSet&lt;String&gt;()));</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> LinkedHashSet&lt;String&gt;()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Map 类型</span></span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> HashMap&lt;String, String&gt;()));</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> TreeMap&lt;String, String&gt;()));</span><br><span class="line">        System.out.println(fill(<span class="keyword">new</span> LinkedHashMap&lt;String, String&gt;()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ArrayList</code> 和 <code>LinkedList</code> 都是List类型，都是按照插入了顺序保存元素，<code>ArrayList</code>可以理解为动态数组，<code>LinkedList</code>可以理解为链表，两者最主要的区别在于执行某些类型的操作时的性能。</p><p><code>HashSet</code>，<code>TreeSet</code> 和<code>LinkedHashSet</code>都是Set类型，在Set类型中每个元素只不留一次，不会出现相同的项，它们的一个主要区别是存储元素的方式不同，<code>HashSet</code>是以散列的形式保存元素，所以是无序的，而<code>TreeSet</code>是以树的形式存储数据，是按照一定的顺序要求保存的。而LinkedHashSet则是按照添加的顺序保存对象的。</p><p><code>HashMap</code>，<code>TreeMap</code>和<code>LinkedHashMap</code>都是Map类型，保存都是键值对（key—value），<code>HashMap</code>没有按照任何明显的顺序来保存其元素，但查找效率是比较快的，它有自己的算法来控制顺序，<code>TreeMap</code>则是按照某种特定顺序来保存键的，<code>LinkedHashMap</code>则是按照插入顺序保存键，并且保存了<code>HashMap</code>的查询速度。</p><p><strong>Tips：</strong></p><p> <strong>1、越底层的东西越复杂,当然也越有用！2、专业的书比网上的资料更全面更详细。3、好奇心和求知欲是第一驱动力。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在平时coding时虽然经常会用到&lt;code&gt;HashMap&lt;/code&gt;，但没有仔细思考它的实现原理，也常常将&lt;code&gt;HashTable&lt;/code&gt;，&lt;code&gt;HashMap&lt;/code&gt;，&lt;code&gt;TreeMap&lt;/code&gt;等概念特性混淆，最主要原因是不太理解它们的底层逻辑，后面仔细思考了一下，发现自己竟然分不太清Hash和Map，后面查了一些资料，总算是弄明白了一些，记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://smallseven.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="http://smallseven.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>VMware-Linux</title>
    <link href="http://smallseven.top/2019/07/11/2019-07-11-vmware-linux/"/>
    <id>http://smallseven.top/2019/07/11/2019-07-11-vmware-linux/</id>
    <published>2019-07-11T02:16:34.000Z</published>
    <updated>2019-07-11T12:59:50.814Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>对于Linux系统，现在基本上属于能够熟练使用常用命令，做一些配置的水平，还是不太熟悉其开发，对于底层原理也不是很了解，自己使用Linux系统主要是VMware安装的Ubuntu，和阿里云的CentOS，这篇文章主要记录一下使用Ubuntu的一些操作，熟悉的就不赘述，记录一些我自己不熟的。</p><a id="more"></a><h3 id="0x01-安装使用"><a href="#0x01-安装使用" class="headerlink" title="0x01 安装使用"></a>0x01 安装使用</h3><p>想要使用Linux 系统，可以安装虚拟机，然后安装Linux系统（Ubuntu还不错）。</p><p>1、首先安装 VMware，找到安装包，不需要啥配置，傻瓜式操作。</p><p><img src="https://s2.ax1x.com/2019/07/11/Z2kVyR.md.png" alt="img"></p><p>安装好，就可以安装系统了，这时候需要一个系统镜像，也很容易找到，可以安装Ubuntu，CentOS，看自己需求吧。</p><p>2、这时候就需要一些配置了，包括安装路径，给系统进行个性化配置以及分配存储空间，按照安装向导弄就成了，这个安装可能需要一点时间。</p><p><img src="https://s2.ax1x.com/2019/07/11/Z2kQYD.md.png" alt="img"></p><p>安装好就使用之前设置的用户和密码登录就成了。这前我安装过VMware，也安装过Ubuntu系统，不知道什么原因用着有点卡，而且联网也总是出问题，体验不是很好，这次重新安装了一下，感觉好用了很多，所以如果发现软件不好用，卸载重装可能也是一种解决办法吧。</p><p>要是想联网的话把网络适配改成桥接模式（主机和虚拟使用同一IP）。</p><h3 id="0x02-常用命令"><a href="#0x02-常用命令" class="headerlink" title="0x02 常用命令"></a>0x02 常用命令</h3><p>总结一些Linux常用命令，主要是这前不太熟悉的：</p><p>可以通过查找打开终端，也可以使用快捷键 <code>ctrl+alt+T</code>打开。</p><p>查看主机名：<code>hostname</code></p><p>查看IP信息：<code>ifconfig</code></p><p>查看网络端口：<code>netstat -ntlp</code></p><p>查看CPU信息：<code>cat /proc/cpuinfo</code></p><p>查看进程信息：<code>ps aux</code></p><p>使用<code>ps aux |grep xxx</code>可以过滤</p><p>结束某个进程：<code>kill -9</code> 进程ID</p><p>查看目录文件详细信息：<code>ls -al</code></p><p>(cdl)rwx r-x r-x 文件相关权限显示的标识</p><p>创建一个文件：<code>touch filename</code></p><p>可以使用vi 进行编辑，也可以使用gedit 命令编辑，当然有些目录或文件是有权限限制的，可以使用sudo 来进行一些操作。</p><p>查看文件详细信息可以使用 <code>file filename</code></p><p>删除文件 <code>rm</code></p><p>删除目录<code>rm rf</code></p><p>查找文件：<code>find ./ -name filename</code>（find 查找目录 文件名）</p><p>也可以进行匹配查找：<code>find ./ -name *.c</code></p><p>安装软件可以是使用：<code>sudo apt-get install</code>软件名</p><p>比如安装git，可以使用<code>sudo apt-get install git</code></p><h3 id="0x03-源码安装"><a href="#0x03-源码安装" class="headerlink" title="0x03 源码安装"></a>0x03 源码安装</h3><p>源码编译安装nginx 并进行相关配置</p><p>首先去官网下载源码安装，安装包很小，很快就能下载好。</p><p>然后进行解压</p><p><code>tar -zxvf nginx-1.17.1.tar.gz</code></p><p>这是直接解压到当前目录下，也可以指定解压目录。</p><p>进入解压好的目录里cd nginx-1.17.1/ 可以查看到一个configure 文件，在这个目录下执行configure文件：<code>./ configure --prefix=/usr/local/nginx</code>并指定安装的路径，这里表示安装在local/nginx路径下。运行时可能会报错说缺少一些模块，可以根据实际情况添加或或者不添加，在运行命令后追加配置，重新执行就行。</p><p><img src="https://s2.ax1x.com/2019/07/11/Z2kEl9.png" alt="img"> </p><p>然后编译nginx，使用make命令，这里make会查找执行Makefile文件。（Makefile 定义整个工程的编译规则，可实现自动化编译，make命令是解释Makefile中的指令）。</p><p>编译完成后可以使用<code>make install</code>进行安装，安装完成后就可以在之前设置的目录里看到用nginx的文件。</p><p><img src="https://s2.ax1x.com/2019/07/11/Z2kmex.md.png" alt="img"></p><p>到此位置nginx就编译安装成功了，但为了使用nginx方便一些，我们可以配置环境或者是设置软连接，就可以直接通过 nginx命令来启用后禁用服务器了。</p><p>配置环境变量<code>sudo gedit /etc/profile</code></p><p>将你的解解压好的目录添加进去</p><p><code>export PATH=&quot;$PATH:/usr/local/nginx/sbin&quot;</code></p><p>设置软连接，其实就将一个文件下的文件连接到另一个文件夹，达到简化切换目录的麻烦。</p><p><code>ln -s /usr/local/nginx/sbin/nginx /usr/bin/nginx</code></p><p>配置好以后就可以使用nginx了。</p><p>使用<code>sudo nginx</code>启动nginx，使用<code>sudo nginx -s stop</code>命令关闭nginx。</p><p>可以测试一下：nginx 默认端口是80，在浏览器中输入localhost:80</p><p><img src="https://s2.ax1x.com/2019/07/11/Z2kASJ.png" alt="img"></p><h3 id="0x04-交叉编译"><a href="#0x04-交叉编译" class="headerlink" title="0x04 交叉编译"></a>0x04 交叉编译</h3><p>交叉编译器（Linux Ubuntu编译程序–在开发板上运行）</p><p>下载安装包</p><p>解压/解压路径（设置路径 -C 要大写）</p><p><code>sudo tar jxvf  XXXXXX  -C /usr/local/</code></p><p>配置环境变量<code>sudo gedit /etc/profile</code></p><p>将你的解解压好的目录添加进去</p><p><code>export PATH=&quot;$PATH:/usr/local/arm-2009q3/bin&quot;</code></p><p><img src="https://s2.ax1x.com/2019/07/11/Z2kZO1.md.png" alt="img"></p><p> 测试一下看成不成，或者直接使用env命令 查看环境变量有没有配好</p><p><code>env |grep PATH</code></p><p>如果没有的话，使用source让它立刻生效</p><p><code>source /etc/profile</code></p><p>现在应该就可以</p><p><img src="https://s2.ax1x.com/2019/07/11/ZRJEHf.md.png" alt="img"></p><p>在用户目录下创建一个.c 文件，可以先用gcc 编译一哈。比如 <code>gcc hello.c -o hello</code></p><p>现在使用arm 编译一哈，就成了</p><p><code>arm-none-linux-gnueabi-gcc hello.c -o arm_hello</code></p><p><img src="https://s2.ax1x.com/2019/07/11/Z2kMFO.png" alt="img"></p><p>然后就生成了两个版本的执行程序了。</p><p><img src="https://s2.ax1x.com/2019/07/11/Z2knw6.md.png" alt="img"></p><p><img src="https://s2.ax1x.com/2019/07/11/Z2kuTK.md.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;对于Linux系统，现在基本上属于能够熟练使用常用命令，做一些配置的水平，还是不太熟悉其开发，对于底层原理也不是很了解，自己使用Linux系统主要是VMware安装的Ubuntu，和阿里云的CentOS，这篇文章主要记录一下使用Ubuntu的一些操作，熟悉的就不赘述，记录一些我自己不熟的。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://smallseven.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="linux" scheme="http://smallseven.top/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Embedded-Hardware</title>
    <link href="http://smallseven.top/2019/07/11/2019-07-11-embedded-hardware/"/>
    <id>http://smallseven.top/2019/07/11/2019-07-11-embedded-hardware/</id>
    <published>2019-07-11T02:16:10.000Z</published>
    <updated>2019-07-11T12:49:27.505Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>终于有时间了，整理一下嵌入式硬件的东西，在过去的一个学期里选修了嵌入式课程，然后相对完整的了解了嵌入式开发过程，咱物联网专业比较好的一点就是可以结合软硬件，都可以了解，上学期还做了一些WSN ZigBee，RFID 的实验，当时觉得用不到，没想到，这次实训竟然也做嵌入式开发，也使用了ZigBee模块完成一些功能，感觉所有东西并不是绝对没用，多了解一点总是好的。</p><a id="more"></a><h3 id="0x01-嵌入式入门"><a href="#0x01-嵌入式入门" class="headerlink" title="0x01 嵌入式入门"></a>0x01 嵌入式入门</h3><p>关于硬件的东西，之前几乎是从来没有接触，完全不懂什么SOC，也不知道什么MCU，更别说是做开发了，之前唯一对硬件感兴趣的就是树莓派，听说是一块很不错的板子，但由于各种情况，也没有入坑。知道这个学期选了嵌入式，然后因为要完成实验所以入坑了一块EK-TM4C123GXL 开发板，麻雀虽小五脏俱全，这块板子基本能够满足所有嵌入式的基本开发，用来学习还是很不错的。</p><p>关于硬件的学习，其实最主要还是要了解硬件资源，熟悉硬件提供的功能，包括GPIO，时钟，中断等，这些都是最基本的，另外就是一些ADC，DAC，时钟频率，高低电平，这些也是要十分熟悉才行。硬件开发有很多东西是记不住的，所以学会查文档很重要的，学习路线可以大致为：看文档了解硬件资源–找案例照葫芦画瓢–网上查阅资料–查开发文档；有些东西不用刻意去记，用的时候去查就行。但构建思路，开发步骤是需要明确的，比如说要使用GPIO时要初始化寄存器，使用模块功能时要考虑时钟的影响，使用中断时要了解如何调用中断处理函数，如果有要连接传感器的话，还要参考传感器的资料，了解其电气特性等。总之，查资料，阅读资料，理解资料在硬件开发中尤为重要。</p><h3 id="0x02-实训硬件开发"><a href="#0x02-实训硬件开发" class="headerlink" title="0x02 实训硬件开发"></a>0x02 实训硬件开发</h3><p>实训时使用的是CC2530，搭载了ZigBee模块，在开发中都是使用IAR软件，刚好和我们wsn实验ZigBee联系上了，不过我们在wsn实验中我只使用了ZigBee协议栈组网通信，而这次我是利用ZigBee通信来控制硬件功能，而硬件功能实现就是需要嵌入式开发的知识了，刚好把所学内容进行了结合，在嵌入式开发中，不同的硬件资源可能开发就有所不同，但大多数底层逻辑是相同的，所以重点是理解思路。但嵌入式开发仍然有很多烦人的问题，这些Bug出现的原因各种各样，有的是硬件本身故障，有的程序错误，甚至可能的电路连接错误，所以在开发中遇到Bug，排查问题方式方法很关键，我个人认为先从硬件开始检查，最后再检查软件程序，逐层排查是一个相对较好的思路。</p><p>当将嵌入式硬件和网络连接起来后，功能开始就更强大了，当然问题出现几率也开始变大了，在物联网传感器硬件开发中，一般使用ZigBee进行硬件组网，网络协议是单独的且复杂的，很多时候我们在开发过程中是不允许修改协议栈的，都已经封装好的，我们需要的是理解代码，了解功能实现思路，然后再做简单的自定义开发，所以读代码也物联网硬件开发需要的能力。</p><p>在硬件开发中调试是一个不得不进行的过程，而硬件开发的调试不像软件那么方便，它需要在开发板或是硬件资源中运行，这是一个比较繁琐的过程，构建，编译，烧录，运行，测试输出这是一个最基本的流程，也是一个相对花费时间的过程，所以想要提升开发效率，最好的办法是理解问题本质并细心的修改问题，而不是盲目的测试，企图用巧合来达到成功。</p><h3 id="0x03-总结"><a href="#0x03-总结" class="headerlink" title="0x03 总结"></a>0x03 总结</h3><p>本来是准备写一篇详细嵌入式硬件开发的文章，把自己使用的TM4C123GXL 开发和CC2530开发时使用的核心技术，关键代码总结一下，后面发现硬件开发这玩意儿，只要理解了解很简单，实现起来也是多变的，没有一个很固定的标准，所以也不太好总结，也没太必要，下一次遇到是查资料就行。这次在完成项目时参考了很多网上的资料，学到很多东西，比如博客园的小蜜蜂老师和csdn的Bruceoxl老师，他们的博文很全面也很详细，给了我很大的帮助，同时也挺佩服他们能够输出那么多优质内容，应该向他们学习。</p><p>写到这也要告一段落了，关于硬件嵌入式ZigBee开发，我究竟理解多少，掌握了多少，过段时间后我是否还能记起，这些都是无法量化和衡量的，只希望自己总结的方法能够适用于以后的问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;终于有时间了，整理一下嵌入式硬件的东西，在过去的一个学期里选修了嵌入式课程，然后相对完整的了解了嵌入式开发过程，咱物联网专业比较好的一点就是可以结合软硬件，都可以了解，上学期还做了一些WSN ZigBee，RFID 的实验，当时觉得用不到，没想到，这次实训竟然也做嵌入式开发，也使用了ZigBee模块完成一些功能，感觉所有东西并不是绝对没用，多了解一点总是好的。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://smallseven.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="嵌入式" scheme="http://smallseven.top/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>记录零碎技术栈</title>
    <link href="http://smallseven.top/2019/06/29/2019-06-29-tech-stack/"/>
    <id>http://smallseven.top/2019/06/29/2019-06-29-tech-stack/</id>
    <published>2019-06-29T14:28:46.000Z</published>
    <updated>2019-07-24T14:38:33.328Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>好久没有写东西做总结了，应该时时更新，日日总结，保持对新事物的好奇心，回顾所学旧的知识，融汇贯通。因为实训接触了一些新的玩意儿，如: Vuejs，Flutter, Kotlin 等，也刚好有时间，就干脆多了解一些，顺便做了一点笔记，丰富一下自己的认知。没有实际干货，也不算是技术栈，不管以后会不会深入学习，先记录一下吧。</p><a id="more"></a><h3 id="0x01-Vue-js"><a href="#0x01-Vue-js" class="headerlink" title="0x01 Vue.js"></a>0x01 Vue.js</h3><p>Vue.js 是以数据驱动和组件化思想构建的一个JavaScript MVVM库，提供了简洁和易于理解的的API，能够快速上手。</p><p>什么是MVVM（Model-View-ViewModel），简单来说就是一种设计模式，借鉴了MVC的思想，在前端页面中，将Model用纯JavaScript对象表示，View负责显示，两者做到了最大限度的分离，对于现在多功能的前端和复杂业务逻辑的后端，以及技术分工的划分，这其实是技术发展的一个必然趋势。把Model和View关联起来的就是ViewModel。ViewModel负责把Model的数据同步到View显示出来，还负责把View的修改同步回Model。对于MVVM，我们并不用关注DOM，而是直接操作JavaScript对象，去除操作DOM的繁琐步骤。</p><p>使用Vue其实就是一个定义MVVM各个组成部分的过程，可以归结为：定义View，定义Model，创建Vue实例（连接View 和Model）。目前只是做一个简单了解，要是想要更深入的了解或是使用，还得好好学习一番。下面是一个简单例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">!DOCTYPE html&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这是View--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">            &#123;&#123; message &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        // 这是Model</span></span><br><span class="line"><span class="undefined">        var exampleData = &#123;</span></span><br><span class="line"><span class="undefined">            message: 'Hello World!'</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        // 创建一个 Vue 实例或 "ViewModel"</span></span><br><span class="line"><span class="undefined">        // 它连接 View 与 Model</span></span><br><span class="line"><span class="undefined">        new Vue(&#123;</span></span><br><span class="line"><span class="undefined">            el: '#app',</span></span><br><span class="line"><span class="undefined">            data: exampleData</span></span><br><span class="line"><span class="undefined">        &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="0x01-Flutter框架"><a href="#0x01-Flutter框架" class="headerlink" title="0x01 Flutter框架"></a>0x01 Flutter框架</h3><p>Flutter 是 Google推出并开源的移动应用开发框架，开发者可以通过 Dart语言开发 App，一套代码同时运行在 iOS 和 Android平台。</p><p>之前一直没有了解和关注移动开发这一块，最近也是因为实训内容涉及到Android开发，所以特意去了解了一下。对于移动开发需要区分原生开发和跨平台技术，原生应用程序是指某一移动平台（比如iOS 和安卓）所特有的应用，使用相应平台支持的开发工具和语音，并直接调用系统提供的SDK API。比如Android原生应用就是指使用Java或Kotlin语言直接调用Android SDK开发的应用程序；而iOS原生应用就是指通过Objective-C或Swift语言直接调用iOS SDK开发的应用程序。</p><p>原生开发的优势在于速度快、性能高、可以实现复杂动画及绘制，整体用户体验好，但存在动态化和开发成本较大的问题，因此诞生了一些跨平台的动态化框架，而Flutter就是其中之一，可以看一下官网给的框架图：</p><p><img src="https://s2.ax1x.com/2019/06/29/ZlJWbn.md.png" alt="flutter"></p><p>属于一种自绘UI+原生的技术模式，性能比较好，开发效率也比较高，而且也是一种很新的框架，由Google在2017年的 I/O 大会上首次推出，至今短短两年的时间，其生态系统快速增长，相信未来发展也很值得期待。</p><p>由于目前Flutter仍处于快速发展的阶段，其应用场景的资讯和参考资料并不是很多，想要深入了解可以通过官网和源码等渠道进行学习，包括Dart 语言，这些对于我个人来说都是很陌生的东西，现在发现可以学习的东西太多了，需要学习的东西也很多，保持一颗好奇心，不断去尝试，技术人就是要不断学习的。</p><h3 id="0x02-Kotlin-语言"><a href="#0x02-Kotlin-语言" class="headerlink" title="0x02 Kotlin 语言"></a>0x02 Kotlin 语言</h3><p>是一种在 Java 虚拟机上运行的静态类型编程语言，被称之为 Android 世界的Swift，由 JetBrains 设计开发并开源。Kotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。</p><p>在Google I/O 2017中，Google 宣布 Kotlin 成为 Android 官方开发语言，主要原因可能还是因为Google 和 Oracle 的官司纠纷，导致Google不得不推出Kotlin，当然作为Android开发的核心语言Java，在未来的发展中依然具有巨大影响力。</p><p>另外值得一提的是Oracle公司，近些年对于开源界并不友好，收购了Sun公司（Java，MySQL），开源社区因为担心MySQL被闭源，另外维护了MariaDB作为其分支，之前在数据库课程实验时使用的就是MariaDB，因此顺便了解了Sun公司及其整个发展历程，从兴起到巅峰再到衰亡，也是十分感叹，信息技术行业真的是一个不断更新变换的行业，无论是技术还是产业，整个生态都是快节奏的，真的需要把握时机，顺应变换，更新迭代，否则将会被淘汰。</p><p>对于开源，在计算机行业也只有在计算机行业才能实现和发展的，这是一种行业特性，对于传统行业是无法做到的，开源是一种精神，开源不等于免费，知识产权也是需要保护，在现实利益的趋势下，到底该如何定义开源，真的不是一两句能够说清楚的，对于开发者来讲当然应高喊开源万岁。</p><h3 id="0x03-Gradle-工具"><a href="#0x03-Gradle-工具" class="headerlink" title="0x03 Gradle 工具"></a>0x03 Gradle 工具</h3><p>Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建开源工具。面向Java应用为主。当前其支持的语言限于Java、Groovy、Kotlin和Scala，计划未来将支持更多的语言。</p><p>这个东西主要是在使用Android Studio开发应用时，发现在使用Gradle构建项目，不太清楚到底是个啥就查了一下，简单来说gradle就是一个基于JVM的构建工具，支持局部构建，支持多方式依赖管理，与ant、maven、ivy有良好的相容相关性，gradle适用于任何结构的工程。</p><h3 id="0x04-小结一下"><a href="#0x04-小结一下" class="headerlink" title="0x04 小结一下"></a>0x04 小结一下</h3><p>唉~搞计算机的要学的东西还真多啊，关于硬件嵌入式Linux的学习还没有总结呢，那个好像也很多，等下一篇更新吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;好久没有写东西做总结了，应该时时更新，日日总结，保持对新事物的好奇心，回顾所学旧的知识，融汇贯通。因为实训接触了一些新的玩意儿，如: Vuejs，Flutter, Kotlin 等，也刚好有时间，就干脆多了解一些，顺便做了一点笔记，丰富一下自己的认知。没有实际干货，也不算是技术栈，不管以后会不会深入学习，先记录一下吧。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>初识Docker与简单使用</title>
    <link href="http://smallseven.top/2019/06/17/2019-06-17-docker-study/"/>
    <id>http://smallseven.top/2019/06/17/2019-06-17-docker-study/</id>
    <published>2019-06-17T02:00:04.000Z</published>
    <updated>2019-07-13T12:19:54.954Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-容器与虚拟机"><a href="#0x00-容器与虚拟机" class="headerlink" title="0x00 容器与虚拟机"></a>0x00 容器与虚拟机</h3><p>我们用的传统虚拟机如 <code>VMware</code> ， <code>VisualBox</code> 之类的需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。</p><p>而容器技术是和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。容器技术是实现操作系统虚拟化的一种途径，可以让您在资源受到隔离的进程中运行应用程序及其依赖关系。</p><a id="more"></a><p><img src="https://s2.ax1x.com/2019/07/13/Z4tsgS.md.png" alt="img"></p><p><code>Docker</code> 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 <code>Docker</code> ，就不用担心环境问题。</p><h3 id="0x01-Docker的优势"><a href="#0x01-Docker的优势" class="headerlink" title="0x01 Docker的优势"></a>0x01 Docker的优势</h3><p><strong>Docker相比于传统虚拟化方式具有更多的优势：</strong></p><ul><li><p><code>docker</code> 启动快速属于秒级别。虚拟机通常需要几分钟去启动。<code>docker</code> 需要的资源更少， <code>docker</code> 在操作系统级别进行虚拟化， <code>docker</code> 容器和内核交互，几乎没有性能损耗，性能优于通过 <code>Hypervisor</code> 层与内核层的虚拟化。</p><p><img src="https://s2.ax1x.com/2019/07/13/Z4twNt.md.png" alt="img"></p></li><li><p><code>docker</code> 更轻量， <code>docker</code> 的架构可以共用一个内核与共享应用程序库，所占内存极小。同样的硬件环境， <code>Docker</code> 运行的镜像数远多于虚拟机数量，对系统的利用率非常高。</p></li><li><p>高可用和可恢复性： <code>docker</code> 对业务的高可用支持是通过快速重新部署实现的。虚拟化具备负载均衡，高可用，容错，迁移和数据保护等经过生产实践检验的成熟保障机制， <code>VMware</code> 可承诺虚拟机 <code>99.999%</code> 高可用，保证业务连续性。</p></li><li><p>快速创建、删除：虚拟化创建是分钟级别的， <code>Docker</code> 容器创建是秒级别的， <code>Docker</code> 的快速迭代性，决定了无论是开发、测试、部署都可以节约大量时间。</p></li><li><p>交付、部署：虚拟机可以通过镜像实现环境交付的一致性，但镜像分发无法体系化。 <code>Docker</code> 在 <code>Dockerfile</code> 中记录了容器构建过程，可在集群中实现快速分发和快速部署。</p></li></ul><h3 id="0x02-Docker基础架构"><a href="#0x02-Docker基础架构" class="headerlink" title="0x02 Docker基础架构"></a>0x02 Docker基础架构</h3><p>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。Docker 包括是三个最基本的概念：Image(镜像)，Container(容器)，Repository(仓库)。</p><table><thead><tr><th>Docker 镜像(Images)</th><th>Docker 镜像是用于创建 Docker 容器的模板。</th></tr></thead><tbody><tr><td>Docker 容器(Container)</td><td>容器是独立运行的一个或一组应用。</td></tr><tr><td>Docker 仓库(Registry)</td><td>Docker 仓库用来保存镜像，可以理解为代码仓库。</td></tr></tbody></table><p><img src="https://s2.ax1x.com/2019/07/13/Z4tr38.png" alt="img"></p><p>Docker镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。镜像实际是由多层文件系统联合组成。镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。</p><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等，容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。</p><p>镜像构建完成后，可以很容易的在当前宿主上运行，但是，如果需要在其他服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。一个 Docker Registry中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。</p><p>在上面分别介绍了docker的三个基本概念：Image(镜像)，Container(容器)，Repository(仓库)和C/S的架构。现在在详细记录一下这些组件协作运行容器的过程：</p><ol><li><code>Docker</code> 客户端执行 <code>docker run</code> 命令</li><li><code>Dockerdaemon</code> 发现本地没有我们需要的镜像</li><li><code>daemon</code> 从 <code>DockerHub</code> 下载镜像</li><li>下载完成后，镜像被保存到本地</li><li><code>Dockerdaemon</code> 启动容器</li></ol><p><code>Dockerdaemon</code> 是服务器组件，以 <code>Linux</code> 后台服务的方式运行，是 <code>Docker</code> 最核心的后台进程，我们也把它称为守护进程。它负责响应来自 <code>Docker Client</code> 的请求，然后将这些请求翻译成系统调用完成容器管理操作。</p><h3 id="0x03-Docker-安装与使用"><a href="#0x03-Docker-安装与使用" class="headerlink" title="0x03 Docker 安装与使用"></a>0x03 Docker 安装与使用</h3><p>LXC （Linux Container）内核虚拟化技术，可以提供轻量级虚拟化，以便隔离进程和资源。</p><p>Ubuntu12.04 安装Docker需要升级内核（Docker 在3.8内核下运行最佳，Ubuntu1204内核版本为3.2）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> install the backported kernel</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install linux-image-generic-lts-raring linux-headers-generic-lts-raring</span><br><span class="line"><span class="meta">#</span> reboot</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure><p>安装Docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 添加Docker库的密钥</span><br><span class="line">sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 36A1D7869245C8950F966E92D8576A8BA88D21E9</span><br><span class="line"></span><br><span class="line"># 把Docker的库添加到apt的源列表中，更新并安装lxc-docker包。</span><br><span class="line">sudo sh -c &quot;echo deb http://get.docker.io/ubuntu docker main\</span><br><span class="line">&gt; /etc/apt/sources.list.d/docker.list&quot;</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install lxc-docker</span><br></pre></td></tr></table></figure><p>按照这个步骤安装后，发现报了很多错误，调试了半天也没能解决，后来发现自己的Ubuntu12.04 是32位的，Docker需要运行在64位的机子上，所以失败了。后面查了一下说docker也可以安装在32位的系统，不过pull下来的镜像也必须是32位的，这个有点麻烦，所以放弃了。</p><p>在安装docker或者其他软件时记得要使用命令<code>uname -a</code> 、<code>uname -r</code> 、<code>lsb_release -a</code> 查看系统相关信息，来避免一些不必要的麻烦。另外注意通过<code>uname -a</code>命令查看内核和版本显示系统版本为i386和i686的为 32位系统；显示为X86_64的，才是64位系统。</p><p>后面选择了我的<strong>阿里云CentOS 安装Docker</strong>，一路pass，没有遇到任何bug，大致步骤如下：</p><p>1、清理原有的docker目录和文件，确保安装环境的干净：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-selinux \</span><br><span class="line">                  docker-engine-selinux \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><p>2、使用yum安装docker</p><p>安装一些必要的工具，设备映射器存储驱动程序需要设备映射器-持久数据和lvm2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils \</span><br><span class="line">device-mapper-persistent-data \</span><br><span class="line">lvm2</span><br></pre></td></tr></table></figure><p>设定软件源地址，国外慢的可怜，我这里使用国内源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>更新源信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum makecache fast</span><br></pre></td></tr></table></figure><p>下载docker，直接下载最新版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure><p>也可以选择下载指定版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line">sudo yum install docker-ce-&lt;VERSION STRING&gt;</span><br></pre></td></tr></table></figure><p>至此docker就下载安装成功了，可以直接使用命令docker -v 查看docker版本。</p><p>通过网上查资料说还有更简单的安装方法，直接使用脚本安装，只需要简单的两条命令就可以，我没有测试，应该是可以的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line"></span><br><span class="line">sudo sh get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure><p>3、安装成功后可以进行一些配置和测试。可以设置系统启动时同时启动docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure><p>启动docker并测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br><span class="line">sudo docker run hello-world</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/07/13/Z4tD9f.md.png" alt="img"></p><h3 id="0x04-Docker-常用命令"><a href="#0x04-Docker-常用命令" class="headerlink" title="0x04 Docker 常用命令"></a>0x04 Docker 常用命令</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.docker images ls                             <span class="comment"># 列出本地docker镜像</span></span><br><span class="line"><span class="number">2</span>.docker rmi -f &#123;image id&#125;                     <span class="comment"># 删除docker镜像</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.docker stop [docker_names]|[docker_id]       <span class="comment"># 停止容器运行</span></span><br><span class="line"><span class="number">4</span>.docker rename [docker_names] [newname]       <span class="comment"># 重命名容器</span></span><br><span class="line"><span class="number">5</span>.docker rm [docker_names]                     <span class="comment"># 删除容器</span></span><br><span class="line"><span class="number">6</span>.docker ps -a                                 <span class="comment"># 已创建docker image列表</span></span><br></pre></td></tr></table></figure><p><strong>以创建Nginx容器为例</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 查找 Docker Hub 上的 nginx 镜像</span><br><span class="line">docker search nginx</span><br><span class="line"></span><br><span class="line"># 拉取镜像</span><br><span class="line">docker pull nginx</span><br><span class="line"></span><br><span class="line"># 查看本地镜像</span><br><span class="line">docker images nginx</span><br><span class="line"></span><br><span class="line"># 启动一个Nginx容器实例</span><br><span class="line"># --name(容器名)、-p(端口映射)、-d(后台执行)</span><br><span class="line">docker run --name nginx-test -p 8080:80 -d nginx</span><br><span class="line"></span><br><span class="line"># 查看容器是否有在运行</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img src="https://s2.ax1x.com/2019/07/13/Z4DLhd.md.png" alt="img"></p><p>创建Nginx容器成功后，可以使用 ip + 端口号进行访问，Ubuntu系统可以直接使用127.0.0.1:端口号，如果是云服务器的话就是 ip+端口号，注意端口号要进行防火墙设置以保证可用。</p><h3 id="0x05-Dockerfile"><a href="#0x05-Dockerfile" class="headerlink" title="0x05 Dockerfile"></a>0x05 Dockerfile</h3><p>除了上述的拉取镜像生成容器实例的基本方法，还可以使用<code>Dockerfile</code>来定义镜像创建容器，这里的<code>Dockerfile</code>非常类似Makefile 和 Linux下shell。<code>Dockerfile</code> 是由一行行命令语句组成，并且支持已 <code>#</code> 开头的注释行。一般来说，可以将 <code>Dockerfile</code> 分为四个部分：</p><ol><li><p>基础镜像(父镜像)信息指令 FROM</p></li><li><p>维护者信息指令 MAINTAINER</p></li><li><p>镜像操作指令 RUN 、 EVN 、 ADD 和 WORKDIR 等</p></li><li><p>容器启动指令 CMD 、 ENTRYPOINT 和 USER 等</p></li></ol><p><strong>通过Dockerfile 构建Tomcat 镜像</strong></p><p>创建目录tomcat,用于存放后面的相关东西</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># webapps目录将映射为tomcat容器配置的应用程序目录、logs目录将映射为tomcat容器的日# 志目录、conf目录里的配置文件将映射为tomcat容器的配置文件</span><br><span class="line"></span><br><span class="line">mkdir -p ~/tomcat/webapps ~/tomcat/logs ~/tomcat/conf</span><br></pre></td></tr></table></figure><p>进入创建的tomcat目录，创建Dockerfile</p><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jre</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> CATALINA_HOME /usr/local/tomcat</span><br><span class="line"><span class="keyword">ENV</span> PATH $CATALINA_HOME/bin:$PATH</span><br><span class="line"><span class="keyword">RUN</span> mkdir -p "$CATALINA_HOME"</span><br><span class="line"><span class="keyword">WORKDIR</span> $CATALINA_HOME</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以直接访问 https://hub.docker.com/_/tomcat/</span></span><br><span class="line"><span class="comment"># 选择代码仓库，里面就有Dockerfile，</span></span><br><span class="line"><span class="comment"># 自己复制下来然后自定义修改就行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">CMD</span> ["catalina.sh", "run"]</span><br></pre></td></tr></table></figure><p>通过Dockerfile创建一个镜像，并命名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t tomcat2.</span><br></pre></td></tr></table></figure><p>创建完成后，我们可以在本地的镜像列表里查找到刚刚创建的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images|grep tomcat2</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 运行容器</span><br><span class="line"># 将主机中当前目录下的test挂载到容器的/test</span><br><span class="line">docker run --name tomcat -p 8080:8080 -v $PWD/test:/usr/local/tomcat/webapps/test -d tomcat</span><br></pre></td></tr></table></figure><h3 id="0x06-总结"><a href="#0x06-总结" class="headerlink" title="0x06 总结"></a>0x06 总结</h3><p>至此就把Docker的一些基本的概念和使用进行了简单总结，看了一些资料，自己对Docker也有了一些了解和认识，特别是它设计一个理念和架构，对于复杂的应用开发部署真的做到了简单高效，上面总结了Docker应用的优势和基础的架构，自己也亲自装了Docker并创建了一些容器实例，熟悉了Docker的一些常用指令和使用Dockerfile创建Image，也算是一个简单的入门吧。因为接触并不是很多，至于它的具体应用场景个人还是不太清楚，但个人认为应该是很有应用前景的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-容器与虚拟机&quot;&gt;&lt;a href=&quot;#0x00-容器与虚拟机&quot; class=&quot;headerlink&quot; title=&quot;0x00 容器与虚拟机&quot;&gt;&lt;/a&gt;0x00 容器与虚拟机&lt;/h3&gt;&lt;p&gt;我们用的传统虚拟机如 &lt;code&gt;VMware&lt;/code&gt; ， &lt;code&gt;VisualBox&lt;/code&gt; 之类的需要模拟整台机器包括硬件，每台虚拟机都需要有自己的操作系统，虚拟机一旦被开启，预分配给它的资源将全部被占用。&lt;/p&gt;&lt;p&gt;而容器技术是和我们的宿主机共享硬件资源及操作系统，可以实现资源的动态分配。容器包含应用和其所有的依赖包，但是与其他容器共享内核。容器在宿主机操作系统中，在用户空间以分离的进程运行。容器技术是实现操作系统虚拟化的一种途径，可以让您在资源受到隔离的进程中运行应用程序及其依赖关系。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://smallseven.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Docker" scheme="http://smallseven.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>软件工程：设计难于实现</title>
    <link href="http://smallseven.top/2019/06/11/2019-06-11-software/"/>
    <id>http://smallseven.top/2019/06/11/2019-06-11-software/</id>
    <published>2019-06-11T02:27:32.000Z</published>
    <updated>2019-06-11T02:47:45.713Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>记录一下我对软件工程的理解，说实话在校学习期间很难接触到真正意义上的软件开发，更别提会参考或采用软件工程的解决办法。更多的是编写一些很小很小而且漏洞百出的小程序，锻炼的只不过是对编程语言的熟悉和对一些算法的理解和掌握。而真正的软件开发应该不是这样的，虽然我目前还没接触到，但我知道肯定不是简单的编码，而是有一整套设计思路和开发流程的，因为这是质量和效率的保证。</p><a id="more"></a><h3 id="0x01-设计与实现"><a href="#0x01-设计与实现" class="headerlink" title="0x01 设计与实现"></a>0x01 设计与实现</h3><p>对于软件的开发，我认为设计远比实现复杂，首先我们先忽略对需求的分析，就单纯从一个简单功能来看，设计对于整个开发都是十分重要的，设计不仅要考虑程序的整个流程和部署，还要考虑到最终结果是否是有意义的。就我个人而言，常常会因为设计而苦恼，首先是没有一个很好解决办法的思路，其次是设计不合理导致后续的实现异常复杂。也常因为自己写了一手好bug而感到奔溃，这些都不是实现的问题，更多的是设计不合理或者对于问题本身理解的偏差造成的。实现对于设计是相对容易的，无非就是编码，这和自己对编程语言掌握的程度有关，还有就是算法与数据结构的熟练程度有关。</p><h3 id="0x02-理论的意义"><a href="#0x02-理论的意义" class="headerlink" title="0x02 理论的意义"></a>0x02 理论的意义</h3><p>理论的最大意义就是起到要个引导和规范作用，通过软件工程可以规范整个软件开发的流程和实施步骤，这也是为什么软件工程可以单独作为一门学科而存在的原因之一。软件工程把软件放在了一个产品的角度，从最开始的分析设计，开发实现，测试运维以及质量管理都提出了较为规范和通用的实施步骤和方法策略，从而使软件的开发难度降低，提高了生产效率。以前一直认为理论是无用的，实践才是硬道理，后来才发现自己对于理论的认知是有偏差的，理论并非夸夸奇谈，它的意义也并非限于其字面含义，而重要的是其提出的方法和理念。理论更像是人们总结出的经验，它并非局限于某个问题本身，而是针对某类问题的一个通用解决方案。理论研究和良好的理论体系对于一个行业的发展是至关重要的，我认为没有理论的支持，所有的设计和实现都是没有太大价值的。</p><h3 id="0x03-软件开发困境"><a href="#0x03-软件开发困境" class="headerlink" title="0x03 软件开发困境"></a>0x03 软件开发困境</h3><p>软件开发其实是一种实施细节，即使有很多理论的支持，还是抵不过多变复杂的技术，现在越来越多的框架，虽然免去了重复造轮子，但对于程序员来讲也并没减少负担，反而程序员需要去学习和了解这些框架和技术，完成开发任务。这些开发任务并非其他行业那样只要掌握了足够理论就可以解决多数问题，相反软件开发更多像是一种技术实施细节，这种实施细节只针对某个特定问题有用，换一个场景就未必有用了，所以在程序员行业，只有不断学习汲取新的东西才不会被淘汰。特别是这种实施细节对于软件开发是一种无法规避的难题，如果不了解是无法完成开发任务的，技术的更新迭代远比我们学习新技术的速度快，这是软件开发无法避免的问题，也是我们程序员不得不面对的难题。</p><h3 id="0x04-敏捷开发"><a href="#0x04-敏捷开发" class="headerlink" title="0x04 敏捷开发"></a>0x04 敏捷开发</h3><p>敏捷开发算是一种很好的开发策略针在目前状况下，我理解的敏捷开发是一种小而快的开发，适用于多变的小项。这种开发策略是一种可以针对具体需求进行随机应变的，可以理解为专注于某个需求进行精准开发。对于当下社会情形，精准显得越来越重要，随着社会分工越来越完善，协同合作也显得越来越重要，只有把工作划分到不同领域，才能提高生产效率，就像流水线一样；然后通过协同合作把各个领域的能力进行汇聚，才能发挥真正的价值，简单来说就是利用分工合作，提高效率汇聚价值。敏捷，我理解的就是高度的分工，互联网企业是分工合作体现的最明显的一类企业，无论从技术还是管理层都涉及到多个部门领域，而针对技术展开的部门和部门内部的工作组，都是分工的体现，在计算机行业想要完成任何一款产品研发都是要分工合作的，因为它涉及到多种各样的技术栈，而科技公司很难找到什么都精通的人才。为了适应市场需求，我们可能也只能进行精准学习，想要成为大牛，可能得不断学习，不断精进了。</p><h3 id="0x05-总结"><a href="#0x05-总结" class="headerlink" title="0x05 总结"></a>0x05 总结</h3><p>以上就是自己对于软件工程，对于软件开发以及将要投身于的IT行业的理解，自己写下这些东西可能毫无价值，但它代表的是当前的一些理解和思考，这可能是学生时期才会有的想法。多年以后，自己对于行业有了更深的接触和了解后，一定会有有一些不一样理解和思考的，那就等以后再说吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;记录一下我对软件工程的理解，说实话在校学习期间很难接触到真正意义上的软件开发，更别提会参考或采用软件工程的解决办法。更多的是编写一些很小很小而且漏洞百出的小程序，锻炼的只不过是对编程语言的熟悉和对一些算法的理解和掌握。而真正的软件开发应该不是这样的，虽然我目前还没接触到，但我知道肯定不是简单的编码，而是有一整套设计思路和开发流程的，因为这是质量和效率的保证。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://smallseven.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机：组成原理和体系结构</title>
    <link href="http://smallseven.top/2019/06/09/2019-06-09-computer-summary/"/>
    <id>http://smallseven.top/2019/06/09/2019-06-09-computer-summary/</id>
    <published>2019-06-09T12:22:27.000Z</published>
    <updated>2019-06-11T02:43:26.006Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h3><p>大三这一年学习了组成原理和体系结构这两门偏底层的专业课程，虽然学的不怎么样，但还是或多或少有些不一样的感受，下面就梳理一下自己学到的东西，记录一下自己理解一些的东西。</p><h3 id="0x01-抽象"><a href="#0x01-抽象" class="headerlink" title="0x01 抽象"></a>0x01 抽象</h3><p>对于计算机科班生来说计算机不再只是一台用于办公或计算的机器，而更多的是一种抽象的概念。计算机最核心的能力就是计算，而处理计算需要的是对数据的理解能力，在计算机的世界只有0和1，更准确的说是只有高低电平，这种脉冲信号才是真实存在的，这就是一种抽象。使用0和1来代表脉冲信号的高低电平，当然这种对应关系也只是相对的，这涉及的正是之前模电和数字逻辑课程所学的东西。有了数模电，其中的二极管，三极管，门电路才是构成计算机最基础最底层的东西。而计算机也正是通过这些器件一层一层的抽象，形成多种复杂的数据处理单元和数据通路，最终封装成为一个我们容易理解和使用的机器。</p><a id="more"></a><h3 id="0x02-集成电路"><a href="#0x02-集成电路" class="headerlink" title="0x02 集成电路"></a>0x02 集成电路</h3><p>计算机可以处理信息的方式就是将信息转化为0和1，在逻辑上表现为True 和 False，而在硬件上则是高低电平，在最开始的计算机计算就是通过这种高低电平的打孔计算，这处理起来是非常麻烦的，而且能够处理的数据量非常有限，甚至还没普通算术来的快。但随着硬件和集成电路的发展，计算机底层电路经过几代的更换后，计算机性能得到了飞速的发展，对于硬件的优化是对计算机至关重要的，集成电路的发展对计算各个硬件设计至关重要，从第一台计算诞生到至今，集成电路设计几乎一直是计算发展的核心，而这种最底层的设计需要多个领域技术的结合，包括电子，材料，物理等，所以技术难度很大，需要投入的成本也是巨大的，如果没有原始的技术积累是很难做到的。</p><h3 id="0x03-编码"><a href="#0x03-编码" class="headerlink" title="0x03 编码"></a>0x03 编码</h3><p>编码是计算机最有意思的地方，如何让程序成为计算机可以执行的指令，而指令又是如何装换为机器码的，这种机器码是怎么控制计算机电路的呢，这都是一些有趣的问题。对于计算机程序指令，最开始的认识是高级语言转换为汇编语言，而汇编由转换为可执行的机器码。那为何需要将高级语言转为汇编再转为机器码，而不是高级语言直接转为机器码呢？其实这个设计是为方便程序的优化和调试，高级语言转为汇编是需要编译器的，编译器可以处理好高级语言到汇编这一过程，而真正复杂的是汇编程序转换为机器码，这是需要物理电路实现的，通过机器码01序列来控制对应的寄存器和电路，来进行相应状态的切换，这就是计算机最基础的实现，但这种实现到底怎么实现的呢，我现在还是不太清楚，这可能涉及到EE的内容，但作为CS方向应该有一定的了解，之前也找了《编码:隐匿在计算机软硬件背后的语言》书来看，但只看了部分，等有时间在看一看深入了解一下。</p><h3 id="0x04-指令和程序"><a href="#0x04-指令和程序" class="headerlink" title="0x04 指令和程序"></a>0x04 指令和程序</h3><p>指令简单理解就是控制计算机执行的命令，指令说到还是一串01的序列，只是将这串指令意义化了，就像给寄存器命名，而实际上指向的还是一个地址而已，这是我个人理解的，指令本身含义不大，关键的是它对电路的控制和状态转移的操作，这才是指令真正的意义，除了指令外，还有程序，命令，操作等概念，记得当时计组课上讲过，微程序是一组微指令的集合，微指令是一个单位时间内出现的一组微操作的描述语句，在微指令的控制字段中，每一位代表一个微命令。这些大概就是它们的具体区别吧。</p><h3 id="0x05-数据通路"><a href="#0x05-数据通路" class="headerlink" title="0x05 数据通路"></a>0x05 数据通路</h3><p>这是我们实验实现过的东西，当时使用Verilog编程实现简单MIPS数据通路，如果将实验拆分为各个模块那到并不是很难，分别实现存储器，运算器，控制单元，然后将这些模块组合，在加上程序计算器，IO模块，基本上就可以实现简单的数据通路，而且是单周期的所以理解起来相对比较容易。数据通路是CPU的核心框架，基本上就是实现了一个简单的CPU，比较复杂的是PC的寻址，指令的译码，以及IO操作，这种对于硬件的操作虽然实现是有一定难度的，但也是能一种更好理解计算机的方式。</p><h3 id="0x06-体系结构"><a href="#0x06-体系结构" class="headerlink" title="0x06 体系结构"></a>0x06 体系结构</h3><p>说到体系结构自然想到的就是冯诺依曼体系结构，现代计算机，大部分是基于冯诺依曼体系结构的，其核心就是存储程序和顺序执行，它定义了整个计算的基础框架，无论计算机怎么发展其基本原理都基本相同。体系结构特点包括了计算机处理的数据和指令用二进制表示，指令和数据都存储在同一个存储器中，顺序执行程序的每一条指令，硬件组成包括运算器，控制器，存储器，输入设备和输出设备。我们平时所接触的和学习都是围绕着这个体系所展开的，而其中的每一个部分想要将它理解透都是要花费很多精力的，后面计算机设计都是在这个基础上改进优化，对于后学者而言，能改进的东西越来越少，需要学习的是越来越多，就当下计算机的能力而言，硬件和体系结构的性能几乎已经达到了一个比较高的水平，如果想突破这种极限，可能需要一种新的体系结构来定义计算机了。</p><h3 id="0x07-处理器"><a href="#0x07-处理器" class="headerlink" title="0x07 处理器"></a>0x07 处理器</h3><p>广义上处理器就是指平时所说的CPU，简单理解CPU就是控制程序执行，处理数据的一个单元，也可以理解为个集成电路，和上面提到的集成电路和数据通路类似，CPU是计算机的核心是必不可少的组成部分。微处理器的发展几乎代表了计算机的发展，而这里不得不提就是Intel(英特尔)，这个公司的发展史可以说是代表了这个微处理器的发展历程，包括8x86，奔腾等都是处理器发展的代表，包括后面发展起来的AMD, 高通等公司都是目前芯片领域的巨头，当然芯片不仅包括了处理器芯片，还包括了其他的功能芯片。说到这些，自己其实了解的真的太少了，关于芯片这部分其实我自己还是挺感兴趣的，对于这个设计流程包括功能特性以及工作原理其实还都想去了解一下的，有机会还得多看看书和找找资料。</p><h3 id="0x08-ISA"><a href="#0x08-ISA" class="headerlink" title="0x08 ISA"></a>0x08 ISA</h3><p>指令集架构，说到这里又得感叹自己了解的太少了，对于指令集架构最主要分为CISC和RISC，当时老师讲课一直提到了，因为书上也没提到，所以感觉很懵，都不知道在讲什么，好多课都荒废了，后面还是查了资料才知道的。对于指令集架构无非就是涉及到指令寻址方式，操作数类型和表示方法，以及指令的编码等，还提到一个编译优化等，对于这些东西真的只是学个概念，想要真的弄明白还是要花费一些时间和精力的，况且就单纯老师上课讲的东西，也只是让我们了解一个大概。还有就是MIPS指令结构，这稍微了解的多一些，包括一些指令类型，寻址等，但平时用的太少所以也不熟。</p><h3 id="0x09-流水线"><a href="#0x09-流水线" class="headerlink" title="0x09 流水线"></a>0x09 流水线</h3><p>流水线几乎是体系结构整本书的重点，其实就是讲的是调高程序并行度的一种方法，流水线主要是体现的是指令级的并行，通过流水线来提高程序效率，流水线虽然可以提高效率，但还是存在一些问题，比如一些数据冒险，控制冒险，结构冒险等，这些都是可以进行优化的，所以提出了一系列改进措施和调度策略，包括了scoreboard，tomasulo，分支预测等。其实只要理解了，其实并不复杂，我们也都是以传统5级流水线作为例子，几乎又把之前提到的东西重复了一遍，包括取指，译码，执行，访存和回写。当然比较难的还是对于汇编指令的不太熟悉，因为完全没有好好的去学习汇编，都是在例子上接触的一些，所以，有些时候弄起来很难得心应手。</p><h3 id="0x0A-Cache"><a href="#0x0A-Cache" class="headerlink" title="0x0A Cache"></a>0x0A Cache</h3><p>cache是一个很重要的结构对于计算机来说，它位于是连接CPU和主存的一种高速缓存，由于空间局部性和时间局部性原理，所以可以通过cache缓存来提高CPU对于数据的访问效率，从而提高计算机性能，主存和cache的映射方式包括全相关，直接映射和组相连，连接方式不同效率和复杂度也不同。cache也是可以进行优化的包括多级cache，还有TLB，以及相关的替换策略都是为了提高计算机的性能。</p><h3 id="0x0B-线程级并行"><a href="#0x0B-线程级并行" class="headerlink" title="0x0B 线程级并行"></a>0x0B 线程级并行</h3><p>包括SISD，SIMD，MISD、MIMD，还包括向量机，GPU等，这部分了解的并不是太多。</p><h3 id="0x0C-量化方法"><a href="#0x0C-量化方法" class="headerlink" title="0x0C 量化方法"></a>0x0C 量化方法</h3><p>量化方法就比较好理解了，主要就是对性能进行评估，使用一些指标比如说CPU时间，CPI，加速比，平均访存时间，还有功耗能耗等，其目的就还是可以量化计算机CPU的执行效率，以及性能提升，是衡量性能优化的指标。</p><h3 id="0x0D-总结"><a href="#0x0D-总结" class="headerlink" title="0x0D 总结"></a>0x0D 总结</h3><p>大体上把计组和体系结构的学到东西梳理了一遍，才发现自己学到的东西几乎是碎片化的，自己的知识体系结构根本没有很清楚的逻辑，如果不去记录或者输出，真的不知道自己理解那些东西，其实大学学习更多的是了解一个概念，形成一个大体的知识架构，架构内部的东西是要靠我们自己填补的。</p><p>想要去深入了解一个领域的知识是需要花费很多时间的，获取到的信息如果不进行加工处理内化到自己的知识体系里是无用的。这也是我在进行梳理时真正体会到的。很多东西很难通过三言两语叙述清楚，首先是自己对内容的不太熟悉，其次是没有一个清楚的表达目的。关于计组和体系结构，本身内容就比较抽象，其次就是练习的时间太少，还有就是学这些东西可能对自己意义不大，但学习这个事还是不能太功利，也不能太心急，对于我来说这两门课还算有些兴趣的，或多或少也算是了解了一些东西，至于考试成绩什么的那又是后话了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class=&quot;headerlink&quot; title=&quot;0x00 前言&quot;&gt;&lt;/a&gt;0x00 前言&lt;/h3&gt;&lt;p&gt;大三这一年学习了组成原理和体系结构这两门偏底层的专业课程，虽然学的不怎么样，但还是或多或少有些不一样的感受，下面就梳理一下自己学到的东西，记录一下自己理解一些的东西。&lt;/p&gt;&lt;h3 id=&quot;0x01-抽象&quot;&gt;&lt;a href=&quot;#0x01-抽象&quot; class=&quot;headerlink&quot; title=&quot;0x01 抽象&quot;&gt;&lt;/a&gt;0x01 抽象&lt;/h3&gt;&lt;p&gt;对于计算机科班生来说计算机不再只是一台用于办公或计算的机器，而更多的是一种抽象的概念。计算机最核心的能力就是计算，而处理计算需要的是对数据的理解能力，在计算机的世界只有0和1，更准确的说是只有高低电平，这种脉冲信号才是真实存在的，这就是一种抽象。使用0和1来代表脉冲信号的高低电平，当然这种对应关系也只是相对的，这涉及的正是之前模电和数字逻辑课程所学的东西。有了数模电，其中的二极管，三极管，门电路才是构成计算机最基础最底层的东西。而计算机也正是通过这些器件一层一层的抽象，形成多种复杂的数据处理单元和数据通路，最终封装成为一个我们容易理解和使用的机器。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://smallseven.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="计算机" scheme="http://smallseven.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Blog Plans</title>
    <link href="http://smallseven.top/2019/06/07/2019-06-07-blog-planning/"/>
    <id>http://smallseven.top/2019/06/07/2019-06-07-blog-planning/</id>
    <published>2019-06-07T03:04:25.000Z</published>
    <updated>2019-06-14T10:53:49.084Z</updated>
    
    <content type="html"><![CDATA[<p>自己搭建博客也好久了，一直都在倒腾，也花费了一些时间精力，当然也有很多收获。因为各种原因更新的频率很低，内容输出很少，主要不太清楚要输出那些方面的内容会比较好，所以结合自己的实际情况，给自己博客做一个规划吧。</p><a id="more"></a><p><strong>为什么要写博客？</strong></p><p>其实就是给自己找一块写字的地方，以前有做笔记的习惯，虽然记了但很少会拿来看，但仍然有一种充实感。现在很少手写笔记，所以有很多想法，或者值得纪念的东西，如果不进行记录很可能就会忘了，所以做成博客是一个不错方法，偶尔也可以感动一下自己，不是吗。</p><p>其次是针对技术难题的记录，把一些技术难题记录下来，如果下次遇到也方便查找，减少重复踩坑的可能。当然，如果自己的文章能够帮助到其他人，那不是更好吗。只可惜目前技术水平太低，没有遇到啥技术难题，大多是一些学习笔记，之后尽量写一些技术类或者经验类文章，提升一下Blog的格调。</p><p>写博客是一个学习的过程，你会因为博客认识更多优秀的人，他们文章可能会对的学习生活有所启发，也可能会解决你遇到的技术问题，或者给你提供了更多信息资讯，这些信息远比那些流量自媒体更有价值。</p><p>如果能够维持博客固定更新的话，坚持做一件事，你会收获很多东西，从不要低估坚持这个东西，绳锯木断，水滴石穿，请相信坚持的力量。当然少一些功利主义，多些不为什么的坚持，可能会做得更好。</p><p><strong>自己的博客计划</strong></p><p>本博客采用的 Hexo + Github pages 搭建的静态博客，想着只更新一些个人笔记，也没必要推广啥的，对于访问速度也没太大要求，也不想弄啥SSL了，国内备案也挺烦的，在阿里云万网买的域名 smallseven.top 感觉还不错，格子小七这个昵称也还挺可爱的。所以在这个个人博客平台主要记录一些学习笔记，生活感想之类的，技术类的文章主要发一些有质量的。</p><p>因为学习中常常会遇到一些杂七杂八的问题，都是一些小细节，所以不打算在个人博客里进行记录。我一般会在csdn进行发布，虽然csdn经常遭人吐槽，但是用来做做笔记还是挺好的，重要的是希望这些小问题的解答可以帮助到其他需要帮助的人，自己踩过的坑，希望别人可以避免掉，发扬程序猿的互帮互助精神。</p><p>还有一个我比较喜欢的平台是博客园，个人觉得博客园的文章质量比csdn要高，讲的很详细，自定义主题也很多，所以体验比csdn要更舒服一些，我在博客园很少发文章，主要是关注一些优秀的博主，学习一些知识和技能。经常在园子里逛一逛能够了解一些多元化的东西，降低信息壁垒，也算是一种学习途径吧。</p><p><strong>最后：如果你觉得一件事情有意义那就去做吧，如果你觉得做这件事能够让你快乐的话，那就Hold on，请相信时间的力量，它会给你答案</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自己搭建博客也好久了，一直都在倒腾，也花费了一些时间精力，当然也有很多收获。因为各种原因更新的频率很低，内容输出很少，主要不太清楚要输出那些方面的内容会比较好，所以结合自己的实际情况，给自己博客做一个规划吧。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>六月，感想</title>
    <link href="http://smallseven.top/2019/06/06/2019-06-06-my-feelings/"/>
    <id>http://smallseven.top/2019/06/06/2019-06-06-my-feelings/</id>
    <published>2019-06-06T13:03:00.000Z</published>
    <updated>2019-06-14T10:54:38.279Z</updated>
    
    <content type="html"><![CDATA[<p>今天是2019年6月6日，也是有一个很有意义的日子，熬过了艰难的一周考试，也总算可以放松一下了，虽然还有几门课程没有考，但复习难度并不算太大，所以也不用太担心。好久没有像现在这样舒心的做一些自己喜欢的事了，大概生活就是这样，得到的时候不懂得珍惜，失去了又感觉惋惜，忙中偷闲带来的娱乐感才是最强的。最近其实有很多想法的，但由于事情比较多，思绪也比较乱，也不知道从哪里开始说起，首先还是对自己近段时间的学习状况进行一些总结吧。</p><a id="more"></a><p>上一次发了一篇感想是在新年那天，主要总结了大三上之前的一些关于学习的感想，还给自己加油鼓劲，没想到时间过得那么快，一下半年时间就过去了，仔细想想自己这半年来，收获成长真的没有预期的那么大，很容易陷入某种瓶颈，或者是存在某种不可抗力的因素，无论是学习还是生活，都没有很好的掌控。首先就说学习吧，这学期基本都是专业课，有比较难的核心课程，也有比较水的课程，而且基本所有课程都有实验或者课程任务，实验都是安排在了晚上，所以晚上时间几乎被占用，除了最开始那几周，自己有很多可以支配的时间外，后面都时间安排的都很紧，直到现在的考试周。也可能是我个人对于时间的规划不太合理，生活规律也没能很好的适应时间的分配，所以常常会感到时间不够用。</p><p>记得三月份是我状态最好的时候，当时没有太重的课业任务，有很多时间去做些其他的事情，因为是大三了，所以找实习应该算是一件比较重要的事，看了很多春招秋招打法，说要提前一段时间准备，刷一些题，做一些项目，还有就是巩固一下自己自己学过的课程内容，因为春招问的都是基础，自己当时还是有这个意识的，但还是缺乏了充分的准备，在三月份的春招都没得到满意的结果，总结起来就是有意识但没能力，无论是理论基础，还是实践能力都不足够，机试和笔试对于我来说都是不小的挑战，只怪自己以前倒腾的太少，也可能是学习方法有问题，或者总结反思的不到位。后来自己也逐渐改变了打法战略，尽量不去关注那些琐碎的事或者与自己无关的事，尽量以及提升自身实力和技术水平为中心，撸代码，学技术，总结经验，那段时间自己的吸收了很多东西，同时对自己职业规划也有了一个比较清楚的计划。人只要忙起来就会觉得时间过得太快，可能是自己有略微的拖延症问题，所有事情都是几乎要到deadline才完成。现实就是这样，一些事情还没结束，另外一些些事情就已经开始了。所以在4,5月份过得很忙茫盲，因为没有一个量化的标准，所以感觉每天都在做事，但又不清楚做了些什么，一直处于一种繁忙，迷茫，甚至有点盲目的状态，很多计划都被打乱，也散失了很多机会。</p><p>到了期末考试周，不得不停下手头上的事情好好准备复习，其实我自己对于考试成绩没太大要求，更多的是希望自己可以尽力而为，但大学很多考试结果真的不一定和付出的努力程度相关，有些科目随便弄一下就能得到一个不错的成绩，而有些科目，你即使花费了很多时间，而结果未必如你所愿。况且大多数科目都有平时成绩的构成，所以很多结果真的不是一场考试就可以决定的，当然也可能是自己不够强，毕竟难的科目大家都难，容易的大家都容易。所以大学考试更多的是一种学习能力的体现，而非努力程度。</p><p>我自己是一个比较喜欢做计划和进行反思总结的一个人，做事情更看重的事情的过程，所以在很多事情上花了工费但结果未必满意的原因，如果事情过度的过程化，缺少一个清楚额目标的话，自己做事的效率会很低很低，这是我深有体会的。做事效率低一直是自己的一大缺点，自己也在想办法突破这种局限性，就像软件开发编程一样，如果真的所有事情都过于强调其过程，试图弄清楚它的原理，真的需要花费很多时间和精力，但有些东西如果不把原理弄明白，而是当纯的完成任务，那又有什么样意义呢？所以自己经常会在两者之间纠结，然而现实却只要求你有一个结果就行。</p><p>Planning 和deadline可以让自己提高效率，所以我自己也经常给自己做一些计划，比如看懂那些知识点，学习某种技能。但实际情况是，好多东西在学习时入门很简单，但要是深入到一定程度的话就很难，很容易放弃，所以就会造成了什么都会一定，什么又都不会的尴尬局面，其实在现实生活中，往往更需要掌握和精通一个领域的专家，而不是熟悉多个领域的杂家，一技之长真的很重要，当然对于我们来说，不应该给自己设限，还是应该尽量广泛的去了解多领知识，只有做到除了会某些事情外，其他的事也能做好的水平，才能让自己有更多的发展可能和试错机会。</p><p>以前常常因为自己对于一些东西缺乏意识而感到烦恼，现在更多的是因为自己能力不足，不得不做的事没有办法做好，自己想做的事情又没有做到。所以意识和能力都很重要，在这个普遍贩卖焦虑的时代，想要不随波逐流，保持独立意志真的很难，除了撸起袖子加油干，还要多思考，只懂的努力是一件很恐怖的事情，现在社会更强调的是聪明的努力和有意义的努力。</p><p>叙述了一堆有用没用的话，同时也让我想到了三年前的自己，2016年6月6日是自己高考前的一天，当时自己满怀信心，从未考虑过高考对于自己意味着什么，一心只想尽力而为。高中三年学习生活并没有想象中过得那么枯燥辛苦，更多的是一种平淡和规律，自己很体验那个过程，体验获得新知识的充实感，体验做对难题的成就感，体验和同学嬉笑娱乐的幸福感。大概这就是高中三年生活的意义吧，往事不过多重提，一切放在心里。曾经一直以梦想和奇迹来鼓励自己，用激情和勇气来为自己加油。而现在更多的是以不忘初衷，不负年华来激励自己，时间过得太快，已经忘记那个梦想初衷究竟是什么了，以后的路还很远，如果不知道自己想要什么，那就让自己变得更好吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是2019年6月6日，也是有一个很有意义的日子，熬过了艰难的一周考试，也总算可以放松一下了，虽然还有几门课程没有考，但复习难度并不算太大，所以也不用太担心。好久没有像现在这样舒心的做一些自己喜欢的事了，大概生活就是这样，得到的时候不懂得珍惜，失去了又感觉惋惜，忙中偷闲带来的娱乐感才是最强的。最近其实有很多想法的，但由于事情比较多，思绪也比较乱，也不知道从哪里开始说起，首先还是对自己近段时间的学习状况进行一些总结吧。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔集" scheme="http://smallseven.top/categories/%E9%9A%8F%E7%AC%94%E9%9B%86/"/>
    
    
  </entry>
  
  <entry>
    <title>关于Navicat for MySQL 的使用小结</title>
    <link href="http://smallseven.top/2019/05/30/2019-05-30-navicat-mysql/"/>
    <id>http://smallseven.top/2019/05/30/2019-05-30-navicat-mysql/</id>
    <published>2019-05-30T00:50:23.000Z</published>
    <updated>2019-06-14T10:57:29.962Z</updated>
    
    <content type="html"><![CDATA[<p>最近都在做数据库的实验，通过实验了解了一些SQL的语法，也更加熟悉了mysql的使用，实验从最开始数据库的创建，表的创建，包括添加一些条件约束，创建索引触发器等都涉及到了。到后面有关mysql的权限管理，以及通过powerdesigner进行数据库建模设计，和使用Java 编程对数据库进行增删改查，几乎包含了所有数据库基础操作。通过实验，不仅是熟悉一些操作，更多的是了解认识更多东西。实验我使用的是Navicat，mysql，sql的基础语法太多，用到去查就行，这里主要记录一些偏实践性的东西，算是一个小总结吧。</p><a id="more"></a><h4 id="1-、命令行界面查看mysql-版本"><a href="#1-、命令行界面查看mysql-版本" class="headerlink" title="1 、命令行界面查看mysql 版本"></a>1 、命令行界面查看mysql 版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select version();</span><br><span class="line">+-----------------+</span><br><span class="line">| version()       |</span><br><span class="line">+-----------------+</span><br><span class="line">| 10.1.32-MariaDB |</span><br><span class="line">+-----------------+</span><br><span class="line">1 row in set</span><br></pre></td></tr></table></figure><p>也可以使用<code>select version() from dual；</code>命令，这里的 dual  是数据库里的一个默认表，在没有引用表的情况下，允许将dual指定为虚拟表名。在Oracle中使用的比较多，是一个oracle内部表，它仅包含一行一列，不论我们做什么操作（不要删除记录）它都只有一条记录。<br>在Mysql，SQL Server 等数据库中也都有dual 表，不过在mysql中的dual表没有值，<code>select * from dual</code> 这种语句会报错。</p><h4 id="2、MySQL-和-MariaDB"><a href="#2、MySQL-和-MariaDB" class="headerlink" title="2、MySQL 和 MariaDB"></a>2、MySQL 和 MariaDB</h4><p>我使用的xmapp的一个工具包，里面包括了mysql，但是在使用时我发现了我是MariaDB，不是mysql，然后就简单了解了一下mariaDB 和 mysql 的区别。</p><p>MariaDB数据库管理系统是MySQL的一个分支，主要由开源社区在维护，采用GPL授权许可。MariaDB的目的是完全兼容MySQL，包括API和命令行，使之能轻松成为MySQL的代替品。</p><p>MariaDB的API和协议兼容MySQL，另外又添加了一些功能，以支持本地的非阻塞操作和进度报告，所以所有使用MySQL的连接器、程序库和应用程序也将可以在MariaDB下工作。</p><p>但两者之间也存在不兼容性，MariaDB 的文档中列出了 MySQL 和 MariaDB 之间的数百个不兼容问题。因此，我们无法通过简单的方案在这两个数据库之间进行迁移。</p><h4 id="3、数据库存储引擎"><a href="#3、数据库存储引擎" class="headerlink" title="3、数据库存储引擎"></a>3、数据库存储引擎</h4><p>数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能，使用不同的存储引擎，还可以 获得特定的功能。</p><p>可以使用<code>show engines</code> 命令查看MySQL 使用的引擎；</p><blockquote><p>MySQL 支持的存储引擎包括：InnoDB、MyISAM、Memory、CSV、Archive、Blackhole、Merge、Federated、Example等</p><p>MariaDB 支持的存储引擎包括：XtraDB、InnoDB、MariaDB ColumnStore、Aria、Archive、Blackhole、Cassandra Storage Engine、Connect、CSV、FederatedX、Memory、Merge、Mroonga、MyISAM、MyRocks等</p></blockquote><p>数据库可以支持多少个存储引擎其实并不太重要，满足需求才是最重要的。如果想了解不同数据库存储引擎的区别可以参考这篇文章 <a href="https://www.cnblogs.com/domi22/p/8059403.html" target="_blank" rel="noopener">数据库—四种存储引擎</a>。</p><h4 id="4、Navicat的帮助文档"><a href="#4、Navicat的帮助文档" class="headerlink" title="4、Navicat的帮助文档"></a>4、Navicat的帮助文档</h4><p>Navicat提供了特别详细的帮助文档可以点击帮助菜单打开，也可以直接使用按<code>f1</code>打开。下面是Navicat for MySQL 一些常用的快捷键。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ctrl+q            打开查询窗口</span><br><span class="line">ctrl+/            注释sql语句</span><br><span class="line">ctrl+shift +/     解除注释</span><br><span class="line">ctrl+r            运行查询窗口的sql语句</span><br><span class="line">ctrl+shift+r      只运行选中的sql语句</span><br><span class="line">F6                打开一个mysql命令行窗口</span><br><span class="line">ctrl+d            查看表结构详情，包括索引 触发器，存储过程，外键，唯一键</span><br><span class="line">ctrl+l            删除一行</span><br><span class="line">ctrl+n            打开一个新的查询窗口</span><br><span class="line">ctrl+w            关闭一个查询窗口</span><br><span class="line">ctrl+tab          多窗口切换</span><br></pre></td></tr></table></figure><h4 id="5、sql-脚本的导入导出"><a href="#5、sql-脚本的导入导出" class="headerlink" title="5、sql 脚本的导入导出"></a>5、sql 脚本的导入导出</h4><ol><li><p>可以直接点击右键点击数据库，运行SQL文件 或者转储SQL文件，就可以将已有的sql 文件导入数据库和将数据库保存为sql文件。也可以右键单击数据库，选择文件传输，这里可以选择不同的连接和数据格式，可以有选择的导入导出传输。</p></li><li><p>通过命令行导出sql文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h 127.0.0.1 -uroot -ppassword databasename &gt;D:/back_databasename.sql</span><br></pre></td></tr></table></figure><blockquote><p>使用命令行，先进入mysql的安装目录。我这里是xmapp安装的，所以切换到C:\xampp\mysql\bin</p><p>mysqldump -h 127.0.0.1 -uroot -ppassword databasename &gt;D:/back_databasename.sql</p><p>用户名为：root，与-u之间可有空格（-h后也可由空格）密码为：password（你自己的密码），注意！-p后面不可有空格，直接跟密码。数据库名称为：databasename（你自己要导入导出的数据库名），导出路径为：D:/back_databasename.sql（根据自己实际情况修改）</p></blockquote></li><li><p>通过命令行还原sql文件，上面步骤相似</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 127.0.0.1 -u root -ppassword -f databasename &lt;D:/back_databasename.sql --default-character-set=gbk</span><br></pre></td></tr></table></figure></li><li><p>使用命令将数据库下表中的数据导出成文本文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use hhh;  // 使用hhh数据库</span><br><span class="line">mysql&gt; show tables; //查看数据库中的表</span><br><span class="line">mysql&gt;select * from user into outfile &apos;out.txt&apos;; //将user表保存为文本文件out.txt</span><br></pre></td></tr></table></figure></li></ol><h4 id="6、使用xmapp启动mysql"><a href="#6、使用xmapp启动mysql" class="headerlink" title="6、使用xmapp启动mysql"></a>6、使用xmapp启动mysql</h4><ol><li><p>命令行进入，先在Xampp的控制面板(shell)开启MYSQL，直接进入路径启动</p><blockquote><p>命令行切换至xmapp安装目录下的mysql目录下的bin目录</p><p>比如：C:\xampp\mysql\bin</p><p>mysql -u root -p 回车 </p><p>要求输入密码（如果是第一次登陆，直接回车，默认密码 “”）修改密码</p></blockquote></li><li><p>修改密码</p><blockquote><p>命令行切换至xmapp安装目录下的mysql目录下的bin目录</p><p>比如：C:\xampp\mysql\bin</p><p>使用命令修改密码：mysqladmin -u root -p password 新密码</p><p>修改密码后 mysql -u root -p 登录时就需要输入密码了</p></blockquote></li><li><p>配置环境变量</p><blockquote><p>Path变量中加入C:\xampp\mysql\bin </p><p>win+R -&gt; cmd回车</p><p>mysql -u root -p 回车 </p><p>要求输入密码（如果是第一次登陆，直接回车，默认密码 “”）</p></blockquote></li></ol><h4 id="7、root-和-非root的区别"><a href="#7、root-和-非root的区别" class="headerlink" title="7、root 和 非root的区别"></a>7、root 和 非root的区别</h4><p>我在使用xmapp时，启动mysql，并通过Navicat连接了数据库后，创建了一些数据库，在Navicat里面的命令行界面可以查看到我创建的数据库，但是在xmapp shell 里面进入mysql 却没有显示我创建的数据库。</p><p><strong>原因</strong>：是我在使用Navicat连接mysql时，使用的是root身份，但通过xmapp shell 进入mysql，我是直接启动的mysql，并没有使用root 进登录的。所以无法查看root身份下的创建的数据库，只是有几个系统默认的数据库。</p><p><strong>解决方法</strong>：使用命令 mysql -u root -p 进入mysql。这时就可以通过查看自己创建的数据库了。</p><p><strong>重要</strong>：以后在使用数据库时要区分以什么身份登录root 和非root有很大区别，对于数据库的管理权限也有所不同，具体情况具体分析。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近都在做数据库的实验，通过实验了解了一些SQL的语法，也更加熟悉了mysql的使用，实验从最开始数据库的创建，表的创建，包括添加一些条件约束，创建索引触发器等都涉及到了。到后面有关mysql的权限管理，以及通过powerdesigner进行数据库建模设计，和使用Java 编程对数据库进行增删改查，几乎包含了所有数据库基础操作。通过实验，不仅是熟悉一些操作，更多的是了解认识更多东西。实验我使用的是Navicat，mysql，sql的基础语法太多，用到去查就行，这里主要记录一些偏实践性的东西，算是一个小总结吧。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://smallseven.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="http://smallseven.top/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>关于前端学习的小总结</title>
    <link href="http://smallseven.top/2019/05/02/2019-05-02-study-html/"/>
    <id>http://smallseven.top/2019/05/02/2019-05-02-study-html/</id>
    <published>2019-05-02T15:51:12.000Z</published>
    <updated>2019-06-14T10:52:02.625Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下近期的学习心得，由于参加一个比赛需要一个简单的web页面来展示结果，所以需要取学习一些前端的开发的技术。之前也看过一些 web 页面的知识，但没有亲自去尝试过，这次正好有机会去进行更深入的了解。</p><a id="more"></a><h3 id="0x01-前端基本功"><a href="#0x01-前端基本功" class="headerlink" title="0x01 前端基本功"></a>0x01 前端基本功</h3><p>要说前端开发，首先得有一些基本功，就是我们平时说的 HTML CSS JavaScript。这些是构建一个网页的基础，之前搭博客我了解过一些HTML和JS的东西，只限于看得懂，也做过一些页面的修改，但是亲手编写的话，还是有一定的困难，不过好在可以查资料，照葫芦画瓢，还是能做出来一些。</p><p>之前尝试过开发一款微信小程序，好多东西都是参考着网上的教程一步一步的做，其中也涉及了大量的网页前端的知识，业务逻辑实现都是用的 JS 当时主要是参考了微信小程序的开发文档，它提供很多可以直接使用的API，如果是实现简单功能的话，会调用就行，当时做的是一款天气预报的小程序，数据来源是百度地图的API，比较有挑战的是 WXSS 样式设计，类比于Web页面的CSS，可以这么说页面好不好看取决于你的样式表设计和布局，因为没有系统学习过，当时还是花了很长时间去设计CSS，尽管如此，最后的页面还是惨目忍睹。</p><p>再说这次页面的编写，有了之前的基础，这次在JS 和 CSS 的设计和实现上感觉容易多了，也更加了解了一个页面的构成。一个 HTML 页面定义了整个网页的结构，把所有CSS 和 JS 都包含起来。当然大多数开发者是很少会直接在HTML里面定义CSS 和JS的，通常是将它们放在单独的文件夹，通过引入进行调用。</p><p>下面这个例子就是个简单的HTML页面，其中包含了页面布局的定义，CSS的定义，以及一个简单 JS 脚本。在HTML页面里CSS是通过<code>&lt;style&gt;&lt;/style&gt;</code>标签定义引用的，一般在HTML的<code>&lt;head&gt;&lt;/head&gt;</code>内引入，也可以直接在标签内进行定义，CSS 样式多变难记，不过十分容易理解，在使用时可以查找相关资料。JS脚本实现的逻辑功能，在页面里 JS 是通过<code>&lt;script&gt;&lt;/script&gt;</code> 标签定义引入的，一般情况  JS 在页面内定义位置不影响，是全局的，通过使用JavaScript 能够大大增强HTML的交互性。</p><p>对于HTML页面来说，整体结构就是head、body；整个页面需要<code>&lt;div&gt;&lt;/div&gt;</code>等各种标签进行组合，一个功能完善并且好看的页面是需要HTML，CSS，JS 共同协调构建的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>这个是标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">body&#123;</span></span><br><span class="line"><span class="undefined">    height: 100%;</span></span><br><span class="line"><span class="undefined">width: 100%;</span></span><br><span class="line"><span class="undefined">background-color: yellow;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">        /*标签选择器*/</span></span><br><span class="line"><span class="undefined">        p&#123;</span></span><br><span class="line"><span class="undefined">            color:red;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        /*类选择器*/</span></span><br><span class="line"><span class="undefined">        .first&#123;</span></span><br><span class="line"><span class="undefined">            color:red;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        /*id选择器*/</span></span><br><span class="line"><span class="undefined">        #first&#123;</span></span><br><span class="line"><span class="undefined">            color:green;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是一个一个简单的HTML,h1</span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span>Hello World！<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>这是一个一个简单的HTML,h2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"color:orange;font-size:18px"</span>&gt;</span>在HTML中使用css样式<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">     <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        var mystr = document.getElementById("test")</span></span><br><span class="line"><span class="xml">        document.write("p标签修改之前："+mystr.innerHTML+ "<span class="tag">&lt;/<span class="name">br</span>&gt;</span>");</span></span><br><span class="line"><span class="undefined">        mystr.innerHTML="hello web!"</span></span><br><span class="line"><span class="xml">        document.write("p标签修改之前："+mystr.innerHTML + "<span class="tag">&lt;/<span class="name">br</span>&gt;</span>");</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="0x02-浅谈-JavaScript"><a href="#0x02-浅谈-JavaScript" class="headerlink" title="0x02 浅谈 JavaScript"></a>0x02 浅谈 JavaScript</h3><p>对于前端开发来说，应该比较复杂的就是业务功能实现这部分了，我在刚接触 JS 的时候也是摸不着头脑，最开始连代码都看不太懂，更别说写。不过接触多了，慢慢的也就熟悉了。</p><p>首先需要了解什么是DOM（文档对象模型），它定义了访问 HTML 和 XML 文档的标准， 是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。其中包含了大量的对象，通过对象调用可以实现一些特定的功能，比如常用的Document、Event 事件、Form表单等。</p><p>在这次网页编写时我还使用了 jQuery，它属于 JavaScript 的一个库，可以极大的简化 JS 编程，功能也十分强大，如果有前面说的基础，那也很容易学。在使用 jQuery 的时候需要使用<code>&lt;script&gt;</code> 标签将 jQuery 添加到网页中，<code>&lt;script&gt;</code> 标签应该位于页面的<code>&lt;head&gt;</code>部分。src 可以是下载到本地js，也可以是远程当然 jquery.js 链接。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"/jquery/jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    $(document).ready(function()&#123;</span></span><br><span class="line"><span class="undefined">    $("button").click(function()&#123;</span></span><br><span class="line"><span class="undefined">    $("p").hide();</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>This is a heading<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is another paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>Click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为实现与服务器交换数据并更新部分网页，我还去了解一些 AJAX。异步的 JavaScript 和 XML，这是一种用于创建快速动态网页的技术，其最主要的优势是可以在不重新加载整个网页的情况下，对网页的某部分进行更新，更能体现 Web 应用的动态性和实时性。</p><p>AJAX 虽然看起来比较复杂，但还是比较容易理解，整个创建过程的格式都是固定的，需要考虑的主要是事件的触发以及元素的更改，也就是什么时候调用 ajax，以及修改那些数据，通常使用的方法是使用 document.querySelector() 属性选择器来进行操作的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> &gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">//1.建立xmlHttpRequest对象</span></span><br><span class="line"><span class="undefined">//2.使用OPEN方法与服务器建立连接此步注意设置http的请求方式（post/get）</span></span><br><span class="line"><span class="undefined">//3.设置回调函数，在回调函数中针对不同的响应状态进行处理</span></span><br><span class="line"><span class="undefined">//4.向服务器端发送数据， 如果是POST方式就不为空</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">// 可以简写为 var xmlHttp = new XMLHttpRequest();</span></span><br><span class="line"><span class="undefined">if(window.XMLHttpRequest) &#123;</span></span><br><span class="line"><span class="undefined">// 建立xmlHttpRequest对象</span></span><br><span class="line"><span class="undefined">var xmlHttp = new XMLHttpRequest();</span></span><br><span class="line"><span class="undefined">if(xmlHttp.overrideMimeType) &#123;</span></span><br><span class="line"><span class="undefined">xmlHttp.overrideMimeType("text/xml");</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">   &#125;</span></span><br><span class="line"><span class="undefined">    else if(window.ActiveXobject) &#123;</span></span><br><span class="line"><span class="undefined">var activeName = ["MSXML2.XMLHTTP", "Microsoft.XMLHTTP"];</span></span><br><span class="line"><span class="undefined">for(var i = 0; i &lt; activeName.length; i++) &#123;</span></span><br><span class="line"><span class="undefined">try &#123;</span></span><br><span class="line"><span class="undefined">  xmlHttp = new ActiveXobject(activeName[i]);</span></span><br><span class="line"><span class="undefined">  break;</span></span><br><span class="line"><span class="undefined"> &#125; catch(e) &#123;&#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">   &#125;</span></span><br><span class="line"><span class="undefined">   if(!xmlHttp) &#123;</span></span><br><span class="line"><span class="undefined">alert("创建xmlhttprequest对象失败");</span></span><br><span class="line"><span class="undefined">   &#125;</span></span><br><span class="line"><span class="undefined">else &#123;&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">// 如果是POST方式，注意设置请求头信息, GET方式可以不设置</span></span><br><span class="line"><span class="undefined">// xmlHttp.setRequestHeader("Content-Type","application/x-www-form-urlencoded")</span></span><br><span class="line"><span class="undefined">xmlHttp.open("get","getData.php?name="+ name,true)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">// 设置回调函数</span></span><br><span class="line"><span class="undefined">xmlHttp.onreadystatechange= callback;</span></span><br><span class="line"><span class="undefined">function callback()&#123;</span></span><br><span class="line"><span class="undefined">if(xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200)&#123;      </span></span><br><span class="line"><span class="undefined">//判断交互是否成功获取服务器返回的数据 </span></span><br><span class="line"><span class="undefined">var responseText =xmlHttp.responseText;</span></span><br><span class="line"><span class="undefined">document.getElementById("info").innerHTML = responseText;</span></span><br><span class="line"><span class="undefined">   &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">//向服务器端发送数据</span></span><br><span class="line"><span class="undefined">xmlHttp.send(null);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过实际上手，自己也尝试了一些 JS 的编写，其实大多数编程的一个套路，只要思想了解了，稍微了解一些语法就能实现一些简单的功能，重要的是多尝试和多实践。</p><h3 id="0x03-Bootstrap-框架"><a href="#0x03-Bootstrap-框架" class="headerlink" title="0x03 Bootstrap 框架"></a>0x03 Bootstrap 框架</h3><p>Bootstrap 是目前最受欢迎的前端框架，是基于HTML，CSS， JavaScript的。开发框架最主要的目的就是方便开发，提供一些列通过模板，开发者可以通过引用修改，完成自己的功能，不需要自己重复早轮子。</p><p>之前我也重来没有接触过前端框架，也不知道该如何使用，通过这次亲手实践，对前端框架有了一个更深入的了解。在使用Bootstrap的时候只需要访问它的官网，可以下载源码，也可以直接使用BootstrapCDN将预编译的 CSS 或 JS 文件引入页面。网站还提供了一些样式，自己可以选择自己需要的进行修改使用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>在线尝试 Bootstrap 实例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css"</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="0x04-XML和JSON"><a href="#0x04-XML和JSON" class="headerlink" title="0x04 XML和JSON"></a>0x04 XML和JSON</h3><p>在 Web 开发中不可避免需要与数据进行交互，最典型的两种数据格式是xml 和 json。xml 实际上是一种扩展性标记语言，可以标记数据和定义数据类型。而json则是一种轻量级的数据交换格式，可在不同平台之间进行数据交换。两者各有优缺点，但是在对数据进行解析时 json 要稍微容易些，可读性也更强。</p><p>在实际开发中，包括后端开发中数据格式也常常为JSON。下面通过两个实例进行比较一下：</p><p><1>.用XML表示中国部分省市数据如下：</1></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">country</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>中国<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">province</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>云南<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">citys</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">city</span>&gt;</span>保山<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">city</span>&gt;</span>昆明<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">citys</span>&gt;</span>  　　</span><br><span class="line">  <span class="tag">&lt;/<span class="name">province</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">province</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>四川<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">citys</span>&gt;</span></span><br><span class="line">      　<span class="tag">&lt;<span class="name">city</span>&gt;</span>成都<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line">      　<span class="tag">&lt;<span class="name">city</span>&gt;</span>乐山<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">citys</span>&gt;</span>　</span><br><span class="line">  <span class="tag">&lt;/<span class="name">province</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">province</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>新疆<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">citys</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">city</span>&gt;</span>乌鲁木齐<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">citys</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">province</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">country</span>&gt;</span></span><br></pre></td></tr></table></figure><p><2>.用JSON表示中国部分省市数据如下：</2></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var country =</span><br><span class="line">        &#123;</span><br><span class="line">            name: "中国",</span><br><span class="line">            provinces: [</span><br><span class="line">            &#123; name: "云南", citys: &#123; city: ["保山", "昆明"]&#125; &#125;, </span><br><span class="line">            &#123; name: "四川", citys: &#123; city: ["成都", "乐山"]&#125; &#125;,</span><br><span class="line">            &#123; name: "新疆", citys: &#123; city: ["乌鲁木齐"]&#125; &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="0x05-PHP-真好！"><a href="#0x05-PHP-真好！" class="headerlink" title="0x05 PHP 真好！"></a>0x05 PHP 真好！</h3><p>在进行Web开发时，前端的问题解决了，就需要考虑后端服务器的问题，如果构建动态网页的话，不可避免的需要与服务器进行数据交互，一般情况下后端代码都是后端程序员编写，然后会留出一些接口给前端程序员调用。</p><p>这次网页的编写因为需要进行数据交互，所以我尝试了最容易上手的服务器脚本语言PHP，毕竟它是最好的编程语言嘛，虽然之前一直在说这个梗，但一直没有去接触了解，现在尝试了一些，果然是好用啊。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">//第一个PHP代码</span></span><br><span class="line"><span class="comment">//设置页面编码格式</span></span><br><span class="line">header(<span class="string">'content-type:text/html;charset=utf-8'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"hello PHP"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;br&gt;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"PHP 是世界上最好的语言！"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;br&gt;'</span>;</span><br><span class="line"></span><br><span class="line">$name = <span class="string">"ppd"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"name: $name"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>($i = <span class="number">0</span>; $i &lt; <span class="number">10</span>; $i++)&#123;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"666"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h3 id="0x06-小结一下"><a href="#0x06-小结一下" class="headerlink" title="0x06 小结一下"></a>0x06 小结一下</h3><p>经过不断踩坑尝试，了解和学到了很多东西，其实很多东西比想象中的要容易，在没有动手做之前总觉得什么都太难，也不想去尝试，其实迈出第一步，后面会好很多。</p><p>解决问题的能力很重要，要把学习和解决问题划分开，学习需要的循序渐进，系统掌握。而解决问题更重的是针对问题本身，找到其解决的办法，最常用的方法莫过于搜索查找。前者是理论基础，后者是实践经验，二者都需要培养提高。</p><p>差不多根据自己了解的前端开发做了一个总结，内容都是很基础很简单的，如果深入的学习了解可能会有更多的发现和感悟。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录一下近期的学习心得，由于参加一个比赛需要一个简单的web页面来展示结果，所以需要取学习一些前端的开发的技术。之前也看过一些 web 页面的知识，但没有亲自去尝试过，这次正好有机会去进行更深入的了解。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="http://smallseven.top/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="前端" scheme="http://smallseven.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
